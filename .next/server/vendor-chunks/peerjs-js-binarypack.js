"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/peerjs-js-binarypack";
exports.ids = ["vendor-chunks/peerjs-js-binarypack"];
exports.modules = {

/***/ "(ssr)/./node_modules/peerjs-js-binarypack/dist/binarypack.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/peerjs-js-binarypack/dist/binarypack.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Packer: () => (/* binding */ $0cfd7828ad59115f$export$b9ec4b114aa40074),\n/* harmony export */   pack: () => (/* binding */ $0cfd7828ad59115f$export$2a703dbb0cb35339),\n/* harmony export */   unpack: () => (/* binding */ $0cfd7828ad59115f$export$417857010dc9287f)\n/* harmony export */ });\nclass $e8379818650e2442$export$93654d4f2d6cd524 {\n    constructor(){\n        this.encoder = new TextEncoder();\n        this._pieces = [];\n        this._parts = [];\n    }\n    append_buffer(data) {\n        this.flush();\n        this._parts.push(data);\n    }\n    append(data) {\n        this._pieces.push(data);\n    }\n    flush() {\n        if (this._pieces.length > 0) {\n            const buf = new Uint8Array(this._pieces);\n            this._parts.push(buf);\n            this._pieces = [];\n        }\n    }\n    toArrayBuffer() {\n        const buffer = [];\n        for (const part of this._parts)buffer.push(part);\n        return $e8379818650e2442$var$concatArrayBuffers(buffer).buffer;\n    }\n}\nfunction $e8379818650e2442$var$concatArrayBuffers(bufs) {\n    let size = 0;\n    for (const buf of bufs)size += buf.byteLength;\n    const result = new Uint8Array(size);\n    let offset = 0;\n    for (const buf of bufs){\n        const view = new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);\n        result.set(view, offset);\n        offset += buf.byteLength;\n    }\n    return result;\n}\n\n\nfunction $0cfd7828ad59115f$export$417857010dc9287f(data) {\n    const unpacker = new $0cfd7828ad59115f$var$Unpacker(data);\n    return unpacker.unpack();\n}\nfunction $0cfd7828ad59115f$export$2a703dbb0cb35339(data) {\n    const packer = new $0cfd7828ad59115f$export$b9ec4b114aa40074();\n    const res = packer.pack(data);\n    if (res instanceof Promise) return res.then(()=>packer.getBuffer());\n    return packer.getBuffer();\n}\nclass $0cfd7828ad59115f$var$Unpacker {\n    constructor(data){\n        this.index = 0;\n        this.dataBuffer = data;\n        this.dataView = new Uint8Array(this.dataBuffer);\n        this.length = this.dataBuffer.byteLength;\n    }\n    unpack() {\n        const type = this.unpack_uint8();\n        if (type < 0x80) return type;\n        else if ((type ^ 0xe0) < 0x20) return (type ^ 0xe0) - 0x20;\n        let size;\n        if ((size = type ^ 0xa0) <= 0x0f) return this.unpack_raw(size);\n        else if ((size = type ^ 0xb0) <= 0x0f) return this.unpack_string(size);\n        else if ((size = type ^ 0x90) <= 0x0f) return this.unpack_array(size);\n        else if ((size = type ^ 0x80) <= 0x0f) return this.unpack_map(size);\n        switch(type){\n            case 0xc0:\n                return null;\n            case 0xc1:\n                return undefined;\n            case 0xc2:\n                return false;\n            case 0xc3:\n                return true;\n            case 0xca:\n                return this.unpack_float();\n            case 0xcb:\n                return this.unpack_double();\n            case 0xcc:\n                return this.unpack_uint8();\n            case 0xcd:\n                return this.unpack_uint16();\n            case 0xce:\n                return this.unpack_uint32();\n            case 0xcf:\n                return this.unpack_uint64();\n            case 0xd0:\n                return this.unpack_int8();\n            case 0xd1:\n                return this.unpack_int16();\n            case 0xd2:\n                return this.unpack_int32();\n            case 0xd3:\n                return this.unpack_int64();\n            case 0xd4:\n                return undefined;\n            case 0xd5:\n                return undefined;\n            case 0xd6:\n                return undefined;\n            case 0xd7:\n                return undefined;\n            case 0xd8:\n                size = this.unpack_uint16();\n                return this.unpack_string(size);\n            case 0xd9:\n                size = this.unpack_uint32();\n                return this.unpack_string(size);\n            case 0xda:\n                size = this.unpack_uint16();\n                return this.unpack_raw(size);\n            case 0xdb:\n                size = this.unpack_uint32();\n                return this.unpack_raw(size);\n            case 0xdc:\n                size = this.unpack_uint16();\n                return this.unpack_array(size);\n            case 0xdd:\n                size = this.unpack_uint32();\n                return this.unpack_array(size);\n            case 0xde:\n                size = this.unpack_uint16();\n                return this.unpack_map(size);\n            case 0xdf:\n                size = this.unpack_uint32();\n                return this.unpack_map(size);\n        }\n    }\n    unpack_uint8() {\n        const byte = this.dataView[this.index] & 0xff;\n        this.index++;\n        return byte;\n    }\n    unpack_uint16() {\n        const bytes = this.read(2);\n        const uint16 = (bytes[0] & 0xff) * 256 + (bytes[1] & 0xff);\n        this.index += 2;\n        return uint16;\n    }\n    unpack_uint32() {\n        const bytes = this.read(4);\n        const uint32 = ((bytes[0] * 256 + bytes[1]) * 256 + bytes[2]) * 256 + bytes[3];\n        this.index += 4;\n        return uint32;\n    }\n    unpack_uint64() {\n        const bytes = this.read(8);\n        const uint64 = ((((((bytes[0] * 256 + bytes[1]) * 256 + bytes[2]) * 256 + bytes[3]) * 256 + bytes[4]) * 256 + bytes[5]) * 256 + bytes[6]) * 256 + bytes[7];\n        this.index += 8;\n        return uint64;\n    }\n    unpack_int8() {\n        const uint8 = this.unpack_uint8();\n        return uint8 < 0x80 ? uint8 : uint8 - 256;\n    }\n    unpack_int16() {\n        const uint16 = this.unpack_uint16();\n        return uint16 < 0x8000 ? uint16 : uint16 - 65536;\n    }\n    unpack_int32() {\n        const uint32 = this.unpack_uint32();\n        return uint32 < 2 ** 31 ? uint32 : uint32 - 2 ** 32;\n    }\n    unpack_int64() {\n        const uint64 = this.unpack_uint64();\n        return uint64 < 2 ** 63 ? uint64 : uint64 - 2 ** 64;\n    }\n    unpack_raw(size) {\n        if (this.length < this.index + size) throw new Error(`BinaryPackFailure: index is out of range ${this.index} ${size} ${this.length}`);\n        const buf = this.dataBuffer.slice(this.index, this.index + size);\n        this.index += size;\n        return buf;\n    }\n    unpack_string(size) {\n        const bytes = this.read(size);\n        let i = 0;\n        let str = \"\";\n        let c;\n        let code;\n        while(i < size){\n            c = bytes[i];\n            // The length of a UTF-8 sequence is specified in the first byte:\n            // 0xxxxxxx means length 1,\n            // 110xxxxx means length 2,\n            // 1110xxxx means length 3,\n            // 11110xxx means length 4.\n            // 10xxxxxx is for non-initial bytes.\n            if (c < 0xa0) {\n                // One-byte sequence: bits 0xxxxxxx\n                code = c;\n                i++;\n            } else if ((c ^ 0xc0) < 0x20) {\n                // Two-byte sequence: bits 110xxxxx 10xxxxxx\n                code = (c & 0x1f) << 6 | bytes[i + 1] & 0x3f;\n                i += 2;\n            } else if ((c ^ 0xe0) < 0x10) {\n                // Three-byte sequence: bits 1110xxxx 10xxxxxx 10xxxxxx\n                code = (c & 0x0f) << 12 | (bytes[i + 1] & 0x3f) << 6 | bytes[i + 2] & 0x3f;\n                i += 3;\n            } else {\n                // Four-byte sequence: bits 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n                code = (c & 0x07) << 18 | (bytes[i + 1] & 0x3f) << 12 | (bytes[i + 2] & 0x3f) << 6 | bytes[i + 3] & 0x3f;\n                i += 4;\n            }\n            str += String.fromCodePoint(code);\n        }\n        this.index += size;\n        return str;\n    }\n    unpack_array(size) {\n        const objects = new Array(size);\n        for(let i = 0; i < size; i++)objects[i] = this.unpack();\n        return objects;\n    }\n    unpack_map(size) {\n        const map = {};\n        for(let i = 0; i < size; i++){\n            const key = this.unpack();\n            map[key] = this.unpack();\n        }\n        return map;\n    }\n    unpack_float() {\n        const uint32 = this.unpack_uint32();\n        const sign = uint32 >> 31;\n        const exp = (uint32 >> 23 & 0xff) - 127;\n        const fraction = uint32 & 0x7fffff | 0x800000;\n        return (sign === 0 ? 1 : -1) * fraction * 2 ** (exp - 23);\n    }\n    unpack_double() {\n        const h32 = this.unpack_uint32();\n        const l32 = this.unpack_uint32();\n        const sign = h32 >> 31;\n        const exp = (h32 >> 20 & 0x7ff) - 1023;\n        const hfrac = h32 & 0xfffff | 0x100000;\n        const frac = hfrac * 2 ** (exp - 20) + l32 * 2 ** (exp - 52);\n        return (sign === 0 ? 1 : -1) * frac;\n    }\n    read(length) {\n        const j = this.index;\n        if (j + length <= this.length) return this.dataView.subarray(j, j + length);\n        else throw new Error(\"BinaryPackFailure: read index out of range\");\n    }\n}\nclass $0cfd7828ad59115f$export$b9ec4b114aa40074 {\n    getBuffer() {\n        return this._bufferBuilder.toArrayBuffer();\n    }\n    pack(value) {\n        if (typeof value === \"string\") this.pack_string(value);\n        else if (typeof value === \"number\") {\n            if (Math.floor(value) === value) this.pack_integer(value);\n            else this.pack_double(value);\n        } else if (typeof value === \"boolean\") {\n            if (value === true) this._bufferBuilder.append(0xc3);\n            else if (value === false) this._bufferBuilder.append(0xc2);\n        } else if (value === undefined) this._bufferBuilder.append(0xc0);\n        else if (typeof value === \"object\") {\n            if (value === null) this._bufferBuilder.append(0xc0);\n            else {\n                const constructor = value.constructor;\n                if (value instanceof Array) {\n                    const res = this.pack_array(value);\n                    if (res instanceof Promise) return res.then(()=>this._bufferBuilder.flush());\n                } else if (value instanceof ArrayBuffer) this.pack_bin(new Uint8Array(value));\n                else if (\"BYTES_PER_ELEMENT\" in value) {\n                    const v = value;\n                    this.pack_bin(new Uint8Array(v.buffer, v.byteOffset, v.byteLength));\n                } else if (value instanceof Date) this.pack_string(value.toString());\n                else if (value instanceof Blob) return value.arrayBuffer().then((buffer)=>{\n                    this.pack_bin(new Uint8Array(buffer));\n                    this._bufferBuilder.flush();\n                });\n                else if (constructor == Object || constructor.toString().startsWith(\"class\")) {\n                    const res = this.pack_object(value);\n                    if (res instanceof Promise) return res.then(()=>this._bufferBuilder.flush());\n                } else throw new Error(`Type \"${constructor.toString()}\" not yet supported`);\n            }\n        } else throw new Error(`Type \"${typeof value}\" not yet supported`);\n        this._bufferBuilder.flush();\n    }\n    pack_bin(blob) {\n        const length = blob.length;\n        if (length <= 0x0f) this.pack_uint8(0xa0 + length);\n        else if (length <= 0xffff) {\n            this._bufferBuilder.append(0xda);\n            this.pack_uint16(length);\n        } else if (length <= 0xffffffff) {\n            this._bufferBuilder.append(0xdb);\n            this.pack_uint32(length);\n        } else throw new Error(\"Invalid length\");\n        this._bufferBuilder.append_buffer(blob);\n    }\n    pack_string(str) {\n        const encoded = this._textEncoder.encode(str);\n        const length = encoded.length;\n        if (length <= 0x0f) this.pack_uint8(0xb0 + length);\n        else if (length <= 0xffff) {\n            this._bufferBuilder.append(0xd8);\n            this.pack_uint16(length);\n        } else if (length <= 0xffffffff) {\n            this._bufferBuilder.append(0xd9);\n            this.pack_uint32(length);\n        } else throw new Error(\"Invalid length\");\n        this._bufferBuilder.append_buffer(encoded);\n    }\n    pack_array(ary) {\n        const length = ary.length;\n        if (length <= 0x0f) this.pack_uint8(0x90 + length);\n        else if (length <= 0xffff) {\n            this._bufferBuilder.append(0xdc);\n            this.pack_uint16(length);\n        } else if (length <= 0xffffffff) {\n            this._bufferBuilder.append(0xdd);\n            this.pack_uint32(length);\n        } else throw new Error(\"Invalid length\");\n        const packNext = (index)=>{\n            if (index < length) {\n                const res = this.pack(ary[index]);\n                if (res instanceof Promise) return res.then(()=>packNext(index + 1));\n                return packNext(index + 1);\n            }\n        };\n        return packNext(0);\n    }\n    pack_integer(num) {\n        if (num >= -32 && num <= 0x7f) this._bufferBuilder.append(num & 0xff);\n        else if (num >= 0x00 && num <= 0xff) {\n            this._bufferBuilder.append(0xcc);\n            this.pack_uint8(num);\n        } else if (num >= -128 && num <= 0x7f) {\n            this._bufferBuilder.append(0xd0);\n            this.pack_int8(num);\n        } else if (num >= 0x0000 && num <= 0xffff) {\n            this._bufferBuilder.append(0xcd);\n            this.pack_uint16(num);\n        } else if (num >= -32768 && num <= 0x7fff) {\n            this._bufferBuilder.append(0xd1);\n            this.pack_int16(num);\n        } else if (num >= 0x00000000 && num <= 0xffffffff) {\n            this._bufferBuilder.append(0xce);\n            this.pack_uint32(num);\n        } else if (num >= -2147483648 && num <= 0x7fffffff) {\n            this._bufferBuilder.append(0xd2);\n            this.pack_int32(num);\n        } else if (num >= -9223372036854776000 && num <= 0x7fffffffffffffff) {\n            this._bufferBuilder.append(0xd3);\n            this.pack_int64(num);\n        } else if (num >= 0x0000000000000000 && num <= 0xffffffffffffffff) {\n            this._bufferBuilder.append(0xcf);\n            this.pack_uint64(num);\n        } else throw new Error(\"Invalid integer\");\n    }\n    pack_double(num) {\n        let sign = 0;\n        if (num < 0) {\n            sign = 1;\n            num = -num;\n        }\n        const exp = Math.floor(Math.log(num) / Math.LN2);\n        const frac0 = num / 2 ** exp - 1;\n        const frac1 = Math.floor(frac0 * 2 ** 52);\n        const b32 = 2 ** 32;\n        const h32 = sign << 31 | exp + 1023 << 20 | frac1 / b32 & 0x0fffff;\n        const l32 = frac1 % b32;\n        this._bufferBuilder.append(0xcb);\n        this.pack_int32(h32);\n        this.pack_int32(l32);\n    }\n    pack_object(obj) {\n        const keys = Object.keys(obj);\n        const length = keys.length;\n        if (length <= 0x0f) this.pack_uint8(0x80 + length);\n        else if (length <= 0xffff) {\n            this._bufferBuilder.append(0xde);\n            this.pack_uint16(length);\n        } else if (length <= 0xffffffff) {\n            this._bufferBuilder.append(0xdf);\n            this.pack_uint32(length);\n        } else throw new Error(\"Invalid length\");\n        const packNext = (index)=>{\n            if (index < keys.length) {\n                const prop = keys[index];\n                // eslint-disable-next-line no-prototype-builtins\n                if (obj.hasOwnProperty(prop)) {\n                    this.pack(prop);\n                    const res = this.pack(obj[prop]);\n                    if (res instanceof Promise) return res.then(()=>packNext(index + 1));\n                }\n                return packNext(index + 1);\n            }\n        };\n        return packNext(0);\n    }\n    pack_uint8(num) {\n        this._bufferBuilder.append(num);\n    }\n    pack_uint16(num) {\n        this._bufferBuilder.append(num >> 8);\n        this._bufferBuilder.append(num & 0xff);\n    }\n    pack_uint32(num) {\n        const n = num & 0xffffffff;\n        this._bufferBuilder.append((n & 0xff000000) >>> 24);\n        this._bufferBuilder.append((n & 0x00ff0000) >>> 16);\n        this._bufferBuilder.append((n & 0x0000ff00) >>> 8);\n        this._bufferBuilder.append(n & 0x000000ff);\n    }\n    pack_uint64(num) {\n        const high = num / 2 ** 32;\n        const low = num % 2 ** 32;\n        this._bufferBuilder.append((high & 0xff000000) >>> 24);\n        this._bufferBuilder.append((high & 0x00ff0000) >>> 16);\n        this._bufferBuilder.append((high & 0x0000ff00) >>> 8);\n        this._bufferBuilder.append(high & 0x000000ff);\n        this._bufferBuilder.append((low & 0xff000000) >>> 24);\n        this._bufferBuilder.append((low & 0x00ff0000) >>> 16);\n        this._bufferBuilder.append((low & 0x0000ff00) >>> 8);\n        this._bufferBuilder.append(low & 0x000000ff);\n    }\n    pack_int8(num) {\n        this._bufferBuilder.append(num & 0xff);\n    }\n    pack_int16(num) {\n        this._bufferBuilder.append((num & 0xff00) >> 8);\n        this._bufferBuilder.append(num & 0xff);\n    }\n    pack_int32(num) {\n        this._bufferBuilder.append(num >>> 24 & 0xff);\n        this._bufferBuilder.append((num & 0x00ff0000) >>> 16);\n        this._bufferBuilder.append((num & 0x0000ff00) >>> 8);\n        this._bufferBuilder.append(num & 0x000000ff);\n    }\n    pack_int64(num) {\n        const high = Math.floor(num / 2 ** 32);\n        const low = num % 2 ** 32;\n        this._bufferBuilder.append((high & 0xff000000) >>> 24);\n        this._bufferBuilder.append((high & 0x00ff0000) >>> 16);\n        this._bufferBuilder.append((high & 0x0000ff00) >>> 8);\n        this._bufferBuilder.append(high & 0x000000ff);\n        this._bufferBuilder.append((low & 0xff000000) >>> 24);\n        this._bufferBuilder.append((low & 0x00ff0000) >>> 16);\n        this._bufferBuilder.append((low & 0x0000ff00) >>> 8);\n        this._bufferBuilder.append(low & 0x000000ff);\n    }\n    constructor(){\n        this._bufferBuilder = new (0, $e8379818650e2442$export$93654d4f2d6cd524)();\n        this._textEncoder = new TextEncoder();\n    }\n}\n\n\n\n//# sourceMappingURL=binarypack.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcGVlcmpzLWpzLWJpbmFyeXBhY2svZGlzdC9iaW5hcnlwYWNrLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5R0FBeUcsWUFBWSxFQUFFLE1BQU0sRUFBRSxZQUFZO0FBQzNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixVQUFVO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFVBQVU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsOEJBQThCLHVCQUF1QjtBQUN2RTtBQUNBLFVBQVUsOEJBQThCLGFBQWE7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdxSztBQUNySyIsInNvdXJjZXMiOlsid2VicGFjazovL3BpY3RvLWd1ZXNzLy4vbm9kZV9tb2R1bGVzL3BlZXJqcy1qcy1iaW5hcnlwYWNrL2Rpc3QvYmluYXJ5cGFjay5tanM/YTU2NCJdLCJzb3VyY2VzQ29udGVudCI6WyJjbGFzcyAkZTgzNzk4MTg2NTBlMjQ0MiRleHBvcnQkOTM2NTRkNGYyZDZjZDUyNCB7XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgdGhpcy5lbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgICAgIHRoaXMuX3BpZWNlcyA9IFtdO1xuICAgICAgICB0aGlzLl9wYXJ0cyA9IFtdO1xuICAgIH1cbiAgICBhcHBlbmRfYnVmZmVyKGRhdGEpIHtcbiAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgICAgICB0aGlzLl9wYXJ0cy5wdXNoKGRhdGEpO1xuICAgIH1cbiAgICBhcHBlbmQoZGF0YSkge1xuICAgICAgICB0aGlzLl9waWVjZXMucHVzaChkYXRhKTtcbiAgICB9XG4gICAgZmx1c2goKSB7XG4gICAgICAgIGlmICh0aGlzLl9waWVjZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgYnVmID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5fcGllY2VzKTtcbiAgICAgICAgICAgIHRoaXMuX3BhcnRzLnB1c2goYnVmKTtcbiAgICAgICAgICAgIHRoaXMuX3BpZWNlcyA9IFtdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvQXJyYXlCdWZmZXIoKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgdGhpcy5fcGFydHMpYnVmZmVyLnB1c2gocGFydCk7XG4gICAgICAgIHJldHVybiAkZTgzNzk4MTg2NTBlMjQ0MiR2YXIkY29uY2F0QXJyYXlCdWZmZXJzKGJ1ZmZlcikuYnVmZmVyO1xuICAgIH1cbn1cbmZ1bmN0aW9uICRlODM3OTgxODY1MGUyNDQyJHZhciRjb25jYXRBcnJheUJ1ZmZlcnMoYnVmcykge1xuICAgIGxldCBzaXplID0gMDtcbiAgICBmb3IgKGNvbnN0IGJ1ZiBvZiBidWZzKXNpemUgKz0gYnVmLmJ5dGVMZW5ndGg7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSk7XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgZm9yIChjb25zdCBidWYgb2YgYnVmcyl7XG4gICAgICAgIGNvbnN0IHZpZXcgPSBuZXcgVWludDhBcnJheShidWYuYnVmZmVyLCBidWYuYnl0ZU9mZnNldCwgYnVmLmJ5dGVMZW5ndGgpO1xuICAgICAgICByZXN1bHQuc2V0KHZpZXcsIG9mZnNldCk7XG4gICAgICAgIG9mZnNldCArPSBidWYuYnl0ZUxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuXG5mdW5jdGlvbiAkMGNmZDc4MjhhZDU5MTE1ZiRleHBvcnQkNDE3ODU3MDEwZGM5Mjg3ZihkYXRhKSB7XG4gICAgY29uc3QgdW5wYWNrZXIgPSBuZXcgJDBjZmQ3ODI4YWQ1OTExNWYkdmFyJFVucGFja2VyKGRhdGEpO1xuICAgIHJldHVybiB1bnBhY2tlci51bnBhY2soKTtcbn1cbmZ1bmN0aW9uICQwY2ZkNzgyOGFkNTkxMTVmJGV4cG9ydCQyYTcwM2RiYjBjYjM1MzM5KGRhdGEpIHtcbiAgICBjb25zdCBwYWNrZXIgPSBuZXcgJDBjZmQ3ODI4YWQ1OTExNWYkZXhwb3J0JGI5ZWM0YjExNGFhNDAwNzQoKTtcbiAgICBjb25zdCByZXMgPSBwYWNrZXIucGFjayhkYXRhKTtcbiAgICBpZiAocmVzIGluc3RhbmNlb2YgUHJvbWlzZSkgcmV0dXJuIHJlcy50aGVuKCgpPT5wYWNrZXIuZ2V0QnVmZmVyKCkpO1xuICAgIHJldHVybiBwYWNrZXIuZ2V0QnVmZmVyKCk7XG59XG5jbGFzcyAkMGNmZDc4MjhhZDU5MTE1ZiR2YXIkVW5wYWNrZXIge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEpe1xuICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5kYXRhQnVmZmVyID0gZGF0YTtcbiAgICAgICAgdGhpcy5kYXRhVmlldyA9IG5ldyBVaW50OEFycmF5KHRoaXMuZGF0YUJ1ZmZlcik7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gdGhpcy5kYXRhQnVmZmVyLmJ5dGVMZW5ndGg7XG4gICAgfVxuICAgIHVucGFjaygpIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IHRoaXMudW5wYWNrX3VpbnQ4KCk7XG4gICAgICAgIGlmICh0eXBlIDwgMHg4MCkgcmV0dXJuIHR5cGU7XG4gICAgICAgIGVsc2UgaWYgKCh0eXBlIF4gMHhlMCkgPCAweDIwKSByZXR1cm4gKHR5cGUgXiAweGUwKSAtIDB4MjA7XG4gICAgICAgIGxldCBzaXplO1xuICAgICAgICBpZiAoKHNpemUgPSB0eXBlIF4gMHhhMCkgPD0gMHgwZikgcmV0dXJuIHRoaXMudW5wYWNrX3JhdyhzaXplKTtcbiAgICAgICAgZWxzZSBpZiAoKHNpemUgPSB0eXBlIF4gMHhiMCkgPD0gMHgwZikgcmV0dXJuIHRoaXMudW5wYWNrX3N0cmluZyhzaXplKTtcbiAgICAgICAgZWxzZSBpZiAoKHNpemUgPSB0eXBlIF4gMHg5MCkgPD0gMHgwZikgcmV0dXJuIHRoaXMudW5wYWNrX2FycmF5KHNpemUpO1xuICAgICAgICBlbHNlIGlmICgoc2l6ZSA9IHR5cGUgXiAweDgwKSA8PSAweDBmKSByZXR1cm4gdGhpcy51bnBhY2tfbWFwKHNpemUpO1xuICAgICAgICBzd2l0Y2godHlwZSl7XG4gICAgICAgICAgICBjYXNlIDB4YzA6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBjYXNlIDB4YzE6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNhc2UgMHhjMjpcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBjYXNlIDB4YzM6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBjYXNlIDB4Y2E6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudW5wYWNrX2Zsb2F0KCk7XG4gICAgICAgICAgICBjYXNlIDB4Y2I6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudW5wYWNrX2RvdWJsZSgpO1xuICAgICAgICAgICAgY2FzZSAweGNjOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnVucGFja191aW50OCgpO1xuICAgICAgICAgICAgY2FzZSAweGNkOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnVucGFja191aW50MTYoKTtcbiAgICAgICAgICAgIGNhc2UgMHhjZTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy51bnBhY2tfdWludDMyKCk7XG4gICAgICAgICAgICBjYXNlIDB4Y2Y6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudW5wYWNrX3VpbnQ2NCgpO1xuICAgICAgICAgICAgY2FzZSAweGQwOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnVucGFja19pbnQ4KCk7XG4gICAgICAgICAgICBjYXNlIDB4ZDE6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudW5wYWNrX2ludDE2KCk7XG4gICAgICAgICAgICBjYXNlIDB4ZDI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudW5wYWNrX2ludDMyKCk7XG4gICAgICAgICAgICBjYXNlIDB4ZDM6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudW5wYWNrX2ludDY0KCk7XG4gICAgICAgICAgICBjYXNlIDB4ZDQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNhc2UgMHhkNTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgY2FzZSAweGQ2OlxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjYXNlIDB4ZDc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNhc2UgMHhkODpcbiAgICAgICAgICAgICAgICBzaXplID0gdGhpcy51bnBhY2tfdWludDE2KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudW5wYWNrX3N0cmluZyhzaXplKTtcbiAgICAgICAgICAgIGNhc2UgMHhkOTpcbiAgICAgICAgICAgICAgICBzaXplID0gdGhpcy51bnBhY2tfdWludDMyKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudW5wYWNrX3N0cmluZyhzaXplKTtcbiAgICAgICAgICAgIGNhc2UgMHhkYTpcbiAgICAgICAgICAgICAgICBzaXplID0gdGhpcy51bnBhY2tfdWludDE2KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudW5wYWNrX3JhdyhzaXplKTtcbiAgICAgICAgICAgIGNhc2UgMHhkYjpcbiAgICAgICAgICAgICAgICBzaXplID0gdGhpcy51bnBhY2tfdWludDMyKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudW5wYWNrX3JhdyhzaXplKTtcbiAgICAgICAgICAgIGNhc2UgMHhkYzpcbiAgICAgICAgICAgICAgICBzaXplID0gdGhpcy51bnBhY2tfdWludDE2KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudW5wYWNrX2FycmF5KHNpemUpO1xuICAgICAgICAgICAgY2FzZSAweGRkOlxuICAgICAgICAgICAgICAgIHNpemUgPSB0aGlzLnVucGFja191aW50MzIoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy51bnBhY2tfYXJyYXkoc2l6ZSk7XG4gICAgICAgICAgICBjYXNlIDB4ZGU6XG4gICAgICAgICAgICAgICAgc2l6ZSA9IHRoaXMudW5wYWNrX3VpbnQxNigpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnVucGFja19tYXAoc2l6ZSk7XG4gICAgICAgICAgICBjYXNlIDB4ZGY6XG4gICAgICAgICAgICAgICAgc2l6ZSA9IHRoaXMudW5wYWNrX3VpbnQzMigpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnVucGFja19tYXAoc2l6ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdW5wYWNrX3VpbnQ4KCkge1xuICAgICAgICBjb25zdCBieXRlID0gdGhpcy5kYXRhVmlld1t0aGlzLmluZGV4XSAmIDB4ZmY7XG4gICAgICAgIHRoaXMuaW5kZXgrKztcbiAgICAgICAgcmV0dXJuIGJ5dGU7XG4gICAgfVxuICAgIHVucGFja191aW50MTYoKSB7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gdGhpcy5yZWFkKDIpO1xuICAgICAgICBjb25zdCB1aW50MTYgPSAoYnl0ZXNbMF0gJiAweGZmKSAqIDI1NiArIChieXRlc1sxXSAmIDB4ZmYpO1xuICAgICAgICB0aGlzLmluZGV4ICs9IDI7XG4gICAgICAgIHJldHVybiB1aW50MTY7XG4gICAgfVxuICAgIHVucGFja191aW50MzIoKSB7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gdGhpcy5yZWFkKDQpO1xuICAgICAgICBjb25zdCB1aW50MzIgPSAoKGJ5dGVzWzBdICogMjU2ICsgYnl0ZXNbMV0pICogMjU2ICsgYnl0ZXNbMl0pICogMjU2ICsgYnl0ZXNbM107XG4gICAgICAgIHRoaXMuaW5kZXggKz0gNDtcbiAgICAgICAgcmV0dXJuIHVpbnQzMjtcbiAgICB9XG4gICAgdW5wYWNrX3VpbnQ2NCgpIHtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSB0aGlzLnJlYWQoOCk7XG4gICAgICAgIGNvbnN0IHVpbnQ2NCA9ICgoKCgoKGJ5dGVzWzBdICogMjU2ICsgYnl0ZXNbMV0pICogMjU2ICsgYnl0ZXNbMl0pICogMjU2ICsgYnl0ZXNbM10pICogMjU2ICsgYnl0ZXNbNF0pICogMjU2ICsgYnl0ZXNbNV0pICogMjU2ICsgYnl0ZXNbNl0pICogMjU2ICsgYnl0ZXNbN107XG4gICAgICAgIHRoaXMuaW5kZXggKz0gODtcbiAgICAgICAgcmV0dXJuIHVpbnQ2NDtcbiAgICB9XG4gICAgdW5wYWNrX2ludDgoKSB7XG4gICAgICAgIGNvbnN0IHVpbnQ4ID0gdGhpcy51bnBhY2tfdWludDgoKTtcbiAgICAgICAgcmV0dXJuIHVpbnQ4IDwgMHg4MCA/IHVpbnQ4IDogdWludDggLSAyNTY7XG4gICAgfVxuICAgIHVucGFja19pbnQxNigpIHtcbiAgICAgICAgY29uc3QgdWludDE2ID0gdGhpcy51bnBhY2tfdWludDE2KCk7XG4gICAgICAgIHJldHVybiB1aW50MTYgPCAweDgwMDAgPyB1aW50MTYgOiB1aW50MTYgLSA2NTUzNjtcbiAgICB9XG4gICAgdW5wYWNrX2ludDMyKCkge1xuICAgICAgICBjb25zdCB1aW50MzIgPSB0aGlzLnVucGFja191aW50MzIoKTtcbiAgICAgICAgcmV0dXJuIHVpbnQzMiA8IDIgKiogMzEgPyB1aW50MzIgOiB1aW50MzIgLSAyICoqIDMyO1xuICAgIH1cbiAgICB1bnBhY2tfaW50NjQoKSB7XG4gICAgICAgIGNvbnN0IHVpbnQ2NCA9IHRoaXMudW5wYWNrX3VpbnQ2NCgpO1xuICAgICAgICByZXR1cm4gdWludDY0IDwgMiAqKiA2MyA/IHVpbnQ2NCA6IHVpbnQ2NCAtIDIgKiogNjQ7XG4gICAgfVxuICAgIHVucGFja19yYXcoc2l6ZSkge1xuICAgICAgICBpZiAodGhpcy5sZW5ndGggPCB0aGlzLmluZGV4ICsgc2l6ZSkgdGhyb3cgbmV3IEVycm9yKGBCaW5hcnlQYWNrRmFpbHVyZTogaW5kZXggaXMgb3V0IG9mIHJhbmdlICR7dGhpcy5pbmRleH0gJHtzaXplfSAke3RoaXMubGVuZ3RofWApO1xuICAgICAgICBjb25zdCBidWYgPSB0aGlzLmRhdGFCdWZmZXIuc2xpY2UodGhpcy5pbmRleCwgdGhpcy5pbmRleCArIHNpemUpO1xuICAgICAgICB0aGlzLmluZGV4ICs9IHNpemU7XG4gICAgICAgIHJldHVybiBidWY7XG4gICAgfVxuICAgIHVucGFja19zdHJpbmcoc2l6ZSkge1xuICAgICAgICBjb25zdCBieXRlcyA9IHRoaXMucmVhZChzaXplKTtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBsZXQgc3RyID0gXCJcIjtcbiAgICAgICAgbGV0IGM7XG4gICAgICAgIGxldCBjb2RlO1xuICAgICAgICB3aGlsZShpIDwgc2l6ZSl7XG4gICAgICAgICAgICBjID0gYnl0ZXNbaV07XG4gICAgICAgICAgICAvLyBUaGUgbGVuZ3RoIG9mIGEgVVRGLTggc2VxdWVuY2UgaXMgc3BlY2lmaWVkIGluIHRoZSBmaXJzdCBieXRlOlxuICAgICAgICAgICAgLy8gMHh4eHh4eHggbWVhbnMgbGVuZ3RoIDEsXG4gICAgICAgICAgICAvLyAxMTB4eHh4eCBtZWFucyBsZW5ndGggMixcbiAgICAgICAgICAgIC8vIDExMTB4eHh4IG1lYW5zIGxlbmd0aCAzLFxuICAgICAgICAgICAgLy8gMTExMTB4eHggbWVhbnMgbGVuZ3RoIDQuXG4gICAgICAgICAgICAvLyAxMHh4eHh4eCBpcyBmb3Igbm9uLWluaXRpYWwgYnl0ZXMuXG4gICAgICAgICAgICBpZiAoYyA8IDB4YTApIHtcbiAgICAgICAgICAgICAgICAvLyBPbmUtYnl0ZSBzZXF1ZW5jZTogYml0cyAweHh4eHh4eFxuICAgICAgICAgICAgICAgIGNvZGUgPSBjO1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoKGMgXiAweGMwKSA8IDB4MjApIHtcbiAgICAgICAgICAgICAgICAvLyBUd28tYnl0ZSBzZXF1ZW5jZTogYml0cyAxMTB4eHh4eCAxMHh4eHh4eFxuICAgICAgICAgICAgICAgIGNvZGUgPSAoYyAmIDB4MWYpIDw8IDYgfCBieXRlc1tpICsgMV0gJiAweDNmO1xuICAgICAgICAgICAgICAgIGkgKz0gMjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoKGMgXiAweGUwKSA8IDB4MTApIHtcbiAgICAgICAgICAgICAgICAvLyBUaHJlZS1ieXRlIHNlcXVlbmNlOiBiaXRzIDExMTB4eHh4IDEweHh4eHh4IDEweHh4eHh4XG4gICAgICAgICAgICAgICAgY29kZSA9IChjICYgMHgwZikgPDwgMTIgfCAoYnl0ZXNbaSArIDFdICYgMHgzZikgPDwgNiB8IGJ5dGVzW2kgKyAyXSAmIDB4M2Y7XG4gICAgICAgICAgICAgICAgaSArPSAzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBGb3VyLWJ5dGUgc2VxdWVuY2U6IGJpdHMgMTExMTB4eHggMTB4eHh4eHggMTB4eHh4eHggMTB4eHh4eHhcbiAgICAgICAgICAgICAgICBjb2RlID0gKGMgJiAweDA3KSA8PCAxOCB8IChieXRlc1tpICsgMV0gJiAweDNmKSA8PCAxMiB8IChieXRlc1tpICsgMl0gJiAweDNmKSA8PCA2IHwgYnl0ZXNbaSArIDNdICYgMHgzZjtcbiAgICAgICAgICAgICAgICBpICs9IDQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHIgKz0gU3RyaW5nLmZyb21Db2RlUG9pbnQoY29kZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbmRleCArPSBzaXplO1xuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICB1bnBhY2tfYXJyYXkoc2l6ZSkge1xuICAgICAgICBjb25zdCBvYmplY3RzID0gbmV3IEFycmF5KHNpemUpO1xuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKW9iamVjdHNbaV0gPSB0aGlzLnVucGFjaygpO1xuICAgICAgICByZXR1cm4gb2JqZWN0cztcbiAgICB9XG4gICAgdW5wYWNrX21hcChzaXplKSB7XG4gICAgICAgIGNvbnN0IG1hcCA9IHt9O1xuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKXtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IHRoaXMudW5wYWNrKCk7XG4gICAgICAgICAgICBtYXBba2V5XSA9IHRoaXMudW5wYWNrKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hcDtcbiAgICB9XG4gICAgdW5wYWNrX2Zsb2F0KCkge1xuICAgICAgICBjb25zdCB1aW50MzIgPSB0aGlzLnVucGFja191aW50MzIoKTtcbiAgICAgICAgY29uc3Qgc2lnbiA9IHVpbnQzMiA+PiAzMTtcbiAgICAgICAgY29uc3QgZXhwID0gKHVpbnQzMiA+PiAyMyAmIDB4ZmYpIC0gMTI3O1xuICAgICAgICBjb25zdCBmcmFjdGlvbiA9IHVpbnQzMiAmIDB4N2ZmZmZmIHwgMHg4MDAwMDA7XG4gICAgICAgIHJldHVybiAoc2lnbiA9PT0gMCA/IDEgOiAtMSkgKiBmcmFjdGlvbiAqIDIgKiogKGV4cCAtIDIzKTtcbiAgICB9XG4gICAgdW5wYWNrX2RvdWJsZSgpIHtcbiAgICAgICAgY29uc3QgaDMyID0gdGhpcy51bnBhY2tfdWludDMyKCk7XG4gICAgICAgIGNvbnN0IGwzMiA9IHRoaXMudW5wYWNrX3VpbnQzMigpO1xuICAgICAgICBjb25zdCBzaWduID0gaDMyID4+IDMxO1xuICAgICAgICBjb25zdCBleHAgPSAoaDMyID4+IDIwICYgMHg3ZmYpIC0gMTAyMztcbiAgICAgICAgY29uc3QgaGZyYWMgPSBoMzIgJiAweGZmZmZmIHwgMHgxMDAwMDA7XG4gICAgICAgIGNvbnN0IGZyYWMgPSBoZnJhYyAqIDIgKiogKGV4cCAtIDIwKSArIGwzMiAqIDIgKiogKGV4cCAtIDUyKTtcbiAgICAgICAgcmV0dXJuIChzaWduID09PSAwID8gMSA6IC0xKSAqIGZyYWM7XG4gICAgfVxuICAgIHJlYWQobGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGogPSB0aGlzLmluZGV4O1xuICAgICAgICBpZiAoaiArIGxlbmd0aCA8PSB0aGlzLmxlbmd0aCkgcmV0dXJuIHRoaXMuZGF0YVZpZXcuc3ViYXJyYXkoaiwgaiArIGxlbmd0aCk7XG4gICAgICAgIGVsc2UgdGhyb3cgbmV3IEVycm9yKFwiQmluYXJ5UGFja0ZhaWx1cmU6IHJlYWQgaW5kZXggb3V0IG9mIHJhbmdlXCIpO1xuICAgIH1cbn1cbmNsYXNzICQwY2ZkNzgyOGFkNTkxMTVmJGV4cG9ydCRiOWVjNGIxMTRhYTQwMDc0IHtcbiAgICBnZXRCdWZmZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9idWZmZXJCdWlsZGVyLnRvQXJyYXlCdWZmZXIoKTtcbiAgICB9XG4gICAgcGFjayh2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB0aGlzLnBhY2tfc3RyaW5nKHZhbHVlKTtcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBpZiAoTWF0aC5mbG9vcih2YWx1ZSkgPT09IHZhbHVlKSB0aGlzLnBhY2tfaW50ZWdlcih2YWx1ZSk7XG4gICAgICAgICAgICBlbHNlIHRoaXMucGFja19kb3VibGUodmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdHJ1ZSkgdGhpcy5fYnVmZmVyQnVpbGRlci5hcHBlbmQoMHhjMyk7XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSA9PT0gZmFsc2UpIHRoaXMuX2J1ZmZlckJ1aWxkZXIuYXBwZW5kKDB4YzIpO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHRoaXMuX2J1ZmZlckJ1aWxkZXIuYXBwZW5kKDB4YzApO1xuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkgdGhpcy5fYnVmZmVyQnVpbGRlci5hcHBlbmQoMHhjMCk7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb25zdHJ1Y3RvciA9IHZhbHVlLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcyA9IHRoaXMucGFja19hcnJheSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXMgaW5zdGFuY2VvZiBQcm9taXNlKSByZXR1cm4gcmVzLnRoZW4oKCk9PnRoaXMuX2J1ZmZlckJ1aWxkZXIuZmx1c2goKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB0aGlzLnBhY2tfYmluKG5ldyBVaW50OEFycmF5KHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoXCJCWVRFU19QRVJfRUxFTUVOVFwiIGluIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHYgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYWNrX2JpbihuZXcgVWludDhBcnJheSh2LmJ1ZmZlciwgdi5ieXRlT2Zmc2V0LCB2LmJ5dGVMZW5ndGgpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkgdGhpcy5wYWNrX3N0cmluZyh2YWx1ZS50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEJsb2IpIHJldHVybiB2YWx1ZS5hcnJheUJ1ZmZlcigpLnRoZW4oKGJ1ZmZlcik9PntcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYWNrX2JpbihuZXcgVWludDhBcnJheShidWZmZXIpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYnVmZmVyQnVpbGRlci5mbHVzaCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvbnN0cnVjdG9yID09IE9iamVjdCB8fCBjb25zdHJ1Y3Rvci50b1N0cmluZygpLnN0YXJ0c1dpdGgoXCJjbGFzc1wiKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXMgPSB0aGlzLnBhY2tfb2JqZWN0KHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcyBpbnN0YW5jZW9mIFByb21pc2UpIHJldHVybiByZXMudGhlbigoKT0+dGhpcy5fYnVmZmVyQnVpbGRlci5mbHVzaCgpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgdGhyb3cgbmV3IEVycm9yKGBUeXBlIFwiJHtjb25zdHJ1Y3Rvci50b1N0cmluZygpfVwiIG5vdCB5ZXQgc3VwcG9ydGVkYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB0aHJvdyBuZXcgRXJyb3IoYFR5cGUgXCIke3R5cGVvZiB2YWx1ZX1cIiBub3QgeWV0IHN1cHBvcnRlZGApO1xuICAgICAgICB0aGlzLl9idWZmZXJCdWlsZGVyLmZsdXNoKCk7XG4gICAgfVxuICAgIHBhY2tfYmluKGJsb2IpIHtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gYmxvYi5sZW5ndGg7XG4gICAgICAgIGlmIChsZW5ndGggPD0gMHgwZikgdGhpcy5wYWNrX3VpbnQ4KDB4YTAgKyBsZW5ndGgpO1xuICAgICAgICBlbHNlIGlmIChsZW5ndGggPD0gMHhmZmZmKSB7XG4gICAgICAgICAgICB0aGlzLl9idWZmZXJCdWlsZGVyLmFwcGVuZCgweGRhKTtcbiAgICAgICAgICAgIHRoaXMucGFja191aW50MTYobGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIGlmIChsZW5ndGggPD0gMHhmZmZmZmZmZikge1xuICAgICAgICAgICAgdGhpcy5fYnVmZmVyQnVpbGRlci5hcHBlbmQoMHhkYik7XG4gICAgICAgICAgICB0aGlzLnBhY2tfdWludDMyKGxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGxlbmd0aFwiKTtcbiAgICAgICAgdGhpcy5fYnVmZmVyQnVpbGRlci5hcHBlbmRfYnVmZmVyKGJsb2IpO1xuICAgIH1cbiAgICBwYWNrX3N0cmluZyhzdHIpIHtcbiAgICAgICAgY29uc3QgZW5jb2RlZCA9IHRoaXMuX3RleHRFbmNvZGVyLmVuY29kZShzdHIpO1xuICAgICAgICBjb25zdCBsZW5ndGggPSBlbmNvZGVkLmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbmd0aCA8PSAweDBmKSB0aGlzLnBhY2tfdWludDgoMHhiMCArIGxlbmd0aCk7XG4gICAgICAgIGVsc2UgaWYgKGxlbmd0aCA8PSAweGZmZmYpIHtcbiAgICAgICAgICAgIHRoaXMuX2J1ZmZlckJ1aWxkZXIuYXBwZW5kKDB4ZDgpO1xuICAgICAgICAgICAgdGhpcy5wYWNrX3VpbnQxNihsZW5ndGgpO1xuICAgICAgICB9IGVsc2UgaWYgKGxlbmd0aCA8PSAweGZmZmZmZmZmKSB7XG4gICAgICAgICAgICB0aGlzLl9idWZmZXJCdWlsZGVyLmFwcGVuZCgweGQ5KTtcbiAgICAgICAgICAgIHRoaXMucGFja191aW50MzIobGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbGVuZ3RoXCIpO1xuICAgICAgICB0aGlzLl9idWZmZXJCdWlsZGVyLmFwcGVuZF9idWZmZXIoZW5jb2RlZCk7XG4gICAgfVxuICAgIHBhY2tfYXJyYXkoYXJ5KSB7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGFyeS5sZW5ndGg7XG4gICAgICAgIGlmIChsZW5ndGggPD0gMHgwZikgdGhpcy5wYWNrX3VpbnQ4KDB4OTAgKyBsZW5ndGgpO1xuICAgICAgICBlbHNlIGlmIChsZW5ndGggPD0gMHhmZmZmKSB7XG4gICAgICAgICAgICB0aGlzLl9idWZmZXJCdWlsZGVyLmFwcGVuZCgweGRjKTtcbiAgICAgICAgICAgIHRoaXMucGFja191aW50MTYobGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIGlmIChsZW5ndGggPD0gMHhmZmZmZmZmZikge1xuICAgICAgICAgICAgdGhpcy5fYnVmZmVyQnVpbGRlci5hcHBlbmQoMHhkZCk7XG4gICAgICAgICAgICB0aGlzLnBhY2tfdWludDMyKGxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGxlbmd0aFwiKTtcbiAgICAgICAgY29uc3QgcGFja05leHQgPSAoaW5kZXgpPT57XG4gICAgICAgICAgICBpZiAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXMgPSB0aGlzLnBhY2soYXJ5W2luZGV4XSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlcyBpbnN0YW5jZW9mIFByb21pc2UpIHJldHVybiByZXMudGhlbigoKT0+cGFja05leHQoaW5kZXggKyAxKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhY2tOZXh0KGluZGV4ICsgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBwYWNrTmV4dCgwKTtcbiAgICB9XG4gICAgcGFja19pbnRlZ2VyKG51bSkge1xuICAgICAgICBpZiAobnVtID49IC0zMiAmJiBudW0gPD0gMHg3ZikgdGhpcy5fYnVmZmVyQnVpbGRlci5hcHBlbmQobnVtICYgMHhmZik7XG4gICAgICAgIGVsc2UgaWYgKG51bSA+PSAweDAwICYmIG51bSA8PSAweGZmKSB7XG4gICAgICAgICAgICB0aGlzLl9idWZmZXJCdWlsZGVyLmFwcGVuZCgweGNjKTtcbiAgICAgICAgICAgIHRoaXMucGFja191aW50OChudW0pO1xuICAgICAgICB9IGVsc2UgaWYgKG51bSA+PSAtMTI4ICYmIG51bSA8PSAweDdmKSB7XG4gICAgICAgICAgICB0aGlzLl9idWZmZXJCdWlsZGVyLmFwcGVuZCgweGQwKTtcbiAgICAgICAgICAgIHRoaXMucGFja19pbnQ4KG51bSk7XG4gICAgICAgIH0gZWxzZSBpZiAobnVtID49IDB4MDAwMCAmJiBudW0gPD0gMHhmZmZmKSB7XG4gICAgICAgICAgICB0aGlzLl9idWZmZXJCdWlsZGVyLmFwcGVuZCgweGNkKTtcbiAgICAgICAgICAgIHRoaXMucGFja191aW50MTYobnVtKTtcbiAgICAgICAgfSBlbHNlIGlmIChudW0gPj0gLTMyNzY4ICYmIG51bSA8PSAweDdmZmYpIHtcbiAgICAgICAgICAgIHRoaXMuX2J1ZmZlckJ1aWxkZXIuYXBwZW5kKDB4ZDEpO1xuICAgICAgICAgICAgdGhpcy5wYWNrX2ludDE2KG51bSk7XG4gICAgICAgIH0gZWxzZSBpZiAobnVtID49IDB4MDAwMDAwMDAgJiYgbnVtIDw9IDB4ZmZmZmZmZmYpIHtcbiAgICAgICAgICAgIHRoaXMuX2J1ZmZlckJ1aWxkZXIuYXBwZW5kKDB4Y2UpO1xuICAgICAgICAgICAgdGhpcy5wYWNrX3VpbnQzMihudW0pO1xuICAgICAgICB9IGVsc2UgaWYgKG51bSA+PSAtMjE0NzQ4MzY0OCAmJiBudW0gPD0gMHg3ZmZmZmZmZikge1xuICAgICAgICAgICAgdGhpcy5fYnVmZmVyQnVpbGRlci5hcHBlbmQoMHhkMik7XG4gICAgICAgICAgICB0aGlzLnBhY2tfaW50MzIobnVtKTtcbiAgICAgICAgfSBlbHNlIGlmIChudW0gPj0gLTkyMjMzNzIwMzY4NTQ3NzYwMDAgJiYgbnVtIDw9IDB4N2ZmZmZmZmZmZmZmZmZmZikge1xuICAgICAgICAgICAgdGhpcy5fYnVmZmVyQnVpbGRlci5hcHBlbmQoMHhkMyk7XG4gICAgICAgICAgICB0aGlzLnBhY2tfaW50NjQobnVtKTtcbiAgICAgICAgfSBlbHNlIGlmIChudW0gPj0gMHgwMDAwMDAwMDAwMDAwMDAwICYmIG51bSA8PSAweGZmZmZmZmZmZmZmZmZmZmYpIHtcbiAgICAgICAgICAgIHRoaXMuX2J1ZmZlckJ1aWxkZXIuYXBwZW5kKDB4Y2YpO1xuICAgICAgICAgICAgdGhpcy5wYWNrX3VpbnQ2NChudW0pO1xuICAgICAgICB9IGVsc2UgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnRlZ2VyXCIpO1xuICAgIH1cbiAgICBwYWNrX2RvdWJsZShudW0pIHtcbiAgICAgICAgbGV0IHNpZ24gPSAwO1xuICAgICAgICBpZiAobnVtIDwgMCkge1xuICAgICAgICAgICAgc2lnbiA9IDE7XG4gICAgICAgICAgICBudW0gPSAtbnVtO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGV4cCA9IE1hdGguZmxvb3IoTWF0aC5sb2cobnVtKSAvIE1hdGguTE4yKTtcbiAgICAgICAgY29uc3QgZnJhYzAgPSBudW0gLyAyICoqIGV4cCAtIDE7XG4gICAgICAgIGNvbnN0IGZyYWMxID0gTWF0aC5mbG9vcihmcmFjMCAqIDIgKiogNTIpO1xuICAgICAgICBjb25zdCBiMzIgPSAyICoqIDMyO1xuICAgICAgICBjb25zdCBoMzIgPSBzaWduIDw8IDMxIHwgZXhwICsgMTAyMyA8PCAyMCB8IGZyYWMxIC8gYjMyICYgMHgwZmZmZmY7XG4gICAgICAgIGNvbnN0IGwzMiA9IGZyYWMxICUgYjMyO1xuICAgICAgICB0aGlzLl9idWZmZXJCdWlsZGVyLmFwcGVuZCgweGNiKTtcbiAgICAgICAgdGhpcy5wYWNrX2ludDMyKGgzMik7XG4gICAgICAgIHRoaXMucGFja19pbnQzMihsMzIpO1xuICAgIH1cbiAgICBwYWNrX29iamVjdChvYmopIHtcbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgICAgICBpZiAobGVuZ3RoIDw9IDB4MGYpIHRoaXMucGFja191aW50OCgweDgwICsgbGVuZ3RoKTtcbiAgICAgICAgZWxzZSBpZiAobGVuZ3RoIDw9IDB4ZmZmZikge1xuICAgICAgICAgICAgdGhpcy5fYnVmZmVyQnVpbGRlci5hcHBlbmQoMHhkZSk7XG4gICAgICAgICAgICB0aGlzLnBhY2tfdWludDE2KGxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSBpZiAobGVuZ3RoIDw9IDB4ZmZmZmZmZmYpIHtcbiAgICAgICAgICAgIHRoaXMuX2J1ZmZlckJ1aWxkZXIuYXBwZW5kKDB4ZGYpO1xuICAgICAgICAgICAgdGhpcy5wYWNrX3VpbnQzMihsZW5ndGgpO1xuICAgICAgICB9IGVsc2UgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBsZW5ndGhcIik7XG4gICAgICAgIGNvbnN0IHBhY2tOZXh0ID0gKGluZGV4KT0+e1xuICAgICAgICAgICAgaWYgKGluZGV4IDwga2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9wID0ga2V5c1tpbmRleF07XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xuICAgICAgICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYWNrKHByb3ApO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXMgPSB0aGlzLnBhY2sob2JqW3Byb3BdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcyBpbnN0YW5jZW9mIFByb21pc2UpIHJldHVybiByZXMudGhlbigoKT0+cGFja05leHQoaW5kZXggKyAxKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBwYWNrTmV4dChpbmRleCArIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcGFja05leHQoMCk7XG4gICAgfVxuICAgIHBhY2tfdWludDgobnVtKSB7XG4gICAgICAgIHRoaXMuX2J1ZmZlckJ1aWxkZXIuYXBwZW5kKG51bSk7XG4gICAgfVxuICAgIHBhY2tfdWludDE2KG51bSkge1xuICAgICAgICB0aGlzLl9idWZmZXJCdWlsZGVyLmFwcGVuZChudW0gPj4gOCk7XG4gICAgICAgIHRoaXMuX2J1ZmZlckJ1aWxkZXIuYXBwZW5kKG51bSAmIDB4ZmYpO1xuICAgIH1cbiAgICBwYWNrX3VpbnQzMihudW0pIHtcbiAgICAgICAgY29uc3QgbiA9IG51bSAmIDB4ZmZmZmZmZmY7XG4gICAgICAgIHRoaXMuX2J1ZmZlckJ1aWxkZXIuYXBwZW5kKChuICYgMHhmZjAwMDAwMCkgPj4+IDI0KTtcbiAgICAgICAgdGhpcy5fYnVmZmVyQnVpbGRlci5hcHBlbmQoKG4gJiAweDAwZmYwMDAwKSA+Pj4gMTYpO1xuICAgICAgICB0aGlzLl9idWZmZXJCdWlsZGVyLmFwcGVuZCgobiAmIDB4MDAwMGZmMDApID4+PiA4KTtcbiAgICAgICAgdGhpcy5fYnVmZmVyQnVpbGRlci5hcHBlbmQobiAmIDB4MDAwMDAwZmYpO1xuICAgIH1cbiAgICBwYWNrX3VpbnQ2NChudW0pIHtcbiAgICAgICAgY29uc3QgaGlnaCA9IG51bSAvIDIgKiogMzI7XG4gICAgICAgIGNvbnN0IGxvdyA9IG51bSAlIDIgKiogMzI7XG4gICAgICAgIHRoaXMuX2J1ZmZlckJ1aWxkZXIuYXBwZW5kKChoaWdoICYgMHhmZjAwMDAwMCkgPj4+IDI0KTtcbiAgICAgICAgdGhpcy5fYnVmZmVyQnVpbGRlci5hcHBlbmQoKGhpZ2ggJiAweDAwZmYwMDAwKSA+Pj4gMTYpO1xuICAgICAgICB0aGlzLl9idWZmZXJCdWlsZGVyLmFwcGVuZCgoaGlnaCAmIDB4MDAwMGZmMDApID4+PiA4KTtcbiAgICAgICAgdGhpcy5fYnVmZmVyQnVpbGRlci5hcHBlbmQoaGlnaCAmIDB4MDAwMDAwZmYpO1xuICAgICAgICB0aGlzLl9idWZmZXJCdWlsZGVyLmFwcGVuZCgobG93ICYgMHhmZjAwMDAwMCkgPj4+IDI0KTtcbiAgICAgICAgdGhpcy5fYnVmZmVyQnVpbGRlci5hcHBlbmQoKGxvdyAmIDB4MDBmZjAwMDApID4+PiAxNik7XG4gICAgICAgIHRoaXMuX2J1ZmZlckJ1aWxkZXIuYXBwZW5kKChsb3cgJiAweDAwMDBmZjAwKSA+Pj4gOCk7XG4gICAgICAgIHRoaXMuX2J1ZmZlckJ1aWxkZXIuYXBwZW5kKGxvdyAmIDB4MDAwMDAwZmYpO1xuICAgIH1cbiAgICBwYWNrX2ludDgobnVtKSB7XG4gICAgICAgIHRoaXMuX2J1ZmZlckJ1aWxkZXIuYXBwZW5kKG51bSAmIDB4ZmYpO1xuICAgIH1cbiAgICBwYWNrX2ludDE2KG51bSkge1xuICAgICAgICB0aGlzLl9idWZmZXJCdWlsZGVyLmFwcGVuZCgobnVtICYgMHhmZjAwKSA+PiA4KTtcbiAgICAgICAgdGhpcy5fYnVmZmVyQnVpbGRlci5hcHBlbmQobnVtICYgMHhmZik7XG4gICAgfVxuICAgIHBhY2tfaW50MzIobnVtKSB7XG4gICAgICAgIHRoaXMuX2J1ZmZlckJ1aWxkZXIuYXBwZW5kKG51bSA+Pj4gMjQgJiAweGZmKTtcbiAgICAgICAgdGhpcy5fYnVmZmVyQnVpbGRlci5hcHBlbmQoKG51bSAmIDB4MDBmZjAwMDApID4+PiAxNik7XG4gICAgICAgIHRoaXMuX2J1ZmZlckJ1aWxkZXIuYXBwZW5kKChudW0gJiAweDAwMDBmZjAwKSA+Pj4gOCk7XG4gICAgICAgIHRoaXMuX2J1ZmZlckJ1aWxkZXIuYXBwZW5kKG51bSAmIDB4MDAwMDAwZmYpO1xuICAgIH1cbiAgICBwYWNrX2ludDY0KG51bSkge1xuICAgICAgICBjb25zdCBoaWdoID0gTWF0aC5mbG9vcihudW0gLyAyICoqIDMyKTtcbiAgICAgICAgY29uc3QgbG93ID0gbnVtICUgMiAqKiAzMjtcbiAgICAgICAgdGhpcy5fYnVmZmVyQnVpbGRlci5hcHBlbmQoKGhpZ2ggJiAweGZmMDAwMDAwKSA+Pj4gMjQpO1xuICAgICAgICB0aGlzLl9idWZmZXJCdWlsZGVyLmFwcGVuZCgoaGlnaCAmIDB4MDBmZjAwMDApID4+PiAxNik7XG4gICAgICAgIHRoaXMuX2J1ZmZlckJ1aWxkZXIuYXBwZW5kKChoaWdoICYgMHgwMDAwZmYwMCkgPj4+IDgpO1xuICAgICAgICB0aGlzLl9idWZmZXJCdWlsZGVyLmFwcGVuZChoaWdoICYgMHgwMDAwMDBmZik7XG4gICAgICAgIHRoaXMuX2J1ZmZlckJ1aWxkZXIuYXBwZW5kKChsb3cgJiAweGZmMDAwMDAwKSA+Pj4gMjQpO1xuICAgICAgICB0aGlzLl9idWZmZXJCdWlsZGVyLmFwcGVuZCgobG93ICYgMHgwMGZmMDAwMCkgPj4+IDE2KTtcbiAgICAgICAgdGhpcy5fYnVmZmVyQnVpbGRlci5hcHBlbmQoKGxvdyAmIDB4MDAwMGZmMDApID4+PiA4KTtcbiAgICAgICAgdGhpcy5fYnVmZmVyQnVpbGRlci5hcHBlbmQobG93ICYgMHgwMDAwMDBmZik7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHRoaXMuX2J1ZmZlckJ1aWxkZXIgPSBuZXcgKDAsICRlODM3OTgxODY1MGUyNDQyJGV4cG9ydCQ5MzY1NGQ0ZjJkNmNkNTI0KSgpO1xuICAgICAgICB0aGlzLl90ZXh0RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICAgIH1cbn1cblxuXG5leHBvcnQgeyQwY2ZkNzgyOGFkNTkxMTVmJGV4cG9ydCQ0MTc4NTcwMTBkYzkyODdmIGFzIHVucGFjaywgJDBjZmQ3ODI4YWQ1OTExNWYkZXhwb3J0JDJhNzAzZGJiMGNiMzUzMzkgYXMgcGFjaywgJDBjZmQ3ODI4YWQ1OTExNWYkZXhwb3J0JGI5ZWM0YjExNGFhNDAwNzQgYXMgUGFja2VyfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJpbmFyeXBhY2subWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/peerjs-js-binarypack/dist/binarypack.mjs\n");

/***/ })

};
;