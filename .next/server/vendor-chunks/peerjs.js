"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/peerjs";
exports.ids = ["vendor-chunks/peerjs"];
exports.modules = {

/***/ "(ssr)/./node_modules/peerjs/dist/bundler.mjs":
/*!**********************************************!*\
  !*** ./node_modules/peerjs/dist/bundler.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseConnectionErrorType: () => (/* binding */ $78455e22dea96b8c$export$7974935686149686),\n/* harmony export */   BufferedConnection: () => (/* binding */ $a229bedbcaa6ca23$export$ff7c9d4c11d94e8b),\n/* harmony export */   ConnectionType: () => (/* binding */ $78455e22dea96b8c$export$3157d57b4135e3bc),\n/* harmony export */   DataConnectionErrorType: () => (/* binding */ $78455e22dea96b8c$export$49ae800c114df41d),\n/* harmony export */   MsgPack: () => (/* binding */ $6e39230ab36396ad$export$80f5de1a66c4d624),\n/* harmony export */   MsgPackPeer: () => (/* binding */ $1e0aff16be2c328e$export$d72c7bf8eef50853),\n/* harmony export */   Peer: () => (/* binding */ $416260bce337df90$export$ecd1fc136c422448),\n/* harmony export */   PeerError: () => (/* binding */ $23779d1881157a18$export$98871882f492de82),\n/* harmony export */   PeerErrorType: () => (/* binding */ $78455e22dea96b8c$export$9547aaa2e39030ff),\n/* harmony export */   SerializationType: () => (/* binding */ $78455e22dea96b8c$export$89f507cf986a947),\n/* harmony export */   ServerMessageType: () => (/* binding */ $78455e22dea96b8c$export$adb4a1754da6f10d),\n/* harmony export */   SocketEventType: () => (/* binding */ $78455e22dea96b8c$export$3b5c4a4b6354f023),\n/* harmony export */   StreamConnection: () => (/* binding */ $20dbe68149d7aad9$export$72aa44612e2200cd),\n/* harmony export */   \"default\": () => (/* binding */ $dd0187d7f28e386f$export$2e2bcd8739ae039),\n/* harmony export */   util: () => (/* binding */ $4f4134156c446392$export$7debb50ef11d5e0b)\n/* harmony export */ });\n/* harmony import */ var peerjs_js_binarypack__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! peerjs-js-binarypack */ \"(ssr)/./node_modules/peerjs-js-binarypack/dist/binarypack.mjs\");\n/* harmony import */ var webrtc_adapter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! webrtc-adapter */ \"(ssr)/./node_modules/webrtc-adapter/src/js/adapter_core.js\");\n/* harmony import */ var _msgpack_msgpack__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @msgpack/msgpack */ \"(ssr)/./node_modules/@msgpack/msgpack/dist.es5+esm/Encoder.mjs\");\n/* harmony import */ var _msgpack_msgpack__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @msgpack/msgpack */ \"(ssr)/./node_modules/@msgpack/msgpack/dist.es5+esm/decodeAsync.mjs\");\n\n\n\n\n\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\nclass $fcbcc7538a6776d5$export$f1c5f4c9cb95390b {\n    constructor(){\n        this.chunkedMTU = 16300 // The original 60000 bytes setting does not work when sending data from Firefox to Chrome, which is \"cut off\" after 16384 bytes and delivered individually.\n        ;\n        // Binary stuff\n        this._dataCount = 1;\n        this.chunk = (blob)=>{\n            const chunks = [];\n            const size = blob.byteLength;\n            const total = Math.ceil(size / this.chunkedMTU);\n            let index = 0;\n            let start = 0;\n            while(start < size){\n                const end = Math.min(size, start + this.chunkedMTU);\n                const b = blob.slice(start, end);\n                const chunk = {\n                    __peerData: this._dataCount,\n                    n: index,\n                    data: b,\n                    total: total\n                };\n                chunks.push(chunk);\n                start = end;\n                index++;\n            }\n            this._dataCount++;\n            return chunks;\n        };\n    }\n}\nfunction $fcbcc7538a6776d5$export$52c89ebcdc4f53f2(bufs) {\n    let size = 0;\n    for (const buf of bufs)size += buf.byteLength;\n    const result = new Uint8Array(size);\n    let offset = 0;\n    for (const buf of bufs){\n        result.set(buf, offset);\n        offset += buf.byteLength;\n    }\n    return result;\n}\n\n\n\n\nconst $fb63e766cfafaab9$var$webRTCAdapter = //@ts-ignore\n(0, webrtc_adapter__WEBPACK_IMPORTED_MODULE_1__[\"default\"]).default || (0, webrtc_adapter__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\nconst $fb63e766cfafaab9$export$25be9502477c137d = new class {\n    isWebRTCSupported() {\n        return typeof RTCPeerConnection !== \"undefined\";\n    }\n    isBrowserSupported() {\n        const browser = this.getBrowser();\n        const version = this.getVersion();\n        const validBrowser = this.supportedBrowsers.includes(browser);\n        if (!validBrowser) return false;\n        if (browser === \"chrome\") return version >= this.minChromeVersion;\n        if (browser === \"firefox\") return version >= this.minFirefoxVersion;\n        if (browser === \"safari\") return !this.isIOS && version >= this.minSafariVersion;\n        return false;\n    }\n    getBrowser() {\n        return $fb63e766cfafaab9$var$webRTCAdapter.browserDetails.browser;\n    }\n    getVersion() {\n        return $fb63e766cfafaab9$var$webRTCAdapter.browserDetails.version || 0;\n    }\n    isUnifiedPlanSupported() {\n        const browser = this.getBrowser();\n        const version = $fb63e766cfafaab9$var$webRTCAdapter.browserDetails.version || 0;\n        if (browser === \"chrome\" && version < this.minChromeVersion) return false;\n        if (browser === \"firefox\" && version >= this.minFirefoxVersion) return true;\n        if (!window.RTCRtpTransceiver || !(\"currentDirection\" in RTCRtpTransceiver.prototype)) return false;\n        let tempPc;\n        let supported = false;\n        try {\n            tempPc = new RTCPeerConnection();\n            tempPc.addTransceiver(\"audio\");\n            supported = true;\n        } catch (e) {} finally{\n            if (tempPc) tempPc.close();\n        }\n        return supported;\n    }\n    toString() {\n        return `Supports:\n    browser:${this.getBrowser()}\n    version:${this.getVersion()}\n    isIOS:${this.isIOS}\n    isWebRTCSupported:${this.isWebRTCSupported()}\n    isBrowserSupported:${this.isBrowserSupported()}\n    isUnifiedPlanSupported:${this.isUnifiedPlanSupported()}`;\n    }\n    constructor(){\n        this.isIOS = typeof navigator !== \"undefined\" ? [\n            \"iPad\",\n            \"iPhone\",\n            \"iPod\"\n        ].includes(navigator.platform) : false;\n        this.supportedBrowsers = [\n            \"firefox\",\n            \"chrome\",\n            \"safari\"\n        ];\n        this.minFirefoxVersion = 59;\n        this.minChromeVersion = 72;\n        this.minSafariVersion = 605;\n    }\n}();\n\n\nconst $9a84a32bf0bf36bb$export$f35f128fd59ea256 = (id)=>{\n    // Allow empty ids\n    return !id || /^[A-Za-z0-9]+(?:[ _-][A-Za-z0-9]+)*$/.test(id);\n};\n\n\nconst $0e5fd1585784c252$export$4e61f672936bec77 = ()=>Math.random().toString(36).slice(2);\n\n\nconst $4f4134156c446392$var$DEFAULT_CONFIG = {\n    iceServers: [\n        {\n            urls: \"stun:stun.l.google.com:19302\"\n        },\n        {\n            urls: [\n                \"turn:eu-0.turn.peerjs.com:3478\",\n                \"turn:us-0.turn.peerjs.com:3478\"\n            ],\n            username: \"peerjs\",\n            credential: \"peerjsp\"\n        }\n    ],\n    sdpSemantics: \"unified-plan\"\n};\nclass $4f4134156c446392$export$f8f26dd395d7e1bd extends (0, $fcbcc7538a6776d5$export$f1c5f4c9cb95390b) {\n    noop() {}\n    blobToArrayBuffer(blob, cb) {\n        const fr = new FileReader();\n        fr.onload = function(evt) {\n            if (evt.target) cb(evt.target.result);\n        };\n        fr.readAsArrayBuffer(blob);\n        return fr;\n    }\n    binaryStringToArrayBuffer(binary) {\n        const byteArray = new Uint8Array(binary.length);\n        for(let i = 0; i < binary.length; i++)byteArray[i] = binary.charCodeAt(i) & 0xff;\n        return byteArray.buffer;\n    }\n    isSecure() {\n        return location.protocol === \"https:\";\n    }\n    constructor(...args){\n        super(...args);\n        this.CLOUD_HOST = \"0.peerjs.com\";\n        this.CLOUD_PORT = 443;\n        // Browsers that need chunking:\n        this.chunkedBrowsers = {\n            Chrome: 1,\n            chrome: 1\n        };\n        // Returns browser-agnostic default config\n        this.defaultConfig = $4f4134156c446392$var$DEFAULT_CONFIG;\n        this.browser = (0, $fb63e766cfafaab9$export$25be9502477c137d).getBrowser();\n        this.browserVersion = (0, $fb63e766cfafaab9$export$25be9502477c137d).getVersion();\n        this.pack = peerjs_js_binarypack__WEBPACK_IMPORTED_MODULE_0__.pack;\n        this.unpack = peerjs_js_binarypack__WEBPACK_IMPORTED_MODULE_0__.unpack;\n        /**\n\t * A hash of WebRTC features mapped to booleans that correspond to whether the feature is supported by the current browser.\n\t *\n\t * :::caution\n\t * Only the properties documented here are guaranteed to be present on `util.supports`\n\t * :::\n\t */ this.supports = function() {\n            const supported = {\n                browser: (0, $fb63e766cfafaab9$export$25be9502477c137d).isBrowserSupported(),\n                webRTC: (0, $fb63e766cfafaab9$export$25be9502477c137d).isWebRTCSupported(),\n                audioVideo: false,\n                data: false,\n                binaryBlob: false,\n                reliable: false\n            };\n            if (!supported.webRTC) return supported;\n            let pc;\n            try {\n                pc = new RTCPeerConnection($4f4134156c446392$var$DEFAULT_CONFIG);\n                supported.audioVideo = true;\n                let dc;\n                try {\n                    dc = pc.createDataChannel(\"_PEERJSTEST\", {\n                        ordered: true\n                    });\n                    supported.data = true;\n                    supported.reliable = !!dc.ordered;\n                    // Binary test\n                    try {\n                        dc.binaryType = \"blob\";\n                        supported.binaryBlob = !(0, $fb63e766cfafaab9$export$25be9502477c137d).isIOS;\n                    } catch (e) {}\n                } catch (e) {} finally{\n                    if (dc) dc.close();\n                }\n            } catch (e) {} finally{\n                if (pc) pc.close();\n            }\n            return supported;\n        }();\n        // Ensure alphanumeric ids\n        this.validateId = (0, $9a84a32bf0bf36bb$export$f35f128fd59ea256);\n        this.randomToken = (0, $0e5fd1585784c252$export$4e61f672936bec77);\n    }\n}\nconst $4f4134156c446392$export$7debb50ef11d5e0b = new $4f4134156c446392$export$f8f26dd395d7e1bd();\n\n\n\nconst $257947e92926277a$var$LOG_PREFIX = \"PeerJS: \";\nvar $257947e92926277a$export$243e62d78d3b544d;\n(function(LogLevel) {\n    /**\n\t * Prints no logs.\n\t */ LogLevel[LogLevel[\"Disabled\"] = 0] = \"Disabled\";\n    /**\n\t * Prints only errors.\n\t */ LogLevel[LogLevel[\"Errors\"] = 1] = \"Errors\";\n    /**\n\t * Prints errors and warnings.\n\t */ LogLevel[LogLevel[\"Warnings\"] = 2] = \"Warnings\";\n    /**\n\t * Prints all logs.\n\t */ LogLevel[LogLevel[\"All\"] = 3] = \"All\";\n})($257947e92926277a$export$243e62d78d3b544d || ($257947e92926277a$export$243e62d78d3b544d = {}));\nclass $257947e92926277a$var$Logger {\n    get logLevel() {\n        return this._logLevel;\n    }\n    set logLevel(logLevel) {\n        this._logLevel = logLevel;\n    }\n    log(...args) {\n        if (this._logLevel >= 3) this._print(3, ...args);\n    }\n    warn(...args) {\n        if (this._logLevel >= 2) this._print(2, ...args);\n    }\n    error(...args) {\n        if (this._logLevel >= 1) this._print(1, ...args);\n    }\n    setLogFunction(fn) {\n        this._print = fn;\n    }\n    _print(logLevel, ...rest) {\n        const copy = [\n            $257947e92926277a$var$LOG_PREFIX,\n            ...rest\n        ];\n        for(const i in copy)if (copy[i] instanceof Error) copy[i] = \"(\" + copy[i].name + \") \" + copy[i].message;\n        if (logLevel >= 3) console.log(...copy);\n        else if (logLevel >= 2) console.warn(\"WARNING\", ...copy);\n        else if (logLevel >= 1) console.error(\"ERROR\", ...copy);\n    }\n    constructor(){\n        this._logLevel = 0;\n    }\n}\nvar $257947e92926277a$export$2e2bcd8739ae039 = new $257947e92926277a$var$Logger();\n\n\nvar $c4dcfd1d1ea86647$exports = {};\n\"use strict\";\nvar $c4dcfd1d1ea86647$var$has = Object.prototype.hasOwnProperty, $c4dcfd1d1ea86647$var$prefix = \"~\";\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */ function $c4dcfd1d1ea86647$var$Events() {}\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n    $c4dcfd1d1ea86647$var$Events.prototype = Object.create(null);\n    //\n    // This hack is needed because the `__proto__` property is still inherited in\n    // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n    //\n    if (!new $c4dcfd1d1ea86647$var$Events().__proto__) $c4dcfd1d1ea86647$var$prefix = false;\n}\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */ function $c4dcfd1d1ea86647$var$EE(fn, context, once) {\n    this.fn = fn;\n    this.context = context;\n    this.once = once || false;\n}\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */ function $c4dcfd1d1ea86647$var$addListener(emitter, event, fn, context, once) {\n    if (typeof fn !== \"function\") throw new TypeError(\"The listener must be a function\");\n    var listener = new $c4dcfd1d1ea86647$var$EE(fn, context || emitter, once), evt = $c4dcfd1d1ea86647$var$prefix ? $c4dcfd1d1ea86647$var$prefix + event : event;\n    if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n    else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n    else emitter._events[evt] = [\n        emitter._events[evt],\n        listener\n    ];\n    return emitter;\n}\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */ function $c4dcfd1d1ea86647$var$clearEvent(emitter, evt) {\n    if (--emitter._eventsCount === 0) emitter._events = new $c4dcfd1d1ea86647$var$Events();\n    else delete emitter._events[evt];\n}\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */ function $c4dcfd1d1ea86647$var$EventEmitter() {\n    this._events = new $c4dcfd1d1ea86647$var$Events();\n    this._eventsCount = 0;\n}\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */ $c4dcfd1d1ea86647$var$EventEmitter.prototype.eventNames = function eventNames() {\n    var names = [], events, name;\n    if (this._eventsCount === 0) return names;\n    for(name in events = this._events)if ($c4dcfd1d1ea86647$var$has.call(events, name)) names.push($c4dcfd1d1ea86647$var$prefix ? name.slice(1) : name);\n    if (Object.getOwnPropertySymbols) return names.concat(Object.getOwnPropertySymbols(events));\n    return names;\n};\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */ $c4dcfd1d1ea86647$var$EventEmitter.prototype.listeners = function listeners(event) {\n    var evt = $c4dcfd1d1ea86647$var$prefix ? $c4dcfd1d1ea86647$var$prefix + event : event, handlers = this._events[evt];\n    if (!handlers) return [];\n    if (handlers.fn) return [\n        handlers.fn\n    ];\n    for(var i = 0, l = handlers.length, ee = new Array(l); i < l; i++)ee[i] = handlers[i].fn;\n    return ee;\n};\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */ $c4dcfd1d1ea86647$var$EventEmitter.prototype.listenerCount = function listenerCount(event) {\n    var evt = $c4dcfd1d1ea86647$var$prefix ? $c4dcfd1d1ea86647$var$prefix + event : event, listeners = this._events[evt];\n    if (!listeners) return 0;\n    if (listeners.fn) return 1;\n    return listeners.length;\n};\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */ $c4dcfd1d1ea86647$var$EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n    var evt = $c4dcfd1d1ea86647$var$prefix ? $c4dcfd1d1ea86647$var$prefix + event : event;\n    if (!this._events[evt]) return false;\n    var listeners = this._events[evt], len = arguments.length, args, i;\n    if (listeners.fn) {\n        if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n        switch(len){\n            case 1:\n                return listeners.fn.call(listeners.context), true;\n            case 2:\n                return listeners.fn.call(listeners.context, a1), true;\n            case 3:\n                return listeners.fn.call(listeners.context, a1, a2), true;\n            case 4:\n                return listeners.fn.call(listeners.context, a1, a2, a3), true;\n            case 5:\n                return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n            case 6:\n                return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n        }\n        for(i = 1, args = new Array(len - 1); i < len; i++)args[i - 1] = arguments[i];\n        listeners.fn.apply(listeners.context, args);\n    } else {\n        var length = listeners.length, j;\n        for(i = 0; i < length; i++){\n            if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n            switch(len){\n                case 1:\n                    listeners[i].fn.call(listeners[i].context);\n                    break;\n                case 2:\n                    listeners[i].fn.call(listeners[i].context, a1);\n                    break;\n                case 3:\n                    listeners[i].fn.call(listeners[i].context, a1, a2);\n                    break;\n                case 4:\n                    listeners[i].fn.call(listeners[i].context, a1, a2, a3);\n                    break;\n                default:\n                    if (!args) for(j = 1, args = new Array(len - 1); j < len; j++)args[j - 1] = arguments[j];\n                    listeners[i].fn.apply(listeners[i].context, args);\n            }\n        }\n    }\n    return true;\n};\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */ $c4dcfd1d1ea86647$var$EventEmitter.prototype.on = function on(event, fn, context) {\n    return $c4dcfd1d1ea86647$var$addListener(this, event, fn, context, false);\n};\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */ $c4dcfd1d1ea86647$var$EventEmitter.prototype.once = function once(event, fn, context) {\n    return $c4dcfd1d1ea86647$var$addListener(this, event, fn, context, true);\n};\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */ $c4dcfd1d1ea86647$var$EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n    var evt = $c4dcfd1d1ea86647$var$prefix ? $c4dcfd1d1ea86647$var$prefix + event : event;\n    if (!this._events[evt]) return this;\n    if (!fn) {\n        $c4dcfd1d1ea86647$var$clearEvent(this, evt);\n        return this;\n    }\n    var listeners = this._events[evt];\n    if (listeners.fn) {\n        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) $c4dcfd1d1ea86647$var$clearEvent(this, evt);\n    } else {\n        for(var i = 0, events = [], length = listeners.length; i < length; i++)if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) events.push(listeners[i]);\n        //\n        // Reset the array, or remove it completely if we have no more listeners.\n        //\n        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n        else $c4dcfd1d1ea86647$var$clearEvent(this, evt);\n    }\n    return this;\n};\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */ $c4dcfd1d1ea86647$var$EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n    var evt;\n    if (event) {\n        evt = $c4dcfd1d1ea86647$var$prefix ? $c4dcfd1d1ea86647$var$prefix + event : event;\n        if (this._events[evt]) $c4dcfd1d1ea86647$var$clearEvent(this, evt);\n    } else {\n        this._events = new $c4dcfd1d1ea86647$var$Events();\n        this._eventsCount = 0;\n    }\n    return this;\n};\n//\n// Alias methods names because people roll like that.\n//\n$c4dcfd1d1ea86647$var$EventEmitter.prototype.off = $c4dcfd1d1ea86647$var$EventEmitter.prototype.removeListener;\n$c4dcfd1d1ea86647$var$EventEmitter.prototype.addListener = $c4dcfd1d1ea86647$var$EventEmitter.prototype.on;\n//\n// Expose the prefix.\n//\n$c4dcfd1d1ea86647$var$EventEmitter.prefixed = $c4dcfd1d1ea86647$var$prefix;\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\n$c4dcfd1d1ea86647$var$EventEmitter.EventEmitter = $c4dcfd1d1ea86647$var$EventEmitter;\n$c4dcfd1d1ea86647$exports = $c4dcfd1d1ea86647$var$EventEmitter;\n\n\n\nvar $78455e22dea96b8c$exports = {};\n\n$parcel$export($78455e22dea96b8c$exports, \"ConnectionType\", () => $78455e22dea96b8c$export$3157d57b4135e3bc);\n$parcel$export($78455e22dea96b8c$exports, \"PeerErrorType\", () => $78455e22dea96b8c$export$9547aaa2e39030ff);\n$parcel$export($78455e22dea96b8c$exports, \"BaseConnectionErrorType\", () => $78455e22dea96b8c$export$7974935686149686);\n$parcel$export($78455e22dea96b8c$exports, \"DataConnectionErrorType\", () => $78455e22dea96b8c$export$49ae800c114df41d);\n$parcel$export($78455e22dea96b8c$exports, \"SerializationType\", () => $78455e22dea96b8c$export$89f507cf986a947);\n$parcel$export($78455e22dea96b8c$exports, \"SocketEventType\", () => $78455e22dea96b8c$export$3b5c4a4b6354f023);\n$parcel$export($78455e22dea96b8c$exports, \"ServerMessageType\", () => $78455e22dea96b8c$export$adb4a1754da6f10d);\nvar $78455e22dea96b8c$export$3157d57b4135e3bc;\n(function(ConnectionType) {\n    ConnectionType[\"Data\"] = \"data\";\n    ConnectionType[\"Media\"] = \"media\";\n})($78455e22dea96b8c$export$3157d57b4135e3bc || ($78455e22dea96b8c$export$3157d57b4135e3bc = {}));\nvar $78455e22dea96b8c$export$9547aaa2e39030ff;\n(function(PeerErrorType) {\n    /**\n\t * The client's browser does not support some or all WebRTC features that you are trying to use.\n\t */ PeerErrorType[\"BrowserIncompatible\"] = \"browser-incompatible\";\n    /**\n\t * You've already disconnected this peer from the server and can no longer make any new connections on it.\n\t */ PeerErrorType[\"Disconnected\"] = \"disconnected\";\n    /**\n\t * The ID passed into the Peer constructor contains illegal characters.\n\t */ PeerErrorType[\"InvalidID\"] = \"invalid-id\";\n    /**\n\t * The API key passed into the Peer constructor contains illegal characters or is not in the system (cloud server only).\n\t */ PeerErrorType[\"InvalidKey\"] = \"invalid-key\";\n    /**\n\t * Lost or cannot establish a connection to the signalling server.\n\t */ PeerErrorType[\"Network\"] = \"network\";\n    /**\n\t * The peer you're trying to connect to does not exist.\n\t */ PeerErrorType[\"PeerUnavailable\"] = \"peer-unavailable\";\n    /**\n\t * PeerJS is being used securely, but the cloud server does not support SSL. Use a custom PeerServer.\n\t */ PeerErrorType[\"SslUnavailable\"] = \"ssl-unavailable\";\n    /**\n\t * Unable to reach the server.\n\t */ PeerErrorType[\"ServerError\"] = \"server-error\";\n    /**\n\t * An error from the underlying socket.\n\t */ PeerErrorType[\"SocketError\"] = \"socket-error\";\n    /**\n\t * The underlying socket closed unexpectedly.\n\t */ PeerErrorType[\"SocketClosed\"] = \"socket-closed\";\n    /**\n\t * The ID passed into the Peer constructor is already taken.\n\t *\n\t * :::caution\n\t * This error is not fatal if your peer has open peer-to-peer connections.\n\t * This can happen if you attempt to {@apilink Peer.reconnect} a peer that has been disconnected from the server,\n\t * but its old ID has now been taken.\n\t * :::\n\t */ PeerErrorType[\"UnavailableID\"] = \"unavailable-id\";\n    /**\n\t * Native WebRTC errors.\n\t */ PeerErrorType[\"WebRTC\"] = \"webrtc\";\n})($78455e22dea96b8c$export$9547aaa2e39030ff || ($78455e22dea96b8c$export$9547aaa2e39030ff = {}));\nvar $78455e22dea96b8c$export$7974935686149686;\n(function(BaseConnectionErrorType) {\n    BaseConnectionErrorType[\"NegotiationFailed\"] = \"negotiation-failed\";\n    BaseConnectionErrorType[\"ConnectionClosed\"] = \"connection-closed\";\n})($78455e22dea96b8c$export$7974935686149686 || ($78455e22dea96b8c$export$7974935686149686 = {}));\nvar $78455e22dea96b8c$export$49ae800c114df41d;\n(function(DataConnectionErrorType) {\n    DataConnectionErrorType[\"NotOpenYet\"] = \"not-open-yet\";\n    DataConnectionErrorType[\"MessageToBig\"] = \"message-too-big\";\n})($78455e22dea96b8c$export$49ae800c114df41d || ($78455e22dea96b8c$export$49ae800c114df41d = {}));\nvar $78455e22dea96b8c$export$89f507cf986a947;\n(function(SerializationType) {\n    SerializationType[\"Binary\"] = \"binary\";\n    SerializationType[\"BinaryUTF8\"] = \"binary-utf8\";\n    SerializationType[\"JSON\"] = \"json\";\n    SerializationType[\"None\"] = \"raw\";\n})($78455e22dea96b8c$export$89f507cf986a947 || ($78455e22dea96b8c$export$89f507cf986a947 = {}));\nvar $78455e22dea96b8c$export$3b5c4a4b6354f023;\n(function(SocketEventType) {\n    SocketEventType[\"Message\"] = \"message\";\n    SocketEventType[\"Disconnected\"] = \"disconnected\";\n    SocketEventType[\"Error\"] = \"error\";\n    SocketEventType[\"Close\"] = \"close\";\n})($78455e22dea96b8c$export$3b5c4a4b6354f023 || ($78455e22dea96b8c$export$3b5c4a4b6354f023 = {}));\nvar $78455e22dea96b8c$export$adb4a1754da6f10d;\n(function(ServerMessageType) {\n    ServerMessageType[\"Heartbeat\"] = \"HEARTBEAT\";\n    ServerMessageType[\"Candidate\"] = \"CANDIDATE\";\n    ServerMessageType[\"Offer\"] = \"OFFER\";\n    ServerMessageType[\"Answer\"] = \"ANSWER\";\n    ServerMessageType[\"Open\"] = \"OPEN\";\n    ServerMessageType[\"Error\"] = \"ERROR\";\n    ServerMessageType[\"IdTaken\"] = \"ID-TAKEN\";\n    ServerMessageType[\"InvalidKey\"] = \"INVALID-KEY\";\n    ServerMessageType[\"Leave\"] = \"LEAVE\";\n    ServerMessageType[\"Expire\"] = \"EXPIRE\";\n})($78455e22dea96b8c$export$adb4a1754da6f10d || ($78455e22dea96b8c$export$adb4a1754da6f10d = {}));\n\n\nvar $f5f881ec4575f1fc$exports = {};\n$f5f881ec4575f1fc$exports = JSON.parse('{\"name\":\"peerjs\",\"version\":\"1.5.4\",\"keywords\":[\"peerjs\",\"webrtc\",\"p2p\",\"rtc\"],\"description\":\"PeerJS client\",\"homepage\":\"https://peerjs.com\",\"bugs\":{\"url\":\"https://github.com/peers/peerjs/issues\"},\"repository\":{\"type\":\"git\",\"url\":\"https://github.com/peers/peerjs\"},\"license\":\"MIT\",\"contributors\":[\"Michelle Bu <michelle@michellebu.com>\",\"afrokick <devbyru@gmail.com>\",\"ericz <really.ez@gmail.com>\",\"Jairo <kidandcat@gmail.com>\",\"Jonas Gloning <34194370+jonasgloning@users.noreply.github.com>\",\"Jairo Caro-Accino Viciana <jairo@galax.be>\",\"Carlos Caballero <carlos.caballero.gonzalez@gmail.com>\",\"hc <hheennrryy@gmail.com>\",\"Muhammad Asif <capripio@gmail.com>\",\"PrashoonB <prashoonbhattacharjee@gmail.com>\",\"Harsh Bardhan Mishra <47351025+HarshCasper@users.noreply.github.com>\",\"akotynski <aleksanderkotbury@gmail.com>\",\"lmb <i@lmb.io>\",\"Jairooo <jairocaro@msn.com>\",\"Moritz St\\xfcckler <moritz.stueckler@gmail.com>\",\"Simon <crydotsnakegithub@gmail.com>\",\"Denis Lukov <denismassters@gmail.com>\",\"Philipp Hancke <fippo@andyet.net>\",\"Hans Oksendahl <hansoksendahl@gmail.com>\",\"Jess <jessachandler@gmail.com>\",\"khankuan <khankuan@gmail.com>\",\"DUODVK <kurmanov.work@gmail.com>\",\"XiZhao <kwang1imsa@gmail.com>\",\"Matthias Lohr <matthias@lohr.me>\",\"=frank tree <=frnktrb@googlemail.com>\",\"Andre Eckardt <aeckardt@outlook.com>\",\"Chris Cowan <agentme49@gmail.com>\",\"Alex Chuev <alex@chuev.com>\",\"alxnull <alxnull@e.mail.de>\",\"Yemel Jardi <angel.jardi@gmail.com>\",\"Ben Parnell <benjaminparnell.94@gmail.com>\",\"Benny Lichtner <bennlich@gmail.com>\",\"fresheneesz <bitetrudpublic@gmail.com>\",\"bob.barstead@exaptive.com <bob.barstead@exaptive.com>\",\"chandika <chandika@gmail.com>\",\"emersion <contact@emersion.fr>\",\"Christopher Van <cvan@users.noreply.github.com>\",\"eddieherm <edhermoso@gmail.com>\",\"Eduardo Pinho <enet4mikeenet@gmail.com>\",\"Evandro Zanatta <ezanatta@tray.net.br>\",\"Gardner Bickford <gardner@users.noreply.github.com>\",\"Gian Luca <gianluca.cecchi@cynny.com>\",\"PatrickJS <github@gdi2290.com>\",\"jonnyf <github@jonathanfoss.co.uk>\",\"Hizkia Felix <hizkifw@gmail.com>\",\"Hristo Oskov <hristo.oskov@gmail.com>\",\"Isaac Madwed <i.madwed@gmail.com>\",\"Ilya Konanykhin <ilya.konanykhin@gmail.com>\",\"jasonbarry <jasbarry@me.com>\",\"Jonathan Burke <jonathan.burke.1311@googlemail.com>\",\"Josh Hamit <josh.hamit@gmail.com>\",\"Jordan Austin <jrax86@gmail.com>\",\"Joel Wetzell <jwetzell@yahoo.com>\",\"xizhao <kevin.wang@cloudera.com>\",\"Alberto Torres <kungfoobar@gmail.com>\",\"Jonathan Mayol <mayoljonathan@gmail.com>\",\"Jefferson Felix <me@jsfelix.dev>\",\"Rolf Erik Lekang <me@rolflekang.com>\",\"Kevin Mai-Husan Chia <mhchia@users.noreply.github.com>\",\"Pepijn de Vos <pepijndevos@gmail.com>\",\"JooYoung <qkdlql@naver.com>\",\"Tobias Speicher <rootcommander@gmail.com>\",\"Steve Blaurock <sblaurock@gmail.com>\",\"Kyrylo Shegeda <shegeda@ualberta.ca>\",\"Diwank Singh Tomer <singh@diwank.name>\",\"So\\u0308ren Balko <Soeren.Balko@gmail.com>\",\"Arpit Solanki <solankiarpit1997@gmail.com>\",\"Yuki Ito <yuki@gnnk.net>\",\"Artur Zayats <zag2art@gmail.com>\"],\"funding\":{\"type\":\"opencollective\",\"url\":\"https://opencollective.com/peer\"},\"collective\":{\"type\":\"opencollective\",\"url\":\"https://opencollective.com/peer\"},\"files\":[\"dist/*\"],\"sideEffects\":[\"lib/global.ts\",\"lib/supports.ts\"],\"main\":\"dist/bundler.cjs\",\"module\":\"dist/bundler.mjs\",\"browser-minified\":\"dist/peerjs.min.js\",\"browser-unminified\":\"dist/peerjs.js\",\"browser-minified-msgpack\":\"dist/serializer.msgpack.mjs\",\"types\":\"dist/types.d.ts\",\"engines\":{\"node\":\">= 14\"},\"targets\":{\"types\":{\"source\":\"lib/exports.ts\"},\"main\":{\"source\":\"lib/exports.ts\",\"sourceMap\":{\"inlineSources\":true}},\"module\":{\"source\":\"lib/exports.ts\",\"includeNodeModules\":[\"eventemitter3\"],\"sourceMap\":{\"inlineSources\":true}},\"browser-minified\":{\"context\":\"browser\",\"outputFormat\":\"global\",\"optimize\":true,\"engines\":{\"browsers\":\"chrome >= 83, edge >= 83, firefox >= 80, safari >= 15\"},\"source\":\"lib/global.ts\"},\"browser-unminified\":{\"context\":\"browser\",\"outputFormat\":\"global\",\"optimize\":false,\"engines\":{\"browsers\":\"chrome >= 83, edge >= 83, firefox >= 80, safari >= 15\"},\"source\":\"lib/global.ts\"},\"browser-minified-msgpack\":{\"context\":\"browser\",\"outputFormat\":\"esmodule\",\"isLibrary\":true,\"optimize\":true,\"engines\":{\"browsers\":\"chrome >= 83, edge >= 83, firefox >= 102, safari >= 15\"},\"source\":\"lib/dataconnection/StreamConnection/MsgPack.ts\"}},\"scripts\":{\"contributors\":\"git-authors-cli --print=false && prettier --write package.json && git add package.json package-lock.json && git commit -m \\\\\"chore(contributors): update and sort contributors list\\\\\"\",\"check\":\"tsc --noEmit && tsc -p e2e/tsconfig.json --noEmit\",\"watch\":\"parcel watch\",\"build\":\"rm -rf dist && parcel build\",\"prepublishOnly\":\"npm run build\",\"test\":\"jest\",\"test:watch\":\"jest --watch\",\"coverage\":\"jest --coverage --collectCoverageFrom=\\\\\"./lib/**\\\\\"\",\"format\":\"prettier --write .\",\"format:check\":\"prettier --check .\",\"semantic-release\":\"semantic-release\",\"e2e\":\"wdio run e2e/wdio.local.conf.ts\",\"e2e:bstack\":\"wdio run e2e/wdio.bstack.conf.ts\"},\"devDependencies\":{\"@parcel/config-default\":\"^2.9.3\",\"@parcel/packager-ts\":\"^2.9.3\",\"@parcel/transformer-typescript-tsc\":\"^2.9.3\",\"@parcel/transformer-typescript-types\":\"^2.9.3\",\"@semantic-release/changelog\":\"^6.0.1\",\"@semantic-release/git\":\"^10.0.1\",\"@swc/core\":\"^1.3.27\",\"@swc/jest\":\"^0.2.24\",\"@types/jasmine\":\"^4.3.4\",\"@wdio/browserstack-service\":\"^8.11.2\",\"@wdio/cli\":\"^8.11.2\",\"@wdio/globals\":\"^8.11.2\",\"@wdio/jasmine-framework\":\"^8.11.2\",\"@wdio/local-runner\":\"^8.11.2\",\"@wdio/spec-reporter\":\"^8.11.2\",\"@wdio/types\":\"^8.10.4\",\"http-server\":\"^14.1.1\",\"jest\":\"^29.3.1\",\"jest-environment-jsdom\":\"^29.3.1\",\"mock-socket\":\"^9.0.0\",\"parcel\":\"^2.9.3\",\"prettier\":\"^3.0.0\",\"semantic-release\":\"^21.0.0\",\"ts-node\":\"^10.9.1\",\"typescript\":\"^5.0.0\",\"wdio-geckodriver-service\":\"^5.0.1\"},\"dependencies\":{\"@msgpack/msgpack\":\"^2.8.0\",\"eventemitter3\":\"^4.0.7\",\"peerjs-js-binarypack\":\"^2.1.0\",\"webrtc-adapter\":\"^9.0.0\"},\"alias\":{\"process\":false,\"buffer\":false}}');\n\n\nclass $8f5bfa60836d261d$export$4798917dbf149b79 extends (0, $c4dcfd1d1ea86647$exports.EventEmitter) {\n    constructor(secure, host, port, path, key, pingInterval = 5000){\n        super();\n        this.pingInterval = pingInterval;\n        this._disconnected = true;\n        this._messagesQueue = [];\n        const wsProtocol = secure ? \"wss://\" : \"ws://\";\n        this._baseUrl = wsProtocol + host + \":\" + port + path + \"peerjs?key=\" + key;\n    }\n    start(id, token) {\n        this._id = id;\n        const wsUrl = `${this._baseUrl}&id=${id}&token=${token}`;\n        if (!!this._socket || !this._disconnected) return;\n        this._socket = new WebSocket(wsUrl + \"&version=\" + (0, $f5f881ec4575f1fc$exports.version));\n        this._disconnected = false;\n        this._socket.onmessage = (event)=>{\n            let data;\n            try {\n                data = JSON.parse(event.data);\n                (0, $257947e92926277a$export$2e2bcd8739ae039).log(\"Server message received:\", data);\n            } catch (e) {\n                (0, $257947e92926277a$export$2e2bcd8739ae039).log(\"Invalid server message\", event.data);\n                return;\n            }\n            this.emit((0, $78455e22dea96b8c$export$3b5c4a4b6354f023).Message, data);\n        };\n        this._socket.onclose = (event)=>{\n            if (this._disconnected) return;\n            (0, $257947e92926277a$export$2e2bcd8739ae039).log(\"Socket closed.\", event);\n            this._cleanup();\n            this._disconnected = true;\n            this.emit((0, $78455e22dea96b8c$export$3b5c4a4b6354f023).Disconnected);\n        };\n        // Take care of the queue of connections if necessary and make sure Peer knows\n        // socket is open.\n        this._socket.onopen = ()=>{\n            if (this._disconnected) return;\n            this._sendQueuedMessages();\n            (0, $257947e92926277a$export$2e2bcd8739ae039).log(\"Socket open\");\n            this._scheduleHeartbeat();\n        };\n    }\n    _scheduleHeartbeat() {\n        this._wsPingTimer = setTimeout(()=>{\n            this._sendHeartbeat();\n        }, this.pingInterval);\n    }\n    _sendHeartbeat() {\n        if (!this._wsOpen()) {\n            (0, $257947e92926277a$export$2e2bcd8739ae039).log(`Cannot send heartbeat, because socket closed`);\n            return;\n        }\n        const message = JSON.stringify({\n            type: (0, $78455e22dea96b8c$export$adb4a1754da6f10d).Heartbeat\n        });\n        this._socket.send(message);\n        this._scheduleHeartbeat();\n    }\n    /** Is the websocket currently open? */ _wsOpen() {\n        return !!this._socket && this._socket.readyState === 1;\n    }\n    /** Send queued messages. */ _sendQueuedMessages() {\n        //Create copy of queue and clear it,\n        //because send method push the message back to queue if smth will go wrong\n        const copiedQueue = [\n            ...this._messagesQueue\n        ];\n        this._messagesQueue = [];\n        for (const message of copiedQueue)this.send(message);\n    }\n    /** Exposed send for DC & Peer. */ send(data) {\n        if (this._disconnected) return;\n        // If we didn't get an ID yet, we can't yet send anything so we should queue\n        // up these messages.\n        if (!this._id) {\n            this._messagesQueue.push(data);\n            return;\n        }\n        if (!data.type) {\n            this.emit((0, $78455e22dea96b8c$export$3b5c4a4b6354f023).Error, \"Invalid message\");\n            return;\n        }\n        if (!this._wsOpen()) return;\n        const message = JSON.stringify(data);\n        this._socket.send(message);\n    }\n    close() {\n        if (this._disconnected) return;\n        this._cleanup();\n        this._disconnected = true;\n    }\n    _cleanup() {\n        if (this._socket) {\n            this._socket.onopen = this._socket.onmessage = this._socket.onclose = null;\n            this._socket.close();\n            this._socket = undefined;\n        }\n        clearTimeout(this._wsPingTimer);\n    }\n}\n\n\n\n\n\n\nclass $b82fb8fc0514bfc1$export$89e6bb5ad64bf4a {\n    constructor(connection){\n        this.connection = connection;\n    }\n    /** Returns a PeerConnection object set up correctly (for data, media). */ startConnection(options) {\n        const peerConnection = this._startPeerConnection();\n        // Set the connection's PC.\n        this.connection.peerConnection = peerConnection;\n        if (this.connection.type === (0, $78455e22dea96b8c$export$3157d57b4135e3bc).Media && options._stream) this._addTracksToConnection(options._stream, peerConnection);\n        // What do we need to do now?\n        if (options.originator) {\n            const dataConnection = this.connection;\n            const config = {\n                ordered: !!options.reliable\n            };\n            const dataChannel = peerConnection.createDataChannel(dataConnection.label, config);\n            dataConnection._initializeDataChannel(dataChannel);\n            this._makeOffer();\n        } else this.handleSDP(\"OFFER\", options.sdp);\n    }\n    /** Start a PC. */ _startPeerConnection() {\n        (0, $257947e92926277a$export$2e2bcd8739ae039).log(\"Creating RTCPeerConnection.\");\n        const peerConnection = new RTCPeerConnection(this.connection.provider.options.config);\n        this._setupListeners(peerConnection);\n        return peerConnection;\n    }\n    /** Set up various WebRTC listeners. */ _setupListeners(peerConnection) {\n        const peerId = this.connection.peer;\n        const connectionId = this.connection.connectionId;\n        const connectionType = this.connection.type;\n        const provider = this.connection.provider;\n        // ICE CANDIDATES.\n        (0, $257947e92926277a$export$2e2bcd8739ae039).log(\"Listening for ICE candidates.\");\n        peerConnection.onicecandidate = (evt)=>{\n            if (!evt.candidate || !evt.candidate.candidate) return;\n            (0, $257947e92926277a$export$2e2bcd8739ae039).log(`Received ICE candidates for ${peerId}:`, evt.candidate);\n            provider.socket.send({\n                type: (0, $78455e22dea96b8c$export$adb4a1754da6f10d).Candidate,\n                payload: {\n                    candidate: evt.candidate,\n                    type: connectionType,\n                    connectionId: connectionId\n                },\n                dst: peerId\n            });\n        };\n        peerConnection.oniceconnectionstatechange = ()=>{\n            switch(peerConnection.iceConnectionState){\n                case \"failed\":\n                    (0, $257947e92926277a$export$2e2bcd8739ae039).log(\"iceConnectionState is failed, closing connections to \" + peerId);\n                    this.connection.emitError((0, $78455e22dea96b8c$export$7974935686149686).NegotiationFailed, \"Negotiation of connection to \" + peerId + \" failed.\");\n                    this.connection.close();\n                    break;\n                case \"closed\":\n                    (0, $257947e92926277a$export$2e2bcd8739ae039).log(\"iceConnectionState is closed, closing connections to \" + peerId);\n                    this.connection.emitError((0, $78455e22dea96b8c$export$7974935686149686).ConnectionClosed, \"Connection to \" + peerId + \" closed.\");\n                    this.connection.close();\n                    break;\n                case \"disconnected\":\n                    (0, $257947e92926277a$export$2e2bcd8739ae039).log(\"iceConnectionState changed to disconnected on the connection with \" + peerId);\n                    break;\n                case \"completed\":\n                    peerConnection.onicecandidate = ()=>{};\n                    break;\n            }\n            this.connection.emit(\"iceStateChanged\", peerConnection.iceConnectionState);\n        };\n        // DATACONNECTION.\n        (0, $257947e92926277a$export$2e2bcd8739ae039).log(\"Listening for data channel\");\n        // Fired between offer and answer, so options should already be saved\n        // in the options hash.\n        peerConnection.ondatachannel = (evt)=>{\n            (0, $257947e92926277a$export$2e2bcd8739ae039).log(\"Received data channel\");\n            const dataChannel = evt.channel;\n            const connection = provider.getConnection(peerId, connectionId);\n            connection._initializeDataChannel(dataChannel);\n        };\n        // MEDIACONNECTION.\n        (0, $257947e92926277a$export$2e2bcd8739ae039).log(\"Listening for remote stream\");\n        peerConnection.ontrack = (evt)=>{\n            (0, $257947e92926277a$export$2e2bcd8739ae039).log(\"Received remote stream\");\n            const stream = evt.streams[0];\n            const connection = provider.getConnection(peerId, connectionId);\n            if (connection.type === (0, $78455e22dea96b8c$export$3157d57b4135e3bc).Media) {\n                const mediaConnection = connection;\n                this._addStreamToMediaConnection(stream, mediaConnection);\n            }\n        };\n    }\n    cleanup() {\n        (0, $257947e92926277a$export$2e2bcd8739ae039).log(\"Cleaning up PeerConnection to \" + this.connection.peer);\n        const peerConnection = this.connection.peerConnection;\n        if (!peerConnection) return;\n        this.connection.peerConnection = null;\n        //unsubscribe from all PeerConnection's events\n        peerConnection.onicecandidate = peerConnection.oniceconnectionstatechange = peerConnection.ondatachannel = peerConnection.ontrack = ()=>{};\n        const peerConnectionNotClosed = peerConnection.signalingState !== \"closed\";\n        let dataChannelNotClosed = false;\n        const dataChannel = this.connection.dataChannel;\n        if (dataChannel) dataChannelNotClosed = !!dataChannel.readyState && dataChannel.readyState !== \"closed\";\n        if (peerConnectionNotClosed || dataChannelNotClosed) peerConnection.close();\n    }\n    async _makeOffer() {\n        const peerConnection = this.connection.peerConnection;\n        const provider = this.connection.provider;\n        try {\n            const offer = await peerConnection.createOffer(this.connection.options.constraints);\n            (0, $257947e92926277a$export$2e2bcd8739ae039).log(\"Created offer.\");\n            if (this.connection.options.sdpTransform && typeof this.connection.options.sdpTransform === \"function\") offer.sdp = this.connection.options.sdpTransform(offer.sdp) || offer.sdp;\n            try {\n                await peerConnection.setLocalDescription(offer);\n                (0, $257947e92926277a$export$2e2bcd8739ae039).log(\"Set localDescription:\", offer, `for:${this.connection.peer}`);\n                let payload = {\n                    sdp: offer,\n                    type: this.connection.type,\n                    connectionId: this.connection.connectionId,\n                    metadata: this.connection.metadata\n                };\n                if (this.connection.type === (0, $78455e22dea96b8c$export$3157d57b4135e3bc).Data) {\n                    const dataConnection = this.connection;\n                    payload = {\n                        ...payload,\n                        label: dataConnection.label,\n                        reliable: dataConnection.reliable,\n                        serialization: dataConnection.serialization\n                    };\n                }\n                provider.socket.send({\n                    type: (0, $78455e22dea96b8c$export$adb4a1754da6f10d).Offer,\n                    payload: payload,\n                    dst: this.connection.peer\n                });\n            } catch (err) {\n                // TODO: investigate why _makeOffer is being called from the answer\n                if (err != \"OperationError: Failed to set local offer sdp: Called in wrong state: kHaveRemoteOffer\") {\n                    provider.emitError((0, $78455e22dea96b8c$export$9547aaa2e39030ff).WebRTC, err);\n                    (0, $257947e92926277a$export$2e2bcd8739ae039).log(\"Failed to setLocalDescription, \", err);\n                }\n            }\n        } catch (err_1) {\n            provider.emitError((0, $78455e22dea96b8c$export$9547aaa2e39030ff).WebRTC, err_1);\n            (0, $257947e92926277a$export$2e2bcd8739ae039).log(\"Failed to createOffer, \", err_1);\n        }\n    }\n    async _makeAnswer() {\n        const peerConnection = this.connection.peerConnection;\n        const provider = this.connection.provider;\n        try {\n            const answer = await peerConnection.createAnswer();\n            (0, $257947e92926277a$export$2e2bcd8739ae039).log(\"Created answer.\");\n            if (this.connection.options.sdpTransform && typeof this.connection.options.sdpTransform === \"function\") answer.sdp = this.connection.options.sdpTransform(answer.sdp) || answer.sdp;\n            try {\n                await peerConnection.setLocalDescription(answer);\n                (0, $257947e92926277a$export$2e2bcd8739ae039).log(`Set localDescription:`, answer, `for:${this.connection.peer}`);\n                provider.socket.send({\n                    type: (0, $78455e22dea96b8c$export$adb4a1754da6f10d).Answer,\n                    payload: {\n                        sdp: answer,\n                        type: this.connection.type,\n                        connectionId: this.connection.connectionId\n                    },\n                    dst: this.connection.peer\n                });\n            } catch (err) {\n                provider.emitError((0, $78455e22dea96b8c$export$9547aaa2e39030ff).WebRTC, err);\n                (0, $257947e92926277a$export$2e2bcd8739ae039).log(\"Failed to setLocalDescription, \", err);\n            }\n        } catch (err_1) {\n            provider.emitError((0, $78455e22dea96b8c$export$9547aaa2e39030ff).WebRTC, err_1);\n            (0, $257947e92926277a$export$2e2bcd8739ae039).log(\"Failed to create answer, \", err_1);\n        }\n    }\n    /** Handle an SDP. */ async handleSDP(type, sdp) {\n        sdp = new RTCSessionDescription(sdp);\n        const peerConnection = this.connection.peerConnection;\n        const provider = this.connection.provider;\n        (0, $257947e92926277a$export$2e2bcd8739ae039).log(\"Setting remote description\", sdp);\n        const self = this;\n        try {\n            await peerConnection.setRemoteDescription(sdp);\n            (0, $257947e92926277a$export$2e2bcd8739ae039).log(`Set remoteDescription:${type} for:${this.connection.peer}`);\n            if (type === \"OFFER\") await self._makeAnswer();\n        } catch (err) {\n            provider.emitError((0, $78455e22dea96b8c$export$9547aaa2e39030ff).WebRTC, err);\n            (0, $257947e92926277a$export$2e2bcd8739ae039).log(\"Failed to setRemoteDescription, \", err);\n        }\n    }\n    /** Handle a candidate. */ async handleCandidate(ice) {\n        (0, $257947e92926277a$export$2e2bcd8739ae039).log(`handleCandidate:`, ice);\n        try {\n            await this.connection.peerConnection.addIceCandidate(ice);\n            (0, $257947e92926277a$export$2e2bcd8739ae039).log(`Added ICE candidate for:${this.connection.peer}`);\n        } catch (err) {\n            this.connection.provider.emitError((0, $78455e22dea96b8c$export$9547aaa2e39030ff).WebRTC, err);\n            (0, $257947e92926277a$export$2e2bcd8739ae039).log(\"Failed to handleCandidate, \", err);\n        }\n    }\n    _addTracksToConnection(stream, peerConnection) {\n        (0, $257947e92926277a$export$2e2bcd8739ae039).log(`add tracks from stream ${stream.id} to peer connection`);\n        if (!peerConnection.addTrack) return (0, $257947e92926277a$export$2e2bcd8739ae039).error(`Your browser does't support RTCPeerConnection#addTrack. Ignored.`);\n        stream.getTracks().forEach((track)=>{\n            peerConnection.addTrack(track, stream);\n        });\n    }\n    _addStreamToMediaConnection(stream, mediaConnection) {\n        (0, $257947e92926277a$export$2e2bcd8739ae039).log(`add stream ${stream.id} to media connection ${mediaConnection.connectionId}`);\n        mediaConnection.addStream(stream);\n    }\n}\n\n\n\n\n\nclass $23779d1881157a18$export$6a678e589c8a4542 extends (0, $c4dcfd1d1ea86647$exports.EventEmitter) {\n    /**\n\t * Emits a typed error message.\n\t *\n\t * @internal\n\t */ emitError(type, err) {\n        (0, $257947e92926277a$export$2e2bcd8739ae039).error(\"Error:\", err);\n        // @ts-ignore\n        this.emit(\"error\", new $23779d1881157a18$export$98871882f492de82(`${type}`, err));\n    }\n}\nclass $23779d1881157a18$export$98871882f492de82 extends Error {\n    /**\n\t * @internal\n\t */ constructor(type, err){\n        if (typeof err === \"string\") super(err);\n        else {\n            super();\n            Object.assign(this, err);\n        }\n        this.type = type;\n    }\n}\n\n\nclass $5045192fc6d387ba$export$23a2a68283c24d80 extends (0, $23779d1881157a18$export$6a678e589c8a4542) {\n    /**\n\t * Whether the media connection is active (e.g. your call has been answered).\n\t * You can check this if you want to set a maximum wait time for a one-sided call.\n\t */ get open() {\n        return this._open;\n    }\n    constructor(/**\n\t\t * The ID of the peer on the other end of this connection.\n\t\t */ peer, provider, options){\n        super();\n        this.peer = peer;\n        this.provider = provider;\n        this.options = options;\n        this._open = false;\n        this.metadata = options.metadata;\n    }\n}\n\n\nclass $5c1d08c7c57da9a3$export$4a84e95a2324ac29 extends (0, $5045192fc6d387ba$export$23a2a68283c24d80) {\n    static #_ = this.ID_PREFIX = \"mc_\";\n    /**\n\t * For media connections, this is always 'media'.\n\t */ get type() {\n        return (0, $78455e22dea96b8c$export$3157d57b4135e3bc).Media;\n    }\n    get localStream() {\n        return this._localStream;\n    }\n    get remoteStream() {\n        return this._remoteStream;\n    }\n    constructor(peerId, provider, options){\n        super(peerId, provider, options);\n        this._localStream = this.options._stream;\n        this.connectionId = this.options.connectionId || $5c1d08c7c57da9a3$export$4a84e95a2324ac29.ID_PREFIX + (0, $4f4134156c446392$export$7debb50ef11d5e0b).randomToken();\n        this._negotiator = new (0, $b82fb8fc0514bfc1$export$89e6bb5ad64bf4a)(this);\n        if (this._localStream) this._negotiator.startConnection({\n            _stream: this._localStream,\n            originator: true\n        });\n    }\n    /** Called by the Negotiator when the DataChannel is ready. */ _initializeDataChannel(dc) {\n        this.dataChannel = dc;\n        this.dataChannel.onopen = ()=>{\n            (0, $257947e92926277a$export$2e2bcd8739ae039).log(`DC#${this.connectionId} dc connection success`);\n            this.emit(\"willCloseOnRemote\");\n        };\n        this.dataChannel.onclose = ()=>{\n            (0, $257947e92926277a$export$2e2bcd8739ae039).log(`DC#${this.connectionId} dc closed for:`, this.peer);\n            this.close();\n        };\n    }\n    addStream(remoteStream) {\n        (0, $257947e92926277a$export$2e2bcd8739ae039).log(\"Receiving stream\", remoteStream);\n        this._remoteStream = remoteStream;\n        super.emit(\"stream\", remoteStream); // Should we call this `open`?\n    }\n    /**\n\t * @internal\n\t */ handleMessage(message) {\n        const type = message.type;\n        const payload = message.payload;\n        switch(message.type){\n            case (0, $78455e22dea96b8c$export$adb4a1754da6f10d).Answer:\n                // Forward to negotiator\n                this._negotiator.handleSDP(type, payload.sdp);\n                this._open = true;\n                break;\n            case (0, $78455e22dea96b8c$export$adb4a1754da6f10d).Candidate:\n                this._negotiator.handleCandidate(payload.candidate);\n                break;\n            default:\n                (0, $257947e92926277a$export$2e2bcd8739ae039).warn(`Unrecognized message type:${type} from peer:${this.peer}`);\n                break;\n        }\n    }\n    /**\n     * When receiving a {@apilink PeerEvents | `call`} event on a peer, you can call\n     * `answer` on the media connection provided by the callback to accept the call\n     * and optionally send your own media stream.\n\n     *\n     * @param stream A WebRTC media stream.\n     * @param options\n     * @returns\n     */ answer(stream, options = {}) {\n        if (this._localStream) {\n            (0, $257947e92926277a$export$2e2bcd8739ae039).warn(\"Local stream already exists on this MediaConnection. Are you answering a call twice?\");\n            return;\n        }\n        this._localStream = stream;\n        if (options && options.sdpTransform) this.options.sdpTransform = options.sdpTransform;\n        this._negotiator.startConnection({\n            ...this.options._payload,\n            _stream: stream\n        });\n        // Retrieve lost messages stored because PeerConnection not set up.\n        const messages = this.provider._getMessages(this.connectionId);\n        for (const message of messages)this.handleMessage(message);\n        this._open = true;\n    }\n    /**\n\t * Exposed functionality for users.\n\t */ /**\n\t * Closes the media connection.\n\t */ close() {\n        if (this._negotiator) {\n            this._negotiator.cleanup();\n            this._negotiator = null;\n        }\n        this._localStream = null;\n        this._remoteStream = null;\n        if (this.provider) {\n            this.provider._removeConnection(this);\n            this.provider = null;\n        }\n        if (this.options && this.options._stream) this.options._stream = null;\n        if (!this.open) return;\n        this._open = false;\n        super.emit(\"close\");\n    }\n}\n\n\n\n\n\n\nclass $abf266641927cd89$export$2c4e825dc9120f87 {\n    constructor(_options){\n        this._options = _options;\n    }\n    _buildRequest(method) {\n        const protocol = this._options.secure ? \"https\" : \"http\";\n        const { host: host, port: port, path: path, key: key } = this._options;\n        const url = new URL(`${protocol}://${host}:${port}${path}${key}/${method}`);\n        // TODO: Why timestamp, why random?\n        url.searchParams.set(\"ts\", `${Date.now()}${Math.random()}`);\n        url.searchParams.set(\"version\", (0, $f5f881ec4575f1fc$exports.version));\n        return fetch(url.href, {\n            referrerPolicy: this._options.referrerPolicy\n        });\n    }\n    /** Get a unique ID from the server via XHR and initialize with it. */ async retrieveId() {\n        try {\n            const response = await this._buildRequest(\"id\");\n            if (response.status !== 200) throw new Error(`Error. Status:${response.status}`);\n            return response.text();\n        } catch (error) {\n            (0, $257947e92926277a$export$2e2bcd8739ae039).error(\"Error retrieving ID\", error);\n            let pathError = \"\";\n            if (this._options.path === \"/\" && this._options.host !== (0, $4f4134156c446392$export$7debb50ef11d5e0b).CLOUD_HOST) pathError = \" If you passed in a `path` to your self-hosted PeerServer, you'll also need to pass in that same path when creating a new Peer.\";\n            throw new Error(\"Could not get an ID from the server.\" + pathError);\n        }\n    }\n    /** @deprecated */ async listAllPeers() {\n        try {\n            const response = await this._buildRequest(\"peers\");\n            if (response.status !== 200) {\n                if (response.status === 401) {\n                    let helpfulError = \"\";\n                    if (this._options.host === (0, $4f4134156c446392$export$7debb50ef11d5e0b).CLOUD_HOST) helpfulError = \"It looks like you're using the cloud server. You can email team@peerjs.com to enable peer listing for your API key.\";\n                    else helpfulError = \"You need to enable `allow_discovery` on your self-hosted PeerServer to use this feature.\";\n                    throw new Error(\"It doesn't look like you have permission to list peers IDs. \" + helpfulError);\n                }\n                throw new Error(`Error. Status:${response.status}`);\n            }\n            return response.json();\n        } catch (error) {\n            (0, $257947e92926277a$export$2e2bcd8739ae039).error(\"Error retrieving list peers\", error);\n            throw new Error(\"Could not get list peers from the server.\" + error);\n        }\n    }\n}\n\n\n\n\n\n\n\n\n\n\nclass $6366c4ca161bc297$export$d365f7ad9d7df9c9 extends (0, $5045192fc6d387ba$export$23a2a68283c24d80) {\n    static #_ = this.ID_PREFIX = \"dc_\";\n    static #_2 = this.MAX_BUFFERED_AMOUNT = 8388608;\n    get type() {\n        return (0, $78455e22dea96b8c$export$3157d57b4135e3bc).Data;\n    }\n    constructor(peerId, provider, options){\n        super(peerId, provider, options);\n        this.connectionId = this.options.connectionId || $6366c4ca161bc297$export$d365f7ad9d7df9c9.ID_PREFIX + (0, $0e5fd1585784c252$export$4e61f672936bec77)();\n        this.label = this.options.label || this.connectionId;\n        this.reliable = !!this.options.reliable;\n        this._negotiator = new (0, $b82fb8fc0514bfc1$export$89e6bb5ad64bf4a)(this);\n        this._negotiator.startConnection(this.options._payload || {\n            originator: true,\n            reliable: this.reliable\n        });\n    }\n    /** Called by the Negotiator when the DataChannel is ready. */ _initializeDataChannel(dc) {\n        this.dataChannel = dc;\n        this.dataChannel.onopen = ()=>{\n            (0, $257947e92926277a$export$2e2bcd8739ae039).log(`DC#${this.connectionId} dc connection success`);\n            this._open = true;\n            this.emit(\"open\");\n        };\n        this.dataChannel.onmessage = (e)=>{\n            (0, $257947e92926277a$export$2e2bcd8739ae039).log(`DC#${this.connectionId} dc onmessage:`, e.data);\n        // this._handleDataMessage(e);\n        };\n        this.dataChannel.onclose = ()=>{\n            (0, $257947e92926277a$export$2e2bcd8739ae039).log(`DC#${this.connectionId} dc closed for:`, this.peer);\n            this.close();\n        };\n    }\n    /**\n\t * Exposed functionality for users.\n\t */ /** Allows user to close connection. */ close(options) {\n        if (options?.flush) {\n            this.send({\n                __peerData: {\n                    type: \"close\"\n                }\n            });\n            return;\n        }\n        if (this._negotiator) {\n            this._negotiator.cleanup();\n            this._negotiator = null;\n        }\n        if (this.provider) {\n            this.provider._removeConnection(this);\n            this.provider = null;\n        }\n        if (this.dataChannel) {\n            this.dataChannel.onopen = null;\n            this.dataChannel.onmessage = null;\n            this.dataChannel.onclose = null;\n            this.dataChannel = null;\n        }\n        if (!this.open) return;\n        this._open = false;\n        super.emit(\"close\");\n    }\n    /** Allows user to send data. */ send(data, chunked = false) {\n        if (!this.open) {\n            this.emitError((0, $78455e22dea96b8c$export$49ae800c114df41d).NotOpenYet, \"Connection is not open. You should listen for the `open` event before sending messages.\");\n            return;\n        }\n        return this._send(data, chunked);\n    }\n    async handleMessage(message) {\n        const payload = message.payload;\n        switch(message.type){\n            case (0, $78455e22dea96b8c$export$adb4a1754da6f10d).Answer:\n                await this._negotiator.handleSDP(message.type, payload.sdp);\n                break;\n            case (0, $78455e22dea96b8c$export$adb4a1754da6f10d).Candidate:\n                await this._negotiator.handleCandidate(payload.candidate);\n                break;\n            default:\n                (0, $257947e92926277a$export$2e2bcd8739ae039).warn(\"Unrecognized message type:\", message.type, \"from peer:\", this.peer);\n                break;\n        }\n    }\n}\n\n\nclass $a229bedbcaa6ca23$export$ff7c9d4c11d94e8b extends (0, $6366c4ca161bc297$export$d365f7ad9d7df9c9) {\n    get bufferSize() {\n        return this._bufferSize;\n    }\n    _initializeDataChannel(dc) {\n        super._initializeDataChannel(dc);\n        this.dataChannel.binaryType = \"arraybuffer\";\n        this.dataChannel.addEventListener(\"message\", (e)=>this._handleDataMessage(e));\n    }\n    _bufferedSend(msg) {\n        if (this._buffering || !this._trySend(msg)) {\n            this._buffer.push(msg);\n            this._bufferSize = this._buffer.length;\n        }\n    }\n    // Returns true if the send succeeds.\n    _trySend(msg) {\n        if (!this.open) return false;\n        if (this.dataChannel.bufferedAmount > (0, $6366c4ca161bc297$export$d365f7ad9d7df9c9).MAX_BUFFERED_AMOUNT) {\n            this._buffering = true;\n            setTimeout(()=>{\n                this._buffering = false;\n                this._tryBuffer();\n            }, 50);\n            return false;\n        }\n        try {\n            this.dataChannel.send(msg);\n        } catch (e) {\n            (0, $257947e92926277a$export$2e2bcd8739ae039).error(`DC#:${this.connectionId} Error when sending:`, e);\n            this._buffering = true;\n            this.close();\n            return false;\n        }\n        return true;\n    }\n    // Try to send the first message in the buffer.\n    _tryBuffer() {\n        if (!this.open) return;\n        if (this._buffer.length === 0) return;\n        const msg = this._buffer[0];\n        if (this._trySend(msg)) {\n            this._buffer.shift();\n            this._bufferSize = this._buffer.length;\n            this._tryBuffer();\n        }\n    }\n    close(options) {\n        if (options?.flush) {\n            this.send({\n                __peerData: {\n                    type: \"close\"\n                }\n            });\n            return;\n        }\n        this._buffer = [];\n        this._bufferSize = 0;\n        super.close();\n    }\n    constructor(...args){\n        super(...args);\n        this._buffer = [];\n        this._bufferSize = 0;\n        this._buffering = false;\n    }\n}\n\n\n\n\nclass $9fcfddb3ae148f88$export$f0a5a64d5bb37108 extends (0, $a229bedbcaa6ca23$export$ff7c9d4c11d94e8b) {\n    close(options) {\n        super.close(options);\n        this._chunkedData = {};\n    }\n    constructor(peerId, provider, options){\n        super(peerId, provider, options);\n        this.chunker = new (0, $fcbcc7538a6776d5$export$f1c5f4c9cb95390b)();\n        this.serialization = (0, $78455e22dea96b8c$export$89f507cf986a947).Binary;\n        this._chunkedData = {};\n    }\n    // Handles a DataChannel message.\n    _handleDataMessage({ data: data }) {\n        const deserializedData = (0, peerjs_js_binarypack__WEBPACK_IMPORTED_MODULE_0__.unpack)(data);\n        // PeerJS specific message\n        const peerData = deserializedData[\"__peerData\"];\n        if (peerData) {\n            if (peerData.type === \"close\") {\n                this.close();\n                return;\n            }\n            // Chunked data -- piece things back together.\n            // @ts-ignore\n            this._handleChunk(deserializedData);\n            return;\n        }\n        this.emit(\"data\", deserializedData);\n    }\n    _handleChunk(data) {\n        const id = data.__peerData;\n        const chunkInfo = this._chunkedData[id] || {\n            data: [],\n            count: 0,\n            total: data.total\n        };\n        chunkInfo.data[data.n] = new Uint8Array(data.data);\n        chunkInfo.count++;\n        this._chunkedData[id] = chunkInfo;\n        if (chunkInfo.total === chunkInfo.count) {\n            // Clean up before making the recursive call to `_handleDataMessage`.\n            delete this._chunkedData[id];\n            // We've received all the chunks--time to construct the complete data.\n            // const data = new Blob(chunkInfo.data);\n            const data = (0, $fcbcc7538a6776d5$export$52c89ebcdc4f53f2)(chunkInfo.data);\n            this._handleDataMessage({\n                data: data\n            });\n        }\n    }\n    _send(data, chunked) {\n        const blob = (0, peerjs_js_binarypack__WEBPACK_IMPORTED_MODULE_0__.pack)(data);\n        if (blob instanceof Promise) return this._send_blob(blob);\n        if (!chunked && blob.byteLength > this.chunker.chunkedMTU) {\n            this._sendChunks(blob);\n            return;\n        }\n        this._bufferedSend(blob);\n    }\n    async _send_blob(blobPromise) {\n        const blob = await blobPromise;\n        if (blob.byteLength > this.chunker.chunkedMTU) {\n            this._sendChunks(blob);\n            return;\n        }\n        this._bufferedSend(blob);\n    }\n    _sendChunks(blob) {\n        const blobs = this.chunker.chunk(blob);\n        (0, $257947e92926277a$export$2e2bcd8739ae039).log(`DC#${this.connectionId} Try to send ${blobs.length} chunks...`);\n        for (const blob of blobs)this.send(blob, true);\n    }\n}\n\n\n\n\nclass $bbaee3f15f714663$export$6f88fe47d32c9c94 extends (0, $a229bedbcaa6ca23$export$ff7c9d4c11d94e8b) {\n    _handleDataMessage({ data: data }) {\n        super.emit(\"data\", data);\n    }\n    _send(data, _chunked) {\n        this._bufferedSend(data);\n    }\n    constructor(...args){\n        super(...args);\n        this.serialization = (0, $78455e22dea96b8c$export$89f507cf986a947).None;\n    }\n}\n\n\n\n\n\nclass $817f931e3f9096cf$export$48880ac635f47186 extends (0, $a229bedbcaa6ca23$export$ff7c9d4c11d94e8b) {\n    // Handles a DataChannel message.\n    _handleDataMessage({ data: data }) {\n        const deserializedData = this.parse(this.decoder.decode(data));\n        // PeerJS specific message\n        const peerData = deserializedData[\"__peerData\"];\n        if (peerData && peerData.type === \"close\") {\n            this.close();\n            return;\n        }\n        this.emit(\"data\", deserializedData);\n    }\n    _send(data, _chunked) {\n        const encodedData = this.encoder.encode(this.stringify(data));\n        if (encodedData.byteLength >= (0, $4f4134156c446392$export$7debb50ef11d5e0b).chunkedMTU) {\n            this.emitError((0, $78455e22dea96b8c$export$49ae800c114df41d).MessageToBig, \"Message too big for JSON channel\");\n            return;\n        }\n        this._bufferedSend(encodedData);\n    }\n    constructor(...args){\n        super(...args);\n        this.serialization = (0, $78455e22dea96b8c$export$89f507cf986a947).JSON;\n        this.encoder = new TextEncoder();\n        this.decoder = new TextDecoder();\n        this.stringify = JSON.stringify;\n        this.parse = JSON.parse;\n    }\n}\n\n\n\nclass $416260bce337df90$var$PeerOptions {\n}\nclass $416260bce337df90$export$ecd1fc136c422448 extends (0, $23779d1881157a18$export$6a678e589c8a4542) {\n    static #_ = this.DEFAULT_KEY = \"peerjs\";\n    /**\n\t * The brokering ID of this peer\n\t *\n\t * If no ID was specified in {@apilink Peer | the constructor},\n\t * this will be `undefined` until the {@apilink PeerEvents | `open`} event is emitted.\n\t */ get id() {\n        return this._id;\n    }\n    get options() {\n        return this._options;\n    }\n    get open() {\n        return this._open;\n    }\n    /**\n\t * @internal\n\t */ get socket() {\n        return this._socket;\n    }\n    /**\n\t * A hash of all connections associated with this peer, keyed by the remote peer's ID.\n\t * @deprecated\n\t * Return type will change from Object to Map<string,[]>\n\t */ get connections() {\n        const plainConnections = Object.create(null);\n        for (const [k, v] of this._connections)plainConnections[k] = v;\n        return plainConnections;\n    }\n    /**\n\t * true if this peer and all of its connections can no longer be used.\n\t */ get destroyed() {\n        return this._destroyed;\n    }\n    /**\n\t * false if there is an active connection to the PeerServer.\n\t */ get disconnected() {\n        return this._disconnected;\n    }\n    constructor(id, options){\n        super();\n        this._serializers = {\n            raw: (0, $bbaee3f15f714663$export$6f88fe47d32c9c94),\n            json: (0, $817f931e3f9096cf$export$48880ac635f47186),\n            binary: (0, $9fcfddb3ae148f88$export$f0a5a64d5bb37108),\n            \"binary-utf8\": (0, $9fcfddb3ae148f88$export$f0a5a64d5bb37108),\n            default: (0, $9fcfddb3ae148f88$export$f0a5a64d5bb37108)\n        };\n        this._id = null;\n        this._lastServerId = null;\n        // States.\n        this._destroyed = false // Connections have been killed\n        ;\n        this._disconnected = false // Connection to PeerServer killed but P2P connections still active\n        ;\n        this._open = false // Sockets and such are not yet open.\n        ;\n        this._connections = new Map() // All connections for this peer.\n        ;\n        this._lostMessages = new Map() // src => [list of messages]\n        ;\n        let userId;\n        // Deal with overloading\n        if (id && id.constructor == Object) options = id;\n        else if (id) userId = id.toString();\n        // Configurize options\n        options = {\n            debug: 0,\n            host: (0, $4f4134156c446392$export$7debb50ef11d5e0b).CLOUD_HOST,\n            port: (0, $4f4134156c446392$export$7debb50ef11d5e0b).CLOUD_PORT,\n            path: \"/\",\n            key: $416260bce337df90$export$ecd1fc136c422448.DEFAULT_KEY,\n            token: (0, $4f4134156c446392$export$7debb50ef11d5e0b).randomToken(),\n            config: (0, $4f4134156c446392$export$7debb50ef11d5e0b).defaultConfig,\n            referrerPolicy: \"strict-origin-when-cross-origin\",\n            serializers: {},\n            ...options\n        };\n        this._options = options;\n        this._serializers = {\n            ...this._serializers,\n            ...this.options.serializers\n        };\n        // Detect relative URL host.\n        if (this._options.host === \"/\") this._options.host = window.location.hostname;\n        // Set path correctly.\n        if (this._options.path) {\n            if (this._options.path[0] !== \"/\") this._options.path = \"/\" + this._options.path;\n            if (this._options.path[this._options.path.length - 1] !== \"/\") this._options.path += \"/\";\n        }\n        // Set whether we use SSL to same as current host\n        if (this._options.secure === undefined && this._options.host !== (0, $4f4134156c446392$export$7debb50ef11d5e0b).CLOUD_HOST) this._options.secure = (0, $4f4134156c446392$export$7debb50ef11d5e0b).isSecure();\n        else if (this._options.host == (0, $4f4134156c446392$export$7debb50ef11d5e0b).CLOUD_HOST) this._options.secure = true;\n        // Set a custom log function if present\n        if (this._options.logFunction) (0, $257947e92926277a$export$2e2bcd8739ae039).setLogFunction(this._options.logFunction);\n        (0, $257947e92926277a$export$2e2bcd8739ae039).logLevel = this._options.debug || 0;\n        this._api = new (0, $abf266641927cd89$export$2c4e825dc9120f87)(options);\n        this._socket = this._createServerConnection();\n        // Sanity checks\n        // Ensure WebRTC supported\n        if (!(0, $4f4134156c446392$export$7debb50ef11d5e0b).supports.audioVideo && !(0, $4f4134156c446392$export$7debb50ef11d5e0b).supports.data) {\n            this._delayedAbort((0, $78455e22dea96b8c$export$9547aaa2e39030ff).BrowserIncompatible, \"The current browser does not support WebRTC\");\n            return;\n        }\n        // Ensure alphanumeric id\n        if (!!userId && !(0, $4f4134156c446392$export$7debb50ef11d5e0b).validateId(userId)) {\n            this._delayedAbort((0, $78455e22dea96b8c$export$9547aaa2e39030ff).InvalidID, `ID \"${userId}\" is invalid`);\n            return;\n        }\n        if (userId) this._initialize(userId);\n        else this._api.retrieveId().then((id)=>this._initialize(id)).catch((error)=>this._abort((0, $78455e22dea96b8c$export$9547aaa2e39030ff).ServerError, error));\n    }\n    _createServerConnection() {\n        const socket = new (0, $8f5bfa60836d261d$export$4798917dbf149b79)(this._options.secure, this._options.host, this._options.port, this._options.path, this._options.key, this._options.pingInterval);\n        socket.on((0, $78455e22dea96b8c$export$3b5c4a4b6354f023).Message, (data)=>{\n            this._handleMessage(data);\n        });\n        socket.on((0, $78455e22dea96b8c$export$3b5c4a4b6354f023).Error, (error)=>{\n            this._abort((0, $78455e22dea96b8c$export$9547aaa2e39030ff).SocketError, error);\n        });\n        socket.on((0, $78455e22dea96b8c$export$3b5c4a4b6354f023).Disconnected, ()=>{\n            if (this.disconnected) return;\n            this.emitError((0, $78455e22dea96b8c$export$9547aaa2e39030ff).Network, \"Lost connection to server.\");\n            this.disconnect();\n        });\n        socket.on((0, $78455e22dea96b8c$export$3b5c4a4b6354f023).Close, ()=>{\n            if (this.disconnected) return;\n            this._abort((0, $78455e22dea96b8c$export$9547aaa2e39030ff).SocketClosed, \"Underlying socket is already closed.\");\n        });\n        return socket;\n    }\n    /** Initialize a connection with the server. */ _initialize(id) {\n        this._id = id;\n        this.socket.start(id, this._options.token);\n    }\n    /** Handles messages from the server. */ _handleMessage(message) {\n        const type = message.type;\n        const payload = message.payload;\n        const peerId = message.src;\n        switch(type){\n            case (0, $78455e22dea96b8c$export$adb4a1754da6f10d).Open:\n                this._lastServerId = this.id;\n                this._open = true;\n                this.emit(\"open\", this.id);\n                break;\n            case (0, $78455e22dea96b8c$export$adb4a1754da6f10d).Error:\n                this._abort((0, $78455e22dea96b8c$export$9547aaa2e39030ff).ServerError, payload.msg);\n                break;\n            case (0, $78455e22dea96b8c$export$adb4a1754da6f10d).IdTaken:\n                this._abort((0, $78455e22dea96b8c$export$9547aaa2e39030ff).UnavailableID, `ID \"${this.id}\" is taken`);\n                break;\n            case (0, $78455e22dea96b8c$export$adb4a1754da6f10d).InvalidKey:\n                this._abort((0, $78455e22dea96b8c$export$9547aaa2e39030ff).InvalidKey, `API KEY \"${this._options.key}\" is invalid`);\n                break;\n            case (0, $78455e22dea96b8c$export$adb4a1754da6f10d).Leave:\n                (0, $257947e92926277a$export$2e2bcd8739ae039).log(`Received leave message from ${peerId}`);\n                this._cleanupPeer(peerId);\n                this._connections.delete(peerId);\n                break;\n            case (0, $78455e22dea96b8c$export$adb4a1754da6f10d).Expire:\n                this.emitError((0, $78455e22dea96b8c$export$9547aaa2e39030ff).PeerUnavailable, `Could not connect to peer ${peerId}`);\n                break;\n            case (0, $78455e22dea96b8c$export$adb4a1754da6f10d).Offer:\n                {\n                    // we should consider switching this to CALL/CONNECT, but this is the least breaking option.\n                    const connectionId = payload.connectionId;\n                    let connection = this.getConnection(peerId, connectionId);\n                    if (connection) {\n                        connection.close();\n                        (0, $257947e92926277a$export$2e2bcd8739ae039).warn(`Offer received for existing Connection ID:${connectionId}`);\n                    }\n                    // Create a new connection.\n                    if (payload.type === (0, $78455e22dea96b8c$export$3157d57b4135e3bc).Media) {\n                        const mediaConnection = new (0, $5c1d08c7c57da9a3$export$4a84e95a2324ac29)(peerId, this, {\n                            connectionId: connectionId,\n                            _payload: payload,\n                            metadata: payload.metadata\n                        });\n                        connection = mediaConnection;\n                        this._addConnection(peerId, connection);\n                        this.emit(\"call\", mediaConnection);\n                    } else if (payload.type === (0, $78455e22dea96b8c$export$3157d57b4135e3bc).Data) {\n                        const dataConnection = new this._serializers[payload.serialization](peerId, this, {\n                            connectionId: connectionId,\n                            _payload: payload,\n                            metadata: payload.metadata,\n                            label: payload.label,\n                            serialization: payload.serialization,\n                            reliable: payload.reliable\n                        });\n                        connection = dataConnection;\n                        this._addConnection(peerId, connection);\n                        this.emit(\"connection\", dataConnection);\n                    } else {\n                        (0, $257947e92926277a$export$2e2bcd8739ae039).warn(`Received malformed connection type:${payload.type}`);\n                        return;\n                    }\n                    // Find messages.\n                    const messages = this._getMessages(connectionId);\n                    for (const message of messages)connection.handleMessage(message);\n                    break;\n                }\n            default:\n                {\n                    if (!payload) {\n                        (0, $257947e92926277a$export$2e2bcd8739ae039).warn(`You received a malformed message from ${peerId} of type ${type}`);\n                        return;\n                    }\n                    const connectionId = payload.connectionId;\n                    const connection = this.getConnection(peerId, connectionId);\n                    if (connection && connection.peerConnection) // Pass it on.\n                    connection.handleMessage(message);\n                    else if (connectionId) // Store for possible later use\n                    this._storeMessage(connectionId, message);\n                    else (0, $257947e92926277a$export$2e2bcd8739ae039).warn(\"You received an unrecognized message:\", message);\n                    break;\n                }\n        }\n    }\n    /** Stores messages without a set up connection, to be claimed later. */ _storeMessage(connectionId, message) {\n        if (!this._lostMessages.has(connectionId)) this._lostMessages.set(connectionId, []);\n        this._lostMessages.get(connectionId).push(message);\n    }\n    /**\n\t * Retrieve messages from lost message store\n\t * @internal\n\t */ //TODO Change it to private\n    _getMessages(connectionId) {\n        const messages = this._lostMessages.get(connectionId);\n        if (messages) {\n            this._lostMessages.delete(connectionId);\n            return messages;\n        }\n        return [];\n    }\n    /**\n\t * Connects to the remote peer specified by id and returns a data connection.\n\t * @param peer The brokering ID of the remote peer (their {@apilink Peer.id}).\n\t * @param options for specifying details about Peer Connection\n\t */ connect(peer, options = {}) {\n        options = {\n            serialization: \"default\",\n            ...options\n        };\n        if (this.disconnected) {\n            (0, $257947e92926277a$export$2e2bcd8739ae039).warn(\"You cannot connect to a new Peer because you called .disconnect() on this Peer and ended your connection with the server. You can create a new Peer to reconnect, or call reconnect on this peer if you believe its ID to still be available.\");\n            this.emitError((0, $78455e22dea96b8c$export$9547aaa2e39030ff).Disconnected, \"Cannot connect to new Peer after disconnecting from server.\");\n            return;\n        }\n        const dataConnection = new this._serializers[options.serialization](peer, this, options);\n        this._addConnection(peer, dataConnection);\n        return dataConnection;\n    }\n    /**\n\t * Calls the remote peer specified by id and returns a media connection.\n\t * @param peer The brokering ID of the remote peer (their peer.id).\n\t * @param stream The caller's media stream\n\t * @param options Metadata associated with the connection, passed in by whoever initiated the connection.\n\t */ call(peer, stream, options = {}) {\n        if (this.disconnected) {\n            (0, $257947e92926277a$export$2e2bcd8739ae039).warn(\"You cannot connect to a new Peer because you called .disconnect() on this Peer and ended your connection with the server. You can create a new Peer to reconnect.\");\n            this.emitError((0, $78455e22dea96b8c$export$9547aaa2e39030ff).Disconnected, \"Cannot connect to new Peer after disconnecting from server.\");\n            return;\n        }\n        if (!stream) {\n            (0, $257947e92926277a$export$2e2bcd8739ae039).error(\"To call a peer, you must provide a stream from your browser's `getUserMedia`.\");\n            return;\n        }\n        const mediaConnection = new (0, $5c1d08c7c57da9a3$export$4a84e95a2324ac29)(peer, this, {\n            ...options,\n            _stream: stream\n        });\n        this._addConnection(peer, mediaConnection);\n        return mediaConnection;\n    }\n    /** Add a data/media connection to this peer. */ _addConnection(peerId, connection) {\n        (0, $257947e92926277a$export$2e2bcd8739ae039).log(`add connection ${connection.type}:${connection.connectionId} to peerId:${peerId}`);\n        if (!this._connections.has(peerId)) this._connections.set(peerId, []);\n        this._connections.get(peerId).push(connection);\n    }\n    //TODO should be private\n    _removeConnection(connection) {\n        const connections = this._connections.get(connection.peer);\n        if (connections) {\n            const index = connections.indexOf(connection);\n            if (index !== -1) connections.splice(index, 1);\n        }\n        //remove from lost messages\n        this._lostMessages.delete(connection.connectionId);\n    }\n    /** Retrieve a data/media connection for this peer. */ getConnection(peerId, connectionId) {\n        const connections = this._connections.get(peerId);\n        if (!connections) return null;\n        for (const connection of connections){\n            if (connection.connectionId === connectionId) return connection;\n        }\n        return null;\n    }\n    _delayedAbort(type, message) {\n        setTimeout(()=>{\n            this._abort(type, message);\n        }, 0);\n    }\n    /**\n\t * Emits an error message and destroys the Peer.\n\t * The Peer is not destroyed if it's in a disconnected state, in which case\n\t * it retains its disconnected state and its existing connections.\n\t */ _abort(type, message) {\n        (0, $257947e92926277a$export$2e2bcd8739ae039).error(\"Aborting!\");\n        this.emitError(type, message);\n        if (!this._lastServerId) this.destroy();\n        else this.disconnect();\n    }\n    /**\n\t * Destroys the Peer: closes all active connections as well as the connection\n\t * to the server.\n\t *\n\t * :::caution\n\t * This cannot be undone; the respective peer object will no longer be able\n\t * to create or receive any connections, its ID will be forfeited on the server,\n\t * and all of its data and media connections will be closed.\n\t * :::\n\t */ destroy() {\n        if (this.destroyed) return;\n        (0, $257947e92926277a$export$2e2bcd8739ae039).log(`Destroy peer with ID:${this.id}`);\n        this.disconnect();\n        this._cleanup();\n        this._destroyed = true;\n        this.emit(\"close\");\n    }\n    /** Disconnects every connection on this peer. */ _cleanup() {\n        for (const peerId of this._connections.keys()){\n            this._cleanupPeer(peerId);\n            this._connections.delete(peerId);\n        }\n        this.socket.removeAllListeners();\n    }\n    /** Closes all connections to this peer. */ _cleanupPeer(peerId) {\n        const connections = this._connections.get(peerId);\n        if (!connections) return;\n        for (const connection of connections)connection.close();\n    }\n    /**\n\t * Disconnects the Peer's connection to the PeerServer. Does not close any\n\t *  active connections.\n\t * Warning: The peer can no longer create or accept connections after being\n\t *  disconnected. It also cannot reconnect to the server.\n\t */ disconnect() {\n        if (this.disconnected) return;\n        const currentId = this.id;\n        (0, $257947e92926277a$export$2e2bcd8739ae039).log(`Disconnect peer with ID:${currentId}`);\n        this._disconnected = true;\n        this._open = false;\n        this.socket.close();\n        this._lastServerId = currentId;\n        this._id = null;\n        this.emit(\"disconnected\", currentId);\n    }\n    /** Attempts to reconnect with the same ID.\n\t *\n\t * Only {@apilink Peer.disconnect | disconnected peers} can be reconnected.\n\t * Destroyed peers cannot be reconnected.\n\t * If the connection fails (as an example, if the peer's old ID is now taken),\n\t * the peer's existing connections will not close, but any associated errors events will fire.\n\t */ reconnect() {\n        if (this.disconnected && !this.destroyed) {\n            (0, $257947e92926277a$export$2e2bcd8739ae039).log(`Attempting reconnection to server with ID ${this._lastServerId}`);\n            this._disconnected = false;\n            this._initialize(this._lastServerId);\n        } else if (this.destroyed) throw new Error(\"This peer cannot reconnect to the server. It has already been destroyed.\");\n        else if (!this.disconnected && !this.open) // Do nothing. We're still connecting the first time.\n        (0, $257947e92926277a$export$2e2bcd8739ae039).error(\"In a hurry? We're still trying to make the initial connection!\");\n        else throw new Error(`Peer ${this.id} cannot reconnect because it is not disconnected from the server!`);\n    }\n    /**\n\t * Get a list of available peer IDs. If you're running your own server, you'll\n\t * want to set allow_discovery: true in the PeerServer options. If you're using\n\t * the cloud server, email team@peerjs.com to get the functionality enabled for\n\t * your key.\n\t */ listAllPeers(cb = (_)=>{}) {\n        this._api.listAllPeers().then((peers)=>cb(peers)).catch((error)=>this._abort((0, $78455e22dea96b8c$export$9547aaa2e39030ff).ServerError, error));\n    }\n}\n\n\n\n\n\n\nclass $20dbe68149d7aad9$export$72aa44612e2200cd extends (0, $6366c4ca161bc297$export$d365f7ad9d7df9c9) {\n    constructor(peerId, provider, options){\n        super(peerId, provider, {\n            ...options,\n            reliable: true\n        });\n        this._CHUNK_SIZE = 32768;\n        this._splitStream = new TransformStream({\n            transform: (chunk, controller)=>{\n                for(let split = 0; split < chunk.length; split += this._CHUNK_SIZE)controller.enqueue(chunk.subarray(split, split + this._CHUNK_SIZE));\n            }\n        });\n        this._rawSendStream = new WritableStream({\n            write: async (chunk, controller)=>{\n                const openEvent = new Promise((resolve)=>this.dataChannel.addEventListener(\"bufferedamountlow\", resolve, {\n                        once: true\n                    }));\n                // if we can send the chunk now, send it\n                // if not, we wait until at least half of the sending buffer is free again\n                await (this.dataChannel.bufferedAmount <= (0, $6366c4ca161bc297$export$d365f7ad9d7df9c9).MAX_BUFFERED_AMOUNT - chunk.byteLength || openEvent);\n                // TODO: what can go wrong here?\n                try {\n                    this.dataChannel.send(chunk);\n                } catch (e) {\n                    (0, $257947e92926277a$export$2e2bcd8739ae039).error(`DC#:${this.connectionId} Error when sending:`, e);\n                    controller.error(e);\n                    this.close();\n                }\n            }\n        });\n        this.writer = this._splitStream.writable.getWriter();\n        this._rawReadStream = new ReadableStream({\n            start: (controller)=>{\n                this.once(\"open\", ()=>{\n                    this.dataChannel.addEventListener(\"message\", (e)=>{\n                        controller.enqueue(e.data);\n                    });\n                });\n            }\n        });\n        this._splitStream.readable.pipeTo(this._rawSendStream);\n    }\n    _initializeDataChannel(dc) {\n        super._initializeDataChannel(dc);\n        this.dataChannel.binaryType = \"arraybuffer\";\n        this.dataChannel.bufferedAmountLowThreshold = (0, $6366c4ca161bc297$export$d365f7ad9d7df9c9).MAX_BUFFERED_AMOUNT / 2;\n    }\n}\n\n\nclass $6e39230ab36396ad$export$80f5de1a66c4d624 extends (0, $20dbe68149d7aad9$export$72aa44612e2200cd) {\n    constructor(peerId, provider, options){\n        super(peerId, provider, options);\n        this.serialization = \"MsgPack\";\n        this._encoder = new (0, _msgpack_msgpack__WEBPACK_IMPORTED_MODULE_2__.Encoder)();\n        (async ()=>{\n            for await (const msg of (0, _msgpack_msgpack__WEBPACK_IMPORTED_MODULE_3__.decodeMultiStream)(this._rawReadStream)){\n                // @ts-ignore\n                if (msg.__peerData?.type === \"close\") {\n                    this.close();\n                    return;\n                }\n                this.emit(\"data\", msg);\n            }\n        })();\n    }\n    _send(data) {\n        return this.writer.write(this._encoder.encode(data));\n    }\n}\n\n\nclass $1e0aff16be2c328e$export$d72c7bf8eef50853 extends (0, $416260bce337df90$export$ecd1fc136c422448) {\n    constructor(...args){\n        super(...args);\n        this._serializers = {\n            MsgPack: $6e39230ab36396ad$export$80f5de1a66c4d624,\n            default: (0, $6e39230ab36396ad$export$80f5de1a66c4d624)\n        };\n    }\n}\n\n\n\n\n\n\n\nvar $dd0187d7f28e386f$export$2e2bcd8739ae039 = (0, $416260bce337df90$export$ecd1fc136c422448);\n\n\n\n//# sourceMappingURL=bundler.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcGVlcmpzL2Rpc3QvYnVuZGxlci5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFrRjtBQUNoQztBQUN3RDs7O0FBRzFHO0FBQ0EsK0JBQStCLHFEQUFxRDtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQSxJQUFJLHNEQUFvQixpQkFBaUIsc0RBQW9CO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGFBQWE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLGNBQWM7QUFDZCxZQUFZO0FBQ1osd0JBQXdCO0FBQ3hCLHlCQUF5QjtBQUN6Qiw2QkFBNkIsOEJBQThCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsbUJBQW1CO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLG1CQUFtQjtBQUN2RjtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsbUJBQW1CO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLHVFQUF1RSxtQkFBbUI7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFGQUFxRixVQUFVO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsK0NBQStDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyR0FBMkcsbUJBQW1CO0FBQzlIO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLHFDQUFxQyxTQUFTO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxzQkFBc0I7QUFDekQ7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLCtFQUErRSxtQkFBbUI7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxxREFBYztBQUM5QztBQUNBLHdDQUF3QywrREFBd0I7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQVFBOzs7QUFHNjRCO0FBQzc0QiIsInNvdXJjZXMiOlsid2VicGFjazovL3BpY3RvLWd1ZXNzLy4vbm9kZV9tb2R1bGVzL3BlZXJqcy9kaXN0L2J1bmRsZXIubWpzP2RmMzkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtwYWNrIGFzICRnQ2NiWSRwYWNrLCB1bnBhY2sgYXMgJGdDY2JZJHVucGFja30gZnJvbSBcInBlZXJqcy1qcy1iaW5hcnlwYWNrXCI7XG5pbXBvcnQgJGdDY2JZJHdlYnJ0Y2FkYXB0ZXIgZnJvbSBcIndlYnJ0Yy1hZGFwdGVyXCI7XG5pbXBvcnQge0VuY29kZXIgYXMgJGdDY2JZJEVuY29kZXIsIGRlY29kZU11bHRpU3RyZWFtIGFzICRnQ2NiWSRkZWNvZGVNdWx0aVN0cmVhbX0gZnJvbSBcIkBtc2dwYWNrL21zZ3BhY2tcIjtcblxuXG5mdW5jdGlvbiAkcGFyY2VsJGV4cG9ydChlLCBuLCB2LCBzKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBuLCB7Z2V0OiB2LCBzZXQ6IHMsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZX0pO1xufVxuY2xhc3MgJGZjYmNjNzUzOGE2Nzc2ZDUkZXhwb3J0JGYxYzVmNGM5Y2I5NTM5MGIge1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHRoaXMuY2h1bmtlZE1UVSA9IDE2MzAwIC8vIFRoZSBvcmlnaW5hbCA2MDAwMCBieXRlcyBzZXR0aW5nIGRvZXMgbm90IHdvcmsgd2hlbiBzZW5kaW5nIGRhdGEgZnJvbSBGaXJlZm94IHRvIENocm9tZSwgd2hpY2ggaXMgXCJjdXQgb2ZmXCIgYWZ0ZXIgMTYzODQgYnl0ZXMgYW5kIGRlbGl2ZXJlZCBpbmRpdmlkdWFsbHkuXG4gICAgICAgIDtcbiAgICAgICAgLy8gQmluYXJ5IHN0dWZmXG4gICAgICAgIHRoaXMuX2RhdGFDb3VudCA9IDE7XG4gICAgICAgIHRoaXMuY2h1bmsgPSAoYmxvYik9PntcbiAgICAgICAgICAgIGNvbnN0IGNodW5rcyA9IFtdO1xuICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IGJsb2IuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IHRvdGFsID0gTWF0aC5jZWlsKHNpemUgLyB0aGlzLmNodW5rZWRNVFUpO1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IDA7XG4gICAgICAgICAgICB3aGlsZShzdGFydCA8IHNpemUpe1xuICAgICAgICAgICAgICAgIGNvbnN0IGVuZCA9IE1hdGgubWluKHNpemUsIHN0YXJ0ICsgdGhpcy5jaHVua2VkTVRVKTtcbiAgICAgICAgICAgICAgICBjb25zdCBiID0gYmxvYi5zbGljZShzdGFydCwgZW5kKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjaHVuayA9IHtcbiAgICAgICAgICAgICAgICAgICAgX19wZWVyRGF0YTogdGhpcy5fZGF0YUNvdW50LFxuICAgICAgICAgICAgICAgICAgICBuOiBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogYixcbiAgICAgICAgICAgICAgICAgICAgdG90YWw6IHRvdGFsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjaHVua3MucHVzaChjaHVuayk7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSBlbmQ7XG4gICAgICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2RhdGFDb3VudCsrO1xuICAgICAgICAgICAgcmV0dXJuIGNodW5rcztcbiAgICAgICAgfTtcbiAgICB9XG59XG5mdW5jdGlvbiAkZmNiY2M3NTM4YTY3NzZkNSRleHBvcnQkNTJjODllYmNkYzRmNTNmMihidWZzKSB7XG4gICAgbGV0IHNpemUgPSAwO1xuICAgIGZvciAoY29uc3QgYnVmIG9mIGJ1ZnMpc2l6ZSArPSBidWYuYnl0ZUxlbmd0aDtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheShzaXplKTtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICBmb3IgKGNvbnN0IGJ1ZiBvZiBidWZzKXtcbiAgICAgICAgcmVzdWx0LnNldChidWYsIG9mZnNldCk7XG4gICAgICAgIG9mZnNldCArPSBidWYuYnl0ZUxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuXG5cblxuY29uc3QgJGZiNjNlNzY2Y2ZhZmFhYjkkdmFyJHdlYlJUQ0FkYXB0ZXIgPSAvL0B0cy1pZ25vcmVcbigwLCAkZ0NjYlkkd2VicnRjYWRhcHRlcikuZGVmYXVsdCB8fCAoMCwgJGdDY2JZJHdlYnJ0Y2FkYXB0ZXIpO1xuY29uc3QgJGZiNjNlNzY2Y2ZhZmFhYjkkZXhwb3J0JDI1YmU5NTAyNDc3YzEzN2QgPSBuZXcgY2xhc3Mge1xuICAgIGlzV2ViUlRDU3VwcG9ydGVkKCkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIFJUQ1BlZXJDb25uZWN0aW9uICE9PSBcInVuZGVmaW5lZFwiO1xuICAgIH1cbiAgICBpc0Jyb3dzZXJTdXBwb3J0ZWQoKSB7XG4gICAgICAgIGNvbnN0IGJyb3dzZXIgPSB0aGlzLmdldEJyb3dzZXIoKTtcbiAgICAgICAgY29uc3QgdmVyc2lvbiA9IHRoaXMuZ2V0VmVyc2lvbigpO1xuICAgICAgICBjb25zdCB2YWxpZEJyb3dzZXIgPSB0aGlzLnN1cHBvcnRlZEJyb3dzZXJzLmluY2x1ZGVzKGJyb3dzZXIpO1xuICAgICAgICBpZiAoIXZhbGlkQnJvd3NlcikgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoYnJvd3NlciA9PT0gXCJjaHJvbWVcIikgcmV0dXJuIHZlcnNpb24gPj0gdGhpcy5taW5DaHJvbWVWZXJzaW9uO1xuICAgICAgICBpZiAoYnJvd3NlciA9PT0gXCJmaXJlZm94XCIpIHJldHVybiB2ZXJzaW9uID49IHRoaXMubWluRmlyZWZveFZlcnNpb247XG4gICAgICAgIGlmIChicm93c2VyID09PSBcInNhZmFyaVwiKSByZXR1cm4gIXRoaXMuaXNJT1MgJiYgdmVyc2lvbiA+PSB0aGlzLm1pblNhZmFyaVZlcnNpb247XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZ2V0QnJvd3NlcigpIHtcbiAgICAgICAgcmV0dXJuICRmYjYzZTc2NmNmYWZhYWI5JHZhciR3ZWJSVENBZGFwdGVyLmJyb3dzZXJEZXRhaWxzLmJyb3dzZXI7XG4gICAgfVxuICAgIGdldFZlcnNpb24oKSB7XG4gICAgICAgIHJldHVybiAkZmI2M2U3NjZjZmFmYWFiOSR2YXIkd2ViUlRDQWRhcHRlci5icm93c2VyRGV0YWlscy52ZXJzaW9uIHx8IDA7XG4gICAgfVxuICAgIGlzVW5pZmllZFBsYW5TdXBwb3J0ZWQoKSB7XG4gICAgICAgIGNvbnN0IGJyb3dzZXIgPSB0aGlzLmdldEJyb3dzZXIoKTtcbiAgICAgICAgY29uc3QgdmVyc2lvbiA9ICRmYjYzZTc2NmNmYWZhYWI5JHZhciR3ZWJSVENBZGFwdGVyLmJyb3dzZXJEZXRhaWxzLnZlcnNpb24gfHwgMDtcbiAgICAgICAgaWYgKGJyb3dzZXIgPT09IFwiY2hyb21lXCIgJiYgdmVyc2lvbiA8IHRoaXMubWluQ2hyb21lVmVyc2lvbikgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoYnJvd3NlciA9PT0gXCJmaXJlZm94XCIgJiYgdmVyc2lvbiA+PSB0aGlzLm1pbkZpcmVmb3hWZXJzaW9uKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKCF3aW5kb3cuUlRDUnRwVHJhbnNjZWl2ZXIgfHwgIShcImN1cnJlbnREaXJlY3Rpb25cIiBpbiBSVENSdHBUcmFuc2NlaXZlci5wcm90b3R5cGUpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCB0ZW1wUGM7XG4gICAgICAgIGxldCBzdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRlbXBQYyA9IG5ldyBSVENQZWVyQ29ubmVjdGlvbigpO1xuICAgICAgICAgICAgdGVtcFBjLmFkZFRyYW5zY2VpdmVyKFwiYXVkaW9cIik7XG4gICAgICAgICAgICBzdXBwb3J0ZWQgPSB0cnVlO1xuICAgICAgICB9IGNhdGNoIChlKSB7fSBmaW5hbGx5e1xuICAgICAgICAgICAgaWYgKHRlbXBQYykgdGVtcFBjLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cHBvcnRlZDtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBgU3VwcG9ydHM6XG4gICAgYnJvd3Nlcjoke3RoaXMuZ2V0QnJvd3NlcigpfVxuICAgIHZlcnNpb246JHt0aGlzLmdldFZlcnNpb24oKX1cbiAgICBpc0lPUzoke3RoaXMuaXNJT1N9XG4gICAgaXNXZWJSVENTdXBwb3J0ZWQ6JHt0aGlzLmlzV2ViUlRDU3VwcG9ydGVkKCl9XG4gICAgaXNCcm93c2VyU3VwcG9ydGVkOiR7dGhpcy5pc0Jyb3dzZXJTdXBwb3J0ZWQoKX1cbiAgICBpc1VuaWZpZWRQbGFuU3VwcG9ydGVkOiR7dGhpcy5pc1VuaWZpZWRQbGFuU3VwcG9ydGVkKCl9YDtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgdGhpcy5pc0lPUyA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09IFwidW5kZWZpbmVkXCIgPyBbXG4gICAgICAgICAgICBcImlQYWRcIixcbiAgICAgICAgICAgIFwiaVBob25lXCIsXG4gICAgICAgICAgICBcImlQb2RcIlxuICAgICAgICBdLmluY2x1ZGVzKG5hdmlnYXRvci5wbGF0Zm9ybSkgOiBmYWxzZTtcbiAgICAgICAgdGhpcy5zdXBwb3J0ZWRCcm93c2VycyA9IFtcbiAgICAgICAgICAgIFwiZmlyZWZveFwiLFxuICAgICAgICAgICAgXCJjaHJvbWVcIixcbiAgICAgICAgICAgIFwic2FmYXJpXCJcbiAgICAgICAgXTtcbiAgICAgICAgdGhpcy5taW5GaXJlZm94VmVyc2lvbiA9IDU5O1xuICAgICAgICB0aGlzLm1pbkNocm9tZVZlcnNpb24gPSA3MjtcbiAgICAgICAgdGhpcy5taW5TYWZhcmlWZXJzaW9uID0gNjA1O1xuICAgIH1cbn0oKTtcblxuXG5jb25zdCAkOWE4NGEzMmJmMGJmMzZiYiRleHBvcnQkZjM1ZjEyOGZkNTllYTI1NiA9IChpZCk9PntcbiAgICAvLyBBbGxvdyBlbXB0eSBpZHNcbiAgICByZXR1cm4gIWlkIHx8IC9eW0EtWmEtejAtOV0rKD86WyBfLV1bQS1aYS16MC05XSspKiQvLnRlc3QoaWQpO1xufTtcblxuXG5jb25zdCAkMGU1ZmQxNTg1Nzg0YzI1MiRleHBvcnQkNGU2MWY2NzI5MzZiZWM3NyA9ICgpPT5NYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKTtcblxuXG5jb25zdCAkNGY0MTM0MTU2YzQ0NjM5MiR2YXIkREVGQVVMVF9DT05GSUcgPSB7XG4gICAgaWNlU2VydmVyczogW1xuICAgICAgICB7XG4gICAgICAgICAgICB1cmxzOiBcInN0dW46c3R1bi5sLmdvb2dsZS5jb206MTkzMDJcIlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICB1cmxzOiBbXG4gICAgICAgICAgICAgICAgXCJ0dXJuOmV1LTAudHVybi5wZWVyanMuY29tOjM0NzhcIixcbiAgICAgICAgICAgICAgICBcInR1cm46dXMtMC50dXJuLnBlZXJqcy5jb206MzQ3OFwiXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgdXNlcm5hbWU6IFwicGVlcmpzXCIsXG4gICAgICAgICAgICBjcmVkZW50aWFsOiBcInBlZXJqc3BcIlxuICAgICAgICB9XG4gICAgXSxcbiAgICBzZHBTZW1hbnRpY3M6IFwidW5pZmllZC1wbGFuXCJcbn07XG5jbGFzcyAkNGY0MTM0MTU2YzQ0NjM5MiRleHBvcnQkZjhmMjZkZDM5NWQ3ZTFiZCBleHRlbmRzICgwLCAkZmNiY2M3NTM4YTY3NzZkNSRleHBvcnQkZjFjNWY0YzljYjk1MzkwYikge1xuICAgIG5vb3AoKSB7fVxuICAgIGJsb2JUb0FycmF5QnVmZmVyKGJsb2IsIGNiKSB7XG4gICAgICAgIGNvbnN0IGZyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgICAgZnIub25sb2FkID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgICAgICBpZiAoZXZ0LnRhcmdldCkgY2IoZXZ0LnRhcmdldC5yZXN1bHQpO1xuICAgICAgICB9O1xuICAgICAgICBmci5yZWFkQXNBcnJheUJ1ZmZlcihibG9iKTtcbiAgICAgICAgcmV0dXJuIGZyO1xuICAgIH1cbiAgICBiaW5hcnlTdHJpbmdUb0FycmF5QnVmZmVyKGJpbmFyeSkge1xuICAgICAgICBjb25zdCBieXRlQXJyYXkgPSBuZXcgVWludDhBcnJheShiaW5hcnkubGVuZ3RoKTtcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IGJpbmFyeS5sZW5ndGg7IGkrKylieXRlQXJyYXlbaV0gPSBiaW5hcnkuY2hhckNvZGVBdChpKSAmIDB4ZmY7XG4gICAgICAgIHJldHVybiBieXRlQXJyYXkuYnVmZmVyO1xuICAgIH1cbiAgICBpc1NlY3VyZSgpIHtcbiAgICAgICAgcmV0dXJuIGxvY2F0aW9uLnByb3RvY29sID09PSBcImh0dHBzOlwiO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKXtcbiAgICAgICAgc3VwZXIoLi4uYXJncyk7XG4gICAgICAgIHRoaXMuQ0xPVURfSE9TVCA9IFwiMC5wZWVyanMuY29tXCI7XG4gICAgICAgIHRoaXMuQ0xPVURfUE9SVCA9IDQ0MztcbiAgICAgICAgLy8gQnJvd3NlcnMgdGhhdCBuZWVkIGNodW5raW5nOlxuICAgICAgICB0aGlzLmNodW5rZWRCcm93c2VycyA9IHtcbiAgICAgICAgICAgIENocm9tZTogMSxcbiAgICAgICAgICAgIGNocm9tZTogMVxuICAgICAgICB9O1xuICAgICAgICAvLyBSZXR1cm5zIGJyb3dzZXItYWdub3N0aWMgZGVmYXVsdCBjb25maWdcbiAgICAgICAgdGhpcy5kZWZhdWx0Q29uZmlnID0gJDRmNDEzNDE1NmM0NDYzOTIkdmFyJERFRkFVTFRfQ09ORklHO1xuICAgICAgICB0aGlzLmJyb3dzZXIgPSAoMCwgJGZiNjNlNzY2Y2ZhZmFhYjkkZXhwb3J0JDI1YmU5NTAyNDc3YzEzN2QpLmdldEJyb3dzZXIoKTtcbiAgICAgICAgdGhpcy5icm93c2VyVmVyc2lvbiA9ICgwLCAkZmI2M2U3NjZjZmFmYWFiOSRleHBvcnQkMjViZTk1MDI0NzdjMTM3ZCkuZ2V0VmVyc2lvbigpO1xuICAgICAgICB0aGlzLnBhY2sgPSAkZ0NjYlkkcGFjaztcbiAgICAgICAgdGhpcy51bnBhY2sgPSAkZ0NjYlkkdW5wYWNrO1xuICAgICAgICAvKipcblx0ICogQSBoYXNoIG9mIFdlYlJUQyBmZWF0dXJlcyBtYXBwZWQgdG8gYm9vbGVhbnMgdGhhdCBjb3JyZXNwb25kIHRvIHdoZXRoZXIgdGhlIGZlYXR1cmUgaXMgc3VwcG9ydGVkIGJ5IHRoZSBjdXJyZW50IGJyb3dzZXIuXG5cdCAqXG5cdCAqIDo6OmNhdXRpb25cblx0ICogT25seSB0aGUgcHJvcGVydGllcyBkb2N1bWVudGVkIGhlcmUgYXJlIGd1YXJhbnRlZWQgdG8gYmUgcHJlc2VudCBvbiBgdXRpbC5zdXBwb3J0c2Bcblx0ICogOjo6XG5cdCAqLyB0aGlzLnN1cHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBjb25zdCBzdXBwb3J0ZWQgPSB7XG4gICAgICAgICAgICAgICAgYnJvd3NlcjogKDAsICRmYjYzZTc2NmNmYWZhYWI5JGV4cG9ydCQyNWJlOTUwMjQ3N2MxMzdkKS5pc0Jyb3dzZXJTdXBwb3J0ZWQoKSxcbiAgICAgICAgICAgICAgICB3ZWJSVEM6ICgwLCAkZmI2M2U3NjZjZmFmYWFiOSRleHBvcnQkMjViZTk1MDI0NzdjMTM3ZCkuaXNXZWJSVENTdXBwb3J0ZWQoKSxcbiAgICAgICAgICAgICAgICBhdWRpb1ZpZGVvOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBkYXRhOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBiaW5hcnlCbG9iOiBmYWxzZSxcbiAgICAgICAgICAgICAgICByZWxpYWJsZTogZmFsc2VcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoIXN1cHBvcnRlZC53ZWJSVEMpIHJldHVybiBzdXBwb3J0ZWQ7XG4gICAgICAgICAgICBsZXQgcGM7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHBjID0gbmV3IFJUQ1BlZXJDb25uZWN0aW9uKCQ0ZjQxMzQxNTZjNDQ2MzkyJHZhciRERUZBVUxUX0NPTkZJRyk7XG4gICAgICAgICAgICAgICAgc3VwcG9ydGVkLmF1ZGlvVmlkZW8gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGxldCBkYztcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBkYyA9IHBjLmNyZWF0ZURhdGFDaGFubmVsKFwiX1BFRVJKU1RFU1RcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3JkZXJlZDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3VwcG9ydGVkLmRhdGEgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBzdXBwb3J0ZWQucmVsaWFibGUgPSAhIWRjLm9yZGVyZWQ7XG4gICAgICAgICAgICAgICAgICAgIC8vIEJpbmFyeSB0ZXN0XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYy5iaW5hcnlUeXBlID0gXCJibG9iXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdXBwb3J0ZWQuYmluYXJ5QmxvYiA9ICEoMCwgJGZiNjNlNzY2Y2ZhZmFhYjkkZXhwb3J0JDI1YmU5NTAyNDc3YzEzN2QpLmlzSU9TO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9IGZpbmFsbHl7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYykgZGMuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7fSBmaW5hbGx5e1xuICAgICAgICAgICAgICAgIGlmIChwYykgcGMuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdXBwb3J0ZWQ7XG4gICAgICAgIH0oKTtcbiAgICAgICAgLy8gRW5zdXJlIGFscGhhbnVtZXJpYyBpZHNcbiAgICAgICAgdGhpcy52YWxpZGF0ZUlkID0gKDAsICQ5YTg0YTMyYmYwYmYzNmJiJGV4cG9ydCRmMzVmMTI4ZmQ1OWVhMjU2KTtcbiAgICAgICAgdGhpcy5yYW5kb21Ub2tlbiA9ICgwLCAkMGU1ZmQxNTg1Nzg0YzI1MiRleHBvcnQkNGU2MWY2NzI5MzZiZWM3Nyk7XG4gICAgfVxufVxuY29uc3QgJDRmNDEzNDE1NmM0NDYzOTIkZXhwb3J0JDdkZWJiNTBlZjExZDVlMGIgPSBuZXcgJDRmNDEzNDE1NmM0NDYzOTIkZXhwb3J0JGY4ZjI2ZGQzOTVkN2UxYmQoKTtcblxuXG5cbmNvbnN0ICQyNTc5NDdlOTI5MjYyNzdhJHZhciRMT0dfUFJFRklYID0gXCJQZWVySlM6IFwiO1xudmFyICQyNTc5NDdlOTI5MjYyNzdhJGV4cG9ydCQyNDNlNjJkNzhkM2I1NDRkO1xuKGZ1bmN0aW9uKExvZ0xldmVsKSB7XG4gICAgLyoqXG5cdCAqIFByaW50cyBubyBsb2dzLlxuXHQgKi8gTG9nTGV2ZWxbTG9nTGV2ZWxbXCJEaXNhYmxlZFwiXSA9IDBdID0gXCJEaXNhYmxlZFwiO1xuICAgIC8qKlxuXHQgKiBQcmludHMgb25seSBlcnJvcnMuXG5cdCAqLyBMb2dMZXZlbFtMb2dMZXZlbFtcIkVycm9yc1wiXSA9IDFdID0gXCJFcnJvcnNcIjtcbiAgICAvKipcblx0ICogUHJpbnRzIGVycm9ycyBhbmQgd2FybmluZ3MuXG5cdCAqLyBMb2dMZXZlbFtMb2dMZXZlbFtcIldhcm5pbmdzXCJdID0gMl0gPSBcIldhcm5pbmdzXCI7XG4gICAgLyoqXG5cdCAqIFByaW50cyBhbGwgbG9ncy5cblx0ICovIExvZ0xldmVsW0xvZ0xldmVsW1wiQWxsXCJdID0gM10gPSBcIkFsbFwiO1xufSkoJDI1Nzk0N2U5MjkyNjI3N2EkZXhwb3J0JDI0M2U2MmQ3OGQzYjU0NGQgfHwgKCQyNTc5NDdlOTI5MjYyNzdhJGV4cG9ydCQyNDNlNjJkNzhkM2I1NDRkID0ge30pKTtcbmNsYXNzICQyNTc5NDdlOTI5MjYyNzdhJHZhciRMb2dnZXIge1xuICAgIGdldCBsb2dMZXZlbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvZ0xldmVsO1xuICAgIH1cbiAgICBzZXQgbG9nTGV2ZWwobG9nTGV2ZWwpIHtcbiAgICAgICAgdGhpcy5fbG9nTGV2ZWwgPSBsb2dMZXZlbDtcbiAgICB9XG4gICAgbG9nKC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKHRoaXMuX2xvZ0xldmVsID49IDMpIHRoaXMuX3ByaW50KDMsIC4uLmFyZ3MpO1xuICAgIH1cbiAgICB3YXJuKC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKHRoaXMuX2xvZ0xldmVsID49IDIpIHRoaXMuX3ByaW50KDIsIC4uLmFyZ3MpO1xuICAgIH1cbiAgICBlcnJvciguLi5hcmdzKSB7XG4gICAgICAgIGlmICh0aGlzLl9sb2dMZXZlbCA+PSAxKSB0aGlzLl9wcmludCgxLCAuLi5hcmdzKTtcbiAgICB9XG4gICAgc2V0TG9nRnVuY3Rpb24oZm4pIHtcbiAgICAgICAgdGhpcy5fcHJpbnQgPSBmbjtcbiAgICB9XG4gICAgX3ByaW50KGxvZ0xldmVsLCAuLi5yZXN0KSB7XG4gICAgICAgIGNvbnN0IGNvcHkgPSBbXG4gICAgICAgICAgICAkMjU3OTQ3ZTkyOTI2Mjc3YSR2YXIkTE9HX1BSRUZJWCxcbiAgICAgICAgICAgIC4uLnJlc3RcbiAgICAgICAgXTtcbiAgICAgICAgZm9yKGNvbnN0IGkgaW4gY29weSlpZiAoY29weVtpXSBpbnN0YW5jZW9mIEVycm9yKSBjb3B5W2ldID0gXCIoXCIgKyBjb3B5W2ldLm5hbWUgKyBcIikgXCIgKyBjb3B5W2ldLm1lc3NhZ2U7XG4gICAgICAgIGlmIChsb2dMZXZlbCA+PSAzKSBjb25zb2xlLmxvZyguLi5jb3B5KTtcbiAgICAgICAgZWxzZSBpZiAobG9nTGV2ZWwgPj0gMikgY29uc29sZS53YXJuKFwiV0FSTklOR1wiLCAuLi5jb3B5KTtcbiAgICAgICAgZWxzZSBpZiAobG9nTGV2ZWwgPj0gMSkgY29uc29sZS5lcnJvcihcIkVSUk9SXCIsIC4uLmNvcHkpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICB0aGlzLl9sb2dMZXZlbCA9IDA7XG4gICAgfVxufVxudmFyICQyNTc5NDdlOTI5MjYyNzdhJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkgPSBuZXcgJDI1Nzk0N2U5MjkyNjI3N2EkdmFyJExvZ2dlcigpO1xuXG5cbnZhciAkYzRkY2ZkMWQxZWE4NjY0NyRleHBvcnRzID0ge307XG5cInVzZSBzdHJpY3RcIjtcbnZhciAkYzRkY2ZkMWQxZWE4NjY0NyR2YXIkaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSwgJGM0ZGNmZDFkMWVhODY2NDckdmFyJHByZWZpeCA9IFwiflwiO1xuLyoqXG4gKiBDb25zdHJ1Y3RvciB0byBjcmVhdGUgYSBzdG9yYWdlIGZvciBvdXIgYEVFYCBvYmplY3RzLlxuICogQW4gYEV2ZW50c2AgaW5zdGFuY2UgaXMgYSBwbGFpbiBvYmplY3Qgd2hvc2UgcHJvcGVydGllcyBhcmUgZXZlbnQgbmFtZXMuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHJpdmF0ZVxuICovIGZ1bmN0aW9uICRjNGRjZmQxZDFlYTg2NjQ3JHZhciRFdmVudHMoKSB7fVxuLy9cbi8vIFdlIHRyeSB0byBub3QgaW5oZXJpdCBmcm9tIGBPYmplY3QucHJvdG90eXBlYC4gSW4gc29tZSBlbmdpbmVzIGNyZWF0aW5nIGFuXG4vLyBpbnN0YW5jZSBpbiB0aGlzIHdheSBpcyBmYXN0ZXIgdGhhbiBjYWxsaW5nIGBPYmplY3QuY3JlYXRlKG51bGwpYCBkaXJlY3RseS5cbi8vIElmIGBPYmplY3QuY3JlYXRlKG51bGwpYCBpcyBub3Qgc3VwcG9ydGVkIHdlIHByZWZpeCB0aGUgZXZlbnQgbmFtZXMgd2l0aCBhXG4vLyBjaGFyYWN0ZXIgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIGJ1aWx0LWluIG9iamVjdCBwcm9wZXJ0aWVzIGFyZSBub3Rcbi8vIG92ZXJyaWRkZW4gb3IgdXNlZCBhcyBhbiBhdHRhY2sgdmVjdG9yLlxuLy9cbmlmIChPYmplY3QuY3JlYXRlKSB7XG4gICAgJGM0ZGNmZDFkMWVhODY2NDckdmFyJEV2ZW50cy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIC8vXG4gICAgLy8gVGhpcyBoYWNrIGlzIG5lZWRlZCBiZWNhdXNlIHRoZSBgX19wcm90b19fYCBwcm9wZXJ0eSBpcyBzdGlsbCBpbmhlcml0ZWQgaW5cbiAgICAvLyBzb21lIG9sZCBicm93c2VycyBsaWtlIEFuZHJvaWQgNCwgaVBob25lIDUuMSwgT3BlcmEgMTEgYW5kIFNhZmFyaSA1LlxuICAgIC8vXG4gICAgaWYgKCFuZXcgJGM0ZGNmZDFkMWVhODY2NDckdmFyJEV2ZW50cygpLl9fcHJvdG9fXykgJGM0ZGNmZDFkMWVhODY2NDckdmFyJHByZWZpeCA9IGZhbHNlO1xufVxuLyoqXG4gKiBSZXByZXNlbnRhdGlvbiBvZiBhIHNpbmdsZSBldmVudCBsaXN0ZW5lci5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHBhcmFtIHtCb29sZWFufSBbb25jZT1mYWxzZV0gU3BlY2lmeSBpZiB0aGUgbGlzdGVuZXIgaXMgYSBvbmUtdGltZSBsaXN0ZW5lci5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHByaXZhdGVcbiAqLyBmdW5jdGlvbiAkYzRkY2ZkMWQxZWE4NjY0NyR2YXIkRUUoZm4sIGNvbnRleHQsIG9uY2UpIHtcbiAgICB0aGlzLmZuID0gZm47XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLm9uY2UgPSBvbmNlIHx8IGZhbHNlO1xufVxuLyoqXG4gKiBBZGQgYSBsaXN0ZW5lciBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50RW1pdHRlcn0gZW1pdHRlciBSZWZlcmVuY2UgdG8gdGhlIGBFdmVudEVtaXR0ZXJgIGluc3RhbmNlLlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb25jZSBTcGVjaWZ5IGlmIHRoZSBsaXN0ZW5lciBpcyBhIG9uZS10aW1lIGxpc3RlbmVyLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn1cbiAqIEBwcml2YXRlXG4gKi8gZnVuY3Rpb24gJGM0ZGNmZDFkMWVhODY2NDckdmFyJGFkZExpc3RlbmVyKGVtaXR0ZXIsIGV2ZW50LCBmbiwgY29udGV4dCwgb25jZSkge1xuICAgIGlmICh0eXBlb2YgZm4gIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoZSBsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG4gICAgdmFyIGxpc3RlbmVyID0gbmV3ICRjNGRjZmQxZDFlYTg2NjQ3JHZhciRFRShmbiwgY29udGV4dCB8fCBlbWl0dGVyLCBvbmNlKSwgZXZ0ID0gJGM0ZGNmZDFkMWVhODY2NDckdmFyJHByZWZpeCA/ICRjNGRjZmQxZDFlYTg2NjQ3JHZhciRwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuICAgIGlmICghZW1pdHRlci5fZXZlbnRzW2V2dF0pIGVtaXR0ZXIuX2V2ZW50c1tldnRdID0gbGlzdGVuZXIsIGVtaXR0ZXIuX2V2ZW50c0NvdW50Kys7XG4gICAgZWxzZSBpZiAoIWVtaXR0ZXIuX2V2ZW50c1tldnRdLmZuKSBlbWl0dGVyLl9ldmVudHNbZXZ0XS5wdXNoKGxpc3RlbmVyKTtcbiAgICBlbHNlIGVtaXR0ZXIuX2V2ZW50c1tldnRdID0gW1xuICAgICAgICBlbWl0dGVyLl9ldmVudHNbZXZ0XSxcbiAgICAgICAgbGlzdGVuZXJcbiAgICBdO1xuICAgIHJldHVybiBlbWl0dGVyO1xufVxuLyoqXG4gKiBDbGVhciBldmVudCBieSBuYW1lLlxuICpcbiAqIEBwYXJhbSB7RXZlbnRFbWl0dGVyfSBlbWl0dGVyIFJlZmVyZW5jZSB0byB0aGUgYEV2ZW50RW1pdHRlcmAgaW5zdGFuY2UuXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZ0IFRoZSBFdmVudCBuYW1lLlxuICogQHByaXZhdGVcbiAqLyBmdW5jdGlvbiAkYzRkY2ZkMWQxZWE4NjY0NyR2YXIkY2xlYXJFdmVudChlbWl0dGVyLCBldnQpIHtcbiAgICBpZiAoLS1lbWl0dGVyLl9ldmVudHNDb3VudCA9PT0gMCkgZW1pdHRlci5fZXZlbnRzID0gbmV3ICRjNGRjZmQxZDFlYTg2NjQ3JHZhciRFdmVudHMoKTtcbiAgICBlbHNlIGRlbGV0ZSBlbWl0dGVyLl9ldmVudHNbZXZ0XTtcbn1cbi8qKlxuICogTWluaW1hbCBgRXZlbnRFbWl0dGVyYCBpbnRlcmZhY2UgdGhhdCBpcyBtb2xkZWQgYWdhaW5zdCB0aGUgTm9kZS5qc1xuICogYEV2ZW50RW1pdHRlcmAgaW50ZXJmYWNlLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHB1YmxpY1xuICovIGZ1bmN0aW9uICRjNGRjZmQxZDFlYTg2NjQ3JHZhciRFdmVudEVtaXR0ZXIoKSB7XG4gICAgdGhpcy5fZXZlbnRzID0gbmV3ICRjNGRjZmQxZDFlYTg2NjQ3JHZhciRFdmVudHMoKTtcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG59XG4vKipcbiAqIFJldHVybiBhbiBhcnJheSBsaXN0aW5nIHRoZSBldmVudHMgZm9yIHdoaWNoIHRoZSBlbWl0dGVyIGhhcyByZWdpc3RlcmVkXG4gKiBsaXN0ZW5lcnMuXG4gKlxuICogQHJldHVybnMge0FycmF5fVxuICogQHB1YmxpY1xuICovICRjNGRjZmQxZDFlYTg2NjQ3JHZhciRFdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50TmFtZXMgPSBmdW5jdGlvbiBldmVudE5hbWVzKCkge1xuICAgIHZhciBuYW1lcyA9IFtdLCBldmVudHMsIG5hbWU7XG4gICAgaWYgKHRoaXMuX2V2ZW50c0NvdW50ID09PSAwKSByZXR1cm4gbmFtZXM7XG4gICAgZm9yKG5hbWUgaW4gZXZlbnRzID0gdGhpcy5fZXZlbnRzKWlmICgkYzRkY2ZkMWQxZWE4NjY0NyR2YXIkaGFzLmNhbGwoZXZlbnRzLCBuYW1lKSkgbmFtZXMucHVzaCgkYzRkY2ZkMWQxZWE4NjY0NyR2YXIkcHJlZml4ID8gbmFtZS5zbGljZSgxKSA6IG5hbWUpO1xuICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSByZXR1cm4gbmFtZXMuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZXZlbnRzKSk7XG4gICAgcmV0dXJuIG5hbWVzO1xufTtcbi8qKlxuICogUmV0dXJuIHRoZSBsaXN0ZW5lcnMgcmVnaXN0ZXJlZCBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFRoZSByZWdpc3RlcmVkIGxpc3RlbmVycy5cbiAqIEBwdWJsaWNcbiAqLyAkYzRkY2ZkMWQxZWE4NjY0NyR2YXIkRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnMoZXZlbnQpIHtcbiAgICB2YXIgZXZ0ID0gJGM0ZGNmZDFkMWVhODY2NDckdmFyJHByZWZpeCA/ICRjNGRjZmQxZDFlYTg2NjQ3JHZhciRwcmVmaXggKyBldmVudCA6IGV2ZW50LCBoYW5kbGVycyA9IHRoaXMuX2V2ZW50c1tldnRdO1xuICAgIGlmICghaGFuZGxlcnMpIHJldHVybiBbXTtcbiAgICBpZiAoaGFuZGxlcnMuZm4pIHJldHVybiBbXG4gICAgICAgIGhhbmRsZXJzLmZuXG4gICAgXTtcbiAgICBmb3IodmFyIGkgPSAwLCBsID0gaGFuZGxlcnMubGVuZ3RoLCBlZSA9IG5ldyBBcnJheShsKTsgaSA8IGw7IGkrKyllZVtpXSA9IGhhbmRsZXJzW2ldLmZuO1xuICAgIHJldHVybiBlZTtcbn07XG4vKipcbiAqIFJldHVybiB0aGUgbnVtYmVyIG9mIGxpc3RlbmVycyBsaXN0ZW5pbmcgdG8gYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtYmVyIG9mIGxpc3RlbmVycy5cbiAqIEBwdWJsaWNcbiAqLyAkYzRkY2ZkMWQxZWE4NjY0NyR2YXIkRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24gbGlzdGVuZXJDb3VudChldmVudCkge1xuICAgIHZhciBldnQgPSAkYzRkY2ZkMWQxZWE4NjY0NyR2YXIkcHJlZml4ID8gJGM0ZGNmZDFkMWVhODY2NDckdmFyJHByZWZpeCArIGV2ZW50IDogZXZlbnQsIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldnRdO1xuICAgIGlmICghbGlzdGVuZXJzKSByZXR1cm4gMDtcbiAgICBpZiAobGlzdGVuZXJzLmZuKSByZXR1cm4gMTtcbiAgICByZXR1cm4gbGlzdGVuZXJzLmxlbmd0aDtcbn07XG4vKipcbiAqIENhbGxzIGVhY2ggb2YgdGhlIGxpc3RlbmVycyByZWdpc3RlcmVkIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIGV2ZW50IGhhZCBsaXN0ZW5lcnMsIGVsc2UgYGZhbHNlYC5cbiAqIEBwdWJsaWNcbiAqLyAkYzRkY2ZkMWQxZWE4NjY0NyR2YXIkRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdChldmVudCwgYTEsIGEyLCBhMywgYTQsIGE1KSB7XG4gICAgdmFyIGV2dCA9ICRjNGRjZmQxZDFlYTg2NjQ3JHZhciRwcmVmaXggPyAkYzRkY2ZkMWQxZWE4NjY0NyR2YXIkcHJlZml4ICsgZXZlbnQgOiBldmVudDtcbiAgICBpZiAoIXRoaXMuX2V2ZW50c1tldnRdKSByZXR1cm4gZmFsc2U7XG4gICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldnRdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzLCBpO1xuICAgIGlmIChsaXN0ZW5lcnMuZm4pIHtcbiAgICAgICAgaWYgKGxpc3RlbmVycy5vbmNlKSB0aGlzLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcnMuZm4sIHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgICAgIHN3aXRjaChsZW4pe1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCksIHRydWU7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSksIHRydWU7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIpLCB0cnVlO1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMyksIHRydWU7XG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIsIGEzLCBhNCksIHRydWU7XG4gICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIsIGEzLCBhNCwgYTUpLCB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGZvcihpID0gMSwgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTsgaSA8IGxlbjsgaSsrKWFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICBsaXN0ZW5lcnMuZm4uYXBwbHkobGlzdGVuZXJzLmNvbnRleHQsIGFyZ3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBsaXN0ZW5lcnMubGVuZ3RoLCBqO1xuICAgICAgICBmb3IoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICBpZiAobGlzdGVuZXJzW2ldLm9uY2UpIHRoaXMucmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyc1tpXS5mbiwgdW5kZWZpbmVkLCB0cnVlKTtcbiAgICAgICAgICAgIHN3aXRjaChsZW4pe1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhMSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExLCBhMik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExLCBhMiwgYTMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoIWFyZ3MpIGZvcihqID0gMSwgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTsgaiA8IGxlbjsgaisrKWFyZ3NbaiAtIDFdID0gYXJndW1lbnRzW2pdO1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnNbaV0uZm4uYXBwbHkobGlzdGVuZXJzW2ldLmNvbnRleHQsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuICogQWRkIGEgbGlzdGVuZXIgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBbY29udGV4dD10aGlzXSBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAcHVibGljXG4gKi8gJGM0ZGNmZDFkMWVhODY2NDckdmFyJEV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBmdW5jdGlvbiBvbihldmVudCwgZm4sIGNvbnRleHQpIHtcbiAgICByZXR1cm4gJGM0ZGNmZDFkMWVhODY2NDckdmFyJGFkZExpc3RlbmVyKHRoaXMsIGV2ZW50LCBmbiwgY29udGV4dCwgZmFsc2UpO1xufTtcbi8qKlxuICogQWRkIGEgb25lLXRpbWUgbGlzdGVuZXIgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBbY29udGV4dD10aGlzXSBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAcHVibGljXG4gKi8gJGM0ZGNmZDFkMWVhODY2NDckdmFyJEV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UoZXZlbnQsIGZuLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuICRjNGRjZmQxZDFlYTg2NjQ3JHZhciRhZGRMaXN0ZW5lcih0aGlzLCBldmVudCwgZm4sIGNvbnRleHQsIHRydWUpO1xufTtcbi8qKlxuICogUmVtb3ZlIHRoZSBsaXN0ZW5lcnMgb2YgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBPbmx5IHJlbW92ZSB0aGUgbGlzdGVuZXJzIHRoYXQgbWF0Y2ggdGhpcyBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBPbmx5IHJlbW92ZSB0aGUgbGlzdGVuZXJzIHRoYXQgaGF2ZSB0aGlzIGNvbnRleHQuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9uY2UgT25seSByZW1vdmUgb25lLXRpbWUgbGlzdGVuZXJzLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQHB1YmxpY1xuICovICRjNGRjZmQxZDFlYTg2NjQ3JHZhciRFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGZuLCBjb250ZXh0LCBvbmNlKSB7XG4gICAgdmFyIGV2dCA9ICRjNGRjZmQxZDFlYTg2NjQ3JHZhciRwcmVmaXggPyAkYzRkY2ZkMWQxZWE4NjY0NyR2YXIkcHJlZml4ICsgZXZlbnQgOiBldmVudDtcbiAgICBpZiAoIXRoaXMuX2V2ZW50c1tldnRdKSByZXR1cm4gdGhpcztcbiAgICBpZiAoIWZuKSB7XG4gICAgICAgICRjNGRjZmQxZDFlYTg2NjQ3JHZhciRjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW2V2dF07XG4gICAgaWYgKGxpc3RlbmVycy5mbikge1xuICAgICAgICBpZiAobGlzdGVuZXJzLmZuID09PSBmbiAmJiAoIW9uY2UgfHwgbGlzdGVuZXJzLm9uY2UpICYmICghY29udGV4dCB8fCBsaXN0ZW5lcnMuY29udGV4dCA9PT0gY29udGV4dCkpICRjNGRjZmQxZDFlYTg2NjQ3JHZhciRjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yKHZhciBpID0gMCwgZXZlbnRzID0gW10sIGxlbmd0aCA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKylpZiAobGlzdGVuZXJzW2ldLmZuICE9PSBmbiB8fCBvbmNlICYmICFsaXN0ZW5lcnNbaV0ub25jZSB8fCBjb250ZXh0ICYmIGxpc3RlbmVyc1tpXS5jb250ZXh0ICE9PSBjb250ZXh0KSBldmVudHMucHVzaChsaXN0ZW5lcnNbaV0pO1xuICAgICAgICAvL1xuICAgICAgICAvLyBSZXNldCB0aGUgYXJyYXksIG9yIHJlbW92ZSBpdCBjb21wbGV0ZWx5IGlmIHdlIGhhdmUgbm8gbW9yZSBsaXN0ZW5lcnMuXG4gICAgICAgIC8vXG4gICAgICAgIGlmIChldmVudHMubGVuZ3RoKSB0aGlzLl9ldmVudHNbZXZ0XSA9IGV2ZW50cy5sZW5ndGggPT09IDEgPyBldmVudHNbMF0gOiBldmVudHM7XG4gICAgICAgIGVsc2UgJGM0ZGNmZDFkMWVhODY2NDckdmFyJGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuLyoqXG4gKiBSZW1vdmUgYWxsIGxpc3RlbmVycywgb3IgdGhvc2Ugb2YgdGhlIHNwZWNpZmllZCBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gW2V2ZW50XSBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBwdWJsaWNcbiAqLyAkYzRkY2ZkMWQxZWE4NjY0NyR2YXIkRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnQpIHtcbiAgICB2YXIgZXZ0O1xuICAgIGlmIChldmVudCkge1xuICAgICAgICBldnQgPSAkYzRkY2ZkMWQxZWE4NjY0NyR2YXIkcHJlZml4ID8gJGM0ZGNmZDFkMWVhODY2NDckdmFyJHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG4gICAgICAgIGlmICh0aGlzLl9ldmVudHNbZXZ0XSkgJGM0ZGNmZDFkMWVhODY2NDckdmFyJGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9ldmVudHMgPSBuZXcgJGM0ZGNmZDFkMWVhODY2NDckdmFyJEV2ZW50cygpO1xuICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcbi8vXG4vLyBBbGlhcyBtZXRob2RzIG5hbWVzIGJlY2F1c2UgcGVvcGxlIHJvbGwgbGlrZSB0aGF0LlxuLy9cbiRjNGRjZmQxZDFlYTg2NjQ3JHZhciRFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9ICRjNGRjZmQxZDFlYTg2NjQ3JHZhciRFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyO1xuJGM0ZGNmZDFkMWVhODY2NDckdmFyJEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSAkYzRkY2ZkMWQxZWE4NjY0NyR2YXIkRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbjtcbi8vXG4vLyBFeHBvc2UgdGhlIHByZWZpeC5cbi8vXG4kYzRkY2ZkMWQxZWE4NjY0NyR2YXIkRXZlbnRFbWl0dGVyLnByZWZpeGVkID0gJGM0ZGNmZDFkMWVhODY2NDckdmFyJHByZWZpeDtcbi8vXG4vLyBBbGxvdyBgRXZlbnRFbWl0dGVyYCB0byBiZSBpbXBvcnRlZCBhcyBtb2R1bGUgbmFtZXNwYWNlLlxuLy9cbiRjNGRjZmQxZDFlYTg2NjQ3JHZhciRFdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gJGM0ZGNmZDFkMWVhODY2NDckdmFyJEV2ZW50RW1pdHRlcjtcbiRjNGRjZmQxZDFlYTg2NjQ3JGV4cG9ydHMgPSAkYzRkY2ZkMWQxZWE4NjY0NyR2YXIkRXZlbnRFbWl0dGVyO1xuXG5cblxudmFyICQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydHMgPSB7fTtcblxuJHBhcmNlbCRleHBvcnQoJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0cywgXCJDb25uZWN0aW9uVHlwZVwiLCAoKSA9PiAkNzg0NTVlMjJkZWE5NmI4YyRleHBvcnQkMzE1N2Q1N2I0MTM1ZTNiYyk7XG4kcGFyY2VsJGV4cG9ydCgkNzg0NTVlMjJkZWE5NmI4YyRleHBvcnRzLCBcIlBlZXJFcnJvclR5cGVcIiwgKCkgPT4gJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JDk1NDdhYWEyZTM5MDMwZmYpO1xuJHBhcmNlbCRleHBvcnQoJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0cywgXCJCYXNlQ29ubmVjdGlvbkVycm9yVHlwZVwiLCAoKSA9PiAkNzg0NTVlMjJkZWE5NmI4YyRleHBvcnQkNzk3NDkzNTY4NjE0OTY4Nik7XG4kcGFyY2VsJGV4cG9ydCgkNzg0NTVlMjJkZWE5NmI4YyRleHBvcnRzLCBcIkRhdGFDb25uZWN0aW9uRXJyb3JUeXBlXCIsICgpID0+ICQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydCQ0OWFlODAwYzExNGRmNDFkKTtcbiRwYXJjZWwkZXhwb3J0KCQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydHMsIFwiU2VyaWFsaXphdGlvblR5cGVcIiwgKCkgPT4gJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JDg5ZjUwN2NmOTg2YTk0Nyk7XG4kcGFyY2VsJGV4cG9ydCgkNzg0NTVlMjJkZWE5NmI4YyRleHBvcnRzLCBcIlNvY2tldEV2ZW50VHlwZVwiLCAoKSA9PiAkNzg0NTVlMjJkZWE5NmI4YyRleHBvcnQkM2I1YzRhNGI2MzU0ZjAyMyk7XG4kcGFyY2VsJGV4cG9ydCgkNzg0NTVlMjJkZWE5NmI4YyRleHBvcnRzLCBcIlNlcnZlck1lc3NhZ2VUeXBlXCIsICgpID0+ICQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydCRhZGI0YTE3NTRkYTZmMTBkKTtcbnZhciAkNzg0NTVlMjJkZWE5NmI4YyRleHBvcnQkMzE1N2Q1N2I0MTM1ZTNiYztcbihmdW5jdGlvbihDb25uZWN0aW9uVHlwZSkge1xuICAgIENvbm5lY3Rpb25UeXBlW1wiRGF0YVwiXSA9IFwiZGF0YVwiO1xuICAgIENvbm5lY3Rpb25UeXBlW1wiTWVkaWFcIl0gPSBcIm1lZGlhXCI7XG59KSgkNzg0NTVlMjJkZWE5NmI4YyRleHBvcnQkMzE1N2Q1N2I0MTM1ZTNiYyB8fCAoJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JDMxNTdkNTdiNDEzNWUzYmMgPSB7fSkpO1xudmFyICQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydCQ5NTQ3YWFhMmUzOTAzMGZmO1xuKGZ1bmN0aW9uKFBlZXJFcnJvclR5cGUpIHtcbiAgICAvKipcblx0ICogVGhlIGNsaWVudCdzIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBzb21lIG9yIGFsbCBXZWJSVEMgZmVhdHVyZXMgdGhhdCB5b3UgYXJlIHRyeWluZyB0byB1c2UuXG5cdCAqLyBQZWVyRXJyb3JUeXBlW1wiQnJvd3NlckluY29tcGF0aWJsZVwiXSA9IFwiYnJvd3Nlci1pbmNvbXBhdGlibGVcIjtcbiAgICAvKipcblx0ICogWW91J3ZlIGFscmVhZHkgZGlzY29ubmVjdGVkIHRoaXMgcGVlciBmcm9tIHRoZSBzZXJ2ZXIgYW5kIGNhbiBubyBsb25nZXIgbWFrZSBhbnkgbmV3IGNvbm5lY3Rpb25zIG9uIGl0LlxuXHQgKi8gUGVlckVycm9yVHlwZVtcIkRpc2Nvbm5lY3RlZFwiXSA9IFwiZGlzY29ubmVjdGVkXCI7XG4gICAgLyoqXG5cdCAqIFRoZSBJRCBwYXNzZWQgaW50byB0aGUgUGVlciBjb25zdHJ1Y3RvciBjb250YWlucyBpbGxlZ2FsIGNoYXJhY3RlcnMuXG5cdCAqLyBQZWVyRXJyb3JUeXBlW1wiSW52YWxpZElEXCJdID0gXCJpbnZhbGlkLWlkXCI7XG4gICAgLyoqXG5cdCAqIFRoZSBBUEkga2V5IHBhc3NlZCBpbnRvIHRoZSBQZWVyIGNvbnN0cnVjdG9yIGNvbnRhaW5zIGlsbGVnYWwgY2hhcmFjdGVycyBvciBpcyBub3QgaW4gdGhlIHN5c3RlbSAoY2xvdWQgc2VydmVyIG9ubHkpLlxuXHQgKi8gUGVlckVycm9yVHlwZVtcIkludmFsaWRLZXlcIl0gPSBcImludmFsaWQta2V5XCI7XG4gICAgLyoqXG5cdCAqIExvc3Qgb3IgY2Fubm90IGVzdGFibGlzaCBhIGNvbm5lY3Rpb24gdG8gdGhlIHNpZ25hbGxpbmcgc2VydmVyLlxuXHQgKi8gUGVlckVycm9yVHlwZVtcIk5ldHdvcmtcIl0gPSBcIm5ldHdvcmtcIjtcbiAgICAvKipcblx0ICogVGhlIHBlZXIgeW91J3JlIHRyeWluZyB0byBjb25uZWN0IHRvIGRvZXMgbm90IGV4aXN0LlxuXHQgKi8gUGVlckVycm9yVHlwZVtcIlBlZXJVbmF2YWlsYWJsZVwiXSA9IFwicGVlci11bmF2YWlsYWJsZVwiO1xuICAgIC8qKlxuXHQgKiBQZWVySlMgaXMgYmVpbmcgdXNlZCBzZWN1cmVseSwgYnV0IHRoZSBjbG91ZCBzZXJ2ZXIgZG9lcyBub3Qgc3VwcG9ydCBTU0wuIFVzZSBhIGN1c3RvbSBQZWVyU2VydmVyLlxuXHQgKi8gUGVlckVycm9yVHlwZVtcIlNzbFVuYXZhaWxhYmxlXCJdID0gXCJzc2wtdW5hdmFpbGFibGVcIjtcbiAgICAvKipcblx0ICogVW5hYmxlIHRvIHJlYWNoIHRoZSBzZXJ2ZXIuXG5cdCAqLyBQZWVyRXJyb3JUeXBlW1wiU2VydmVyRXJyb3JcIl0gPSBcInNlcnZlci1lcnJvclwiO1xuICAgIC8qKlxuXHQgKiBBbiBlcnJvciBmcm9tIHRoZSB1bmRlcmx5aW5nIHNvY2tldC5cblx0ICovIFBlZXJFcnJvclR5cGVbXCJTb2NrZXRFcnJvclwiXSA9IFwic29ja2V0LWVycm9yXCI7XG4gICAgLyoqXG5cdCAqIFRoZSB1bmRlcmx5aW5nIHNvY2tldCBjbG9zZWQgdW5leHBlY3RlZGx5LlxuXHQgKi8gUGVlckVycm9yVHlwZVtcIlNvY2tldENsb3NlZFwiXSA9IFwic29ja2V0LWNsb3NlZFwiO1xuICAgIC8qKlxuXHQgKiBUaGUgSUQgcGFzc2VkIGludG8gdGhlIFBlZXIgY29uc3RydWN0b3IgaXMgYWxyZWFkeSB0YWtlbi5cblx0ICpcblx0ICogOjo6Y2F1dGlvblxuXHQgKiBUaGlzIGVycm9yIGlzIG5vdCBmYXRhbCBpZiB5b3VyIHBlZXIgaGFzIG9wZW4gcGVlci10by1wZWVyIGNvbm5lY3Rpb25zLlxuXHQgKiBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IGF0dGVtcHQgdG8ge0BhcGlsaW5rIFBlZXIucmVjb25uZWN0fSBhIHBlZXIgdGhhdCBoYXMgYmVlbiBkaXNjb25uZWN0ZWQgZnJvbSB0aGUgc2VydmVyLFxuXHQgKiBidXQgaXRzIG9sZCBJRCBoYXMgbm93IGJlZW4gdGFrZW4uXG5cdCAqIDo6OlxuXHQgKi8gUGVlckVycm9yVHlwZVtcIlVuYXZhaWxhYmxlSURcIl0gPSBcInVuYXZhaWxhYmxlLWlkXCI7XG4gICAgLyoqXG5cdCAqIE5hdGl2ZSBXZWJSVEMgZXJyb3JzLlxuXHQgKi8gUGVlckVycm9yVHlwZVtcIldlYlJUQ1wiXSA9IFwid2VicnRjXCI7XG59KSgkNzg0NTVlMjJkZWE5NmI4YyRleHBvcnQkOTU0N2FhYTJlMzkwMzBmZiB8fCAoJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JDk1NDdhYWEyZTM5MDMwZmYgPSB7fSkpO1xudmFyICQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydCQ3OTc0OTM1Njg2MTQ5Njg2O1xuKGZ1bmN0aW9uKEJhc2VDb25uZWN0aW9uRXJyb3JUeXBlKSB7XG4gICAgQmFzZUNvbm5lY3Rpb25FcnJvclR5cGVbXCJOZWdvdGlhdGlvbkZhaWxlZFwiXSA9IFwibmVnb3RpYXRpb24tZmFpbGVkXCI7XG4gICAgQmFzZUNvbm5lY3Rpb25FcnJvclR5cGVbXCJDb25uZWN0aW9uQ2xvc2VkXCJdID0gXCJjb25uZWN0aW9uLWNsb3NlZFwiO1xufSkoJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JDc5NzQ5MzU2ODYxNDk2ODYgfHwgKCQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydCQ3OTc0OTM1Njg2MTQ5Njg2ID0ge30pKTtcbnZhciAkNzg0NTVlMjJkZWE5NmI4YyRleHBvcnQkNDlhZTgwMGMxMTRkZjQxZDtcbihmdW5jdGlvbihEYXRhQ29ubmVjdGlvbkVycm9yVHlwZSkge1xuICAgIERhdGFDb25uZWN0aW9uRXJyb3JUeXBlW1wiTm90T3BlbllldFwiXSA9IFwibm90LW9wZW4teWV0XCI7XG4gICAgRGF0YUNvbm5lY3Rpb25FcnJvclR5cGVbXCJNZXNzYWdlVG9CaWdcIl0gPSBcIm1lc3NhZ2UtdG9vLWJpZ1wiO1xufSkoJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JDQ5YWU4MDBjMTE0ZGY0MWQgfHwgKCQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydCQ0OWFlODAwYzExNGRmNDFkID0ge30pKTtcbnZhciAkNzg0NTVlMjJkZWE5NmI4YyRleHBvcnQkODlmNTA3Y2Y5ODZhOTQ3O1xuKGZ1bmN0aW9uKFNlcmlhbGl6YXRpb25UeXBlKSB7XG4gICAgU2VyaWFsaXphdGlvblR5cGVbXCJCaW5hcnlcIl0gPSBcImJpbmFyeVwiO1xuICAgIFNlcmlhbGl6YXRpb25UeXBlW1wiQmluYXJ5VVRGOFwiXSA9IFwiYmluYXJ5LXV0ZjhcIjtcbiAgICBTZXJpYWxpemF0aW9uVHlwZVtcIkpTT05cIl0gPSBcImpzb25cIjtcbiAgICBTZXJpYWxpemF0aW9uVHlwZVtcIk5vbmVcIl0gPSBcInJhd1wiO1xufSkoJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JDg5ZjUwN2NmOTg2YTk0NyB8fCAoJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JDg5ZjUwN2NmOTg2YTk0NyA9IHt9KSk7XG52YXIgJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JDNiNWM0YTRiNjM1NGYwMjM7XG4oZnVuY3Rpb24oU29ja2V0RXZlbnRUeXBlKSB7XG4gICAgU29ja2V0RXZlbnRUeXBlW1wiTWVzc2FnZVwiXSA9IFwibWVzc2FnZVwiO1xuICAgIFNvY2tldEV2ZW50VHlwZVtcIkRpc2Nvbm5lY3RlZFwiXSA9IFwiZGlzY29ubmVjdGVkXCI7XG4gICAgU29ja2V0RXZlbnRUeXBlW1wiRXJyb3JcIl0gPSBcImVycm9yXCI7XG4gICAgU29ja2V0RXZlbnRUeXBlW1wiQ2xvc2VcIl0gPSBcImNsb3NlXCI7XG59KSgkNzg0NTVlMjJkZWE5NmI4YyRleHBvcnQkM2I1YzRhNGI2MzU0ZjAyMyB8fCAoJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JDNiNWM0YTRiNjM1NGYwMjMgPSB7fSkpO1xudmFyICQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydCRhZGI0YTE3NTRkYTZmMTBkO1xuKGZ1bmN0aW9uKFNlcnZlck1lc3NhZ2VUeXBlKSB7XG4gICAgU2VydmVyTWVzc2FnZVR5cGVbXCJIZWFydGJlYXRcIl0gPSBcIkhFQVJUQkVBVFwiO1xuICAgIFNlcnZlck1lc3NhZ2VUeXBlW1wiQ2FuZGlkYXRlXCJdID0gXCJDQU5ESURBVEVcIjtcbiAgICBTZXJ2ZXJNZXNzYWdlVHlwZVtcIk9mZmVyXCJdID0gXCJPRkZFUlwiO1xuICAgIFNlcnZlck1lc3NhZ2VUeXBlW1wiQW5zd2VyXCJdID0gXCJBTlNXRVJcIjtcbiAgICBTZXJ2ZXJNZXNzYWdlVHlwZVtcIk9wZW5cIl0gPSBcIk9QRU5cIjtcbiAgICBTZXJ2ZXJNZXNzYWdlVHlwZVtcIkVycm9yXCJdID0gXCJFUlJPUlwiO1xuICAgIFNlcnZlck1lc3NhZ2VUeXBlW1wiSWRUYWtlblwiXSA9IFwiSUQtVEFLRU5cIjtcbiAgICBTZXJ2ZXJNZXNzYWdlVHlwZVtcIkludmFsaWRLZXlcIl0gPSBcIklOVkFMSUQtS0VZXCI7XG4gICAgU2VydmVyTWVzc2FnZVR5cGVbXCJMZWF2ZVwiXSA9IFwiTEVBVkVcIjtcbiAgICBTZXJ2ZXJNZXNzYWdlVHlwZVtcIkV4cGlyZVwiXSA9IFwiRVhQSVJFXCI7XG59KSgkNzg0NTVlMjJkZWE5NmI4YyRleHBvcnQkYWRiNGExNzU0ZGE2ZjEwZCB8fCAoJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JGFkYjRhMTc1NGRhNmYxMGQgPSB7fSkpO1xuXG5cbnZhciAkZjVmODgxZWM0NTc1ZjFmYyRleHBvcnRzID0ge307XG4kZjVmODgxZWM0NTc1ZjFmYyRleHBvcnRzID0gSlNPTi5wYXJzZSgne1wibmFtZVwiOlwicGVlcmpzXCIsXCJ2ZXJzaW9uXCI6XCIxLjUuNFwiLFwia2V5d29yZHNcIjpbXCJwZWVyanNcIixcIndlYnJ0Y1wiLFwicDJwXCIsXCJydGNcIl0sXCJkZXNjcmlwdGlvblwiOlwiUGVlckpTIGNsaWVudFwiLFwiaG9tZXBhZ2VcIjpcImh0dHBzOi8vcGVlcmpzLmNvbVwiLFwiYnVnc1wiOntcInVybFwiOlwiaHR0cHM6Ly9naXRodWIuY29tL3BlZXJzL3BlZXJqcy9pc3N1ZXNcIn0sXCJyZXBvc2l0b3J5XCI6e1widHlwZVwiOlwiZ2l0XCIsXCJ1cmxcIjpcImh0dHBzOi8vZ2l0aHViLmNvbS9wZWVycy9wZWVyanNcIn0sXCJsaWNlbnNlXCI6XCJNSVRcIixcImNvbnRyaWJ1dG9yc1wiOltcIk1pY2hlbGxlIEJ1IDxtaWNoZWxsZUBtaWNoZWxsZWJ1LmNvbT5cIixcImFmcm9raWNrIDxkZXZieXJ1QGdtYWlsLmNvbT5cIixcImVyaWN6IDxyZWFsbHkuZXpAZ21haWwuY29tPlwiLFwiSmFpcm8gPGtpZGFuZGNhdEBnbWFpbC5jb20+XCIsXCJKb25hcyBHbG9uaW5nIDwzNDE5NDM3MCtqb25hc2dsb25pbmdAdXNlcnMubm9yZXBseS5naXRodWIuY29tPlwiLFwiSmFpcm8gQ2Fyby1BY2Npbm8gVmljaWFuYSA8amFpcm9AZ2FsYXguYmU+XCIsXCJDYXJsb3MgQ2FiYWxsZXJvIDxjYXJsb3MuY2FiYWxsZXJvLmdvbnphbGV6QGdtYWlsLmNvbT5cIixcImhjIDxoaGVlbm5ycnl5QGdtYWlsLmNvbT5cIixcIk11aGFtbWFkIEFzaWYgPGNhcHJpcGlvQGdtYWlsLmNvbT5cIixcIlByYXNob29uQiA8cHJhc2hvb25iaGF0dGFjaGFyamVlQGdtYWlsLmNvbT5cIixcIkhhcnNoIEJhcmRoYW4gTWlzaHJhIDw0NzM1MTAyNStIYXJzaENhc3BlckB1c2Vycy5ub3JlcGx5LmdpdGh1Yi5jb20+XCIsXCJha290eW5za2kgPGFsZWtzYW5kZXJrb3RidXJ5QGdtYWlsLmNvbT5cIixcImxtYiA8aUBsbWIuaW8+XCIsXCJKYWlyb29vIDxqYWlyb2Nhcm9AbXNuLmNvbT5cIixcIk1vcml0eiBTdFxceGZjY2tsZXIgPG1vcml0ei5zdHVlY2tsZXJAZ21haWwuY29tPlwiLFwiU2ltb24gPGNyeWRvdHNuYWtlZ2l0aHViQGdtYWlsLmNvbT5cIixcIkRlbmlzIEx1a292IDxkZW5pc21hc3N0ZXJzQGdtYWlsLmNvbT5cIixcIlBoaWxpcHAgSGFuY2tlIDxmaXBwb0BhbmR5ZXQubmV0PlwiLFwiSGFucyBPa3NlbmRhaGwgPGhhbnNva3NlbmRhaGxAZ21haWwuY29tPlwiLFwiSmVzcyA8amVzc2FjaGFuZGxlckBnbWFpbC5jb20+XCIsXCJraGFua3VhbiA8a2hhbmt1YW5AZ21haWwuY29tPlwiLFwiRFVPRFZLIDxrdXJtYW5vdi53b3JrQGdtYWlsLmNvbT5cIixcIlhpWmhhbyA8a3dhbmcxaW1zYUBnbWFpbC5jb20+XCIsXCJNYXR0aGlhcyBMb2hyIDxtYXR0aGlhc0Bsb2hyLm1lPlwiLFwiPWZyYW5rIHRyZWUgPD1mcm5rdHJiQGdvb2dsZW1haWwuY29tPlwiLFwiQW5kcmUgRWNrYXJkdCA8YWVja2FyZHRAb3V0bG9vay5jb20+XCIsXCJDaHJpcyBDb3dhbiA8YWdlbnRtZTQ5QGdtYWlsLmNvbT5cIixcIkFsZXggQ2h1ZXYgPGFsZXhAY2h1ZXYuY29tPlwiLFwiYWx4bnVsbCA8YWx4bnVsbEBlLm1haWwuZGU+XCIsXCJZZW1lbCBKYXJkaSA8YW5nZWwuamFyZGlAZ21haWwuY29tPlwiLFwiQmVuIFBhcm5lbGwgPGJlbmphbWlucGFybmVsbC45NEBnbWFpbC5jb20+XCIsXCJCZW5ueSBMaWNodG5lciA8YmVubmxpY2hAZ21haWwuY29tPlwiLFwiZnJlc2hlbmVlc3ogPGJpdGV0cnVkcHVibGljQGdtYWlsLmNvbT5cIixcImJvYi5iYXJzdGVhZEBleGFwdGl2ZS5jb20gPGJvYi5iYXJzdGVhZEBleGFwdGl2ZS5jb20+XCIsXCJjaGFuZGlrYSA8Y2hhbmRpa2FAZ21haWwuY29tPlwiLFwiZW1lcnNpb24gPGNvbnRhY3RAZW1lcnNpb24uZnI+XCIsXCJDaHJpc3RvcGhlciBWYW4gPGN2YW5AdXNlcnMubm9yZXBseS5naXRodWIuY29tPlwiLFwiZWRkaWVoZXJtIDxlZGhlcm1vc29AZ21haWwuY29tPlwiLFwiRWR1YXJkbyBQaW5obyA8ZW5ldDRtaWtlZW5ldEBnbWFpbC5jb20+XCIsXCJFdmFuZHJvIFphbmF0dGEgPGV6YW5hdHRhQHRyYXkubmV0LmJyPlwiLFwiR2FyZG5lciBCaWNrZm9yZCA8Z2FyZG5lckB1c2Vycy5ub3JlcGx5LmdpdGh1Yi5jb20+XCIsXCJHaWFuIEx1Y2EgPGdpYW5sdWNhLmNlY2NoaUBjeW5ueS5jb20+XCIsXCJQYXRyaWNrSlMgPGdpdGh1YkBnZGkyMjkwLmNvbT5cIixcImpvbm55ZiA8Z2l0aHViQGpvbmF0aGFuZm9zcy5jby51az5cIixcIkhpemtpYSBGZWxpeCA8aGl6a2lmd0BnbWFpbC5jb20+XCIsXCJIcmlzdG8gT3Nrb3YgPGhyaXN0by5vc2tvdkBnbWFpbC5jb20+XCIsXCJJc2FhYyBNYWR3ZWQgPGkubWFkd2VkQGdtYWlsLmNvbT5cIixcIklseWEgS29uYW55a2hpbiA8aWx5YS5rb25hbnlraGluQGdtYWlsLmNvbT5cIixcImphc29uYmFycnkgPGphc2JhcnJ5QG1lLmNvbT5cIixcIkpvbmF0aGFuIEJ1cmtlIDxqb25hdGhhbi5idXJrZS4xMzExQGdvb2dsZW1haWwuY29tPlwiLFwiSm9zaCBIYW1pdCA8am9zaC5oYW1pdEBnbWFpbC5jb20+XCIsXCJKb3JkYW4gQXVzdGluIDxqcmF4ODZAZ21haWwuY29tPlwiLFwiSm9lbCBXZXR6ZWxsIDxqd2V0emVsbEB5YWhvby5jb20+XCIsXCJ4aXpoYW8gPGtldmluLndhbmdAY2xvdWRlcmEuY29tPlwiLFwiQWxiZXJ0byBUb3JyZXMgPGt1bmdmb29iYXJAZ21haWwuY29tPlwiLFwiSm9uYXRoYW4gTWF5b2wgPG1heW9sam9uYXRoYW5AZ21haWwuY29tPlwiLFwiSmVmZmVyc29uIEZlbGl4IDxtZUBqc2ZlbGl4LmRldj5cIixcIlJvbGYgRXJpayBMZWthbmcgPG1lQHJvbGZsZWthbmcuY29tPlwiLFwiS2V2aW4gTWFpLUh1c2FuIENoaWEgPG1oY2hpYUB1c2Vycy5ub3JlcGx5LmdpdGh1Yi5jb20+XCIsXCJQZXBpam4gZGUgVm9zIDxwZXBpam5kZXZvc0BnbWFpbC5jb20+XCIsXCJKb29Zb3VuZyA8cWtkbHFsQG5hdmVyLmNvbT5cIixcIlRvYmlhcyBTcGVpY2hlciA8cm9vdGNvbW1hbmRlckBnbWFpbC5jb20+XCIsXCJTdGV2ZSBCbGF1cm9jayA8c2JsYXVyb2NrQGdtYWlsLmNvbT5cIixcIkt5cnlsbyBTaGVnZWRhIDxzaGVnZWRhQHVhbGJlcnRhLmNhPlwiLFwiRGl3YW5rIFNpbmdoIFRvbWVyIDxzaW5naEBkaXdhbmsubmFtZT5cIixcIlNvXFx1MDMwOHJlbiBCYWxrbyA8U29lcmVuLkJhbGtvQGdtYWlsLmNvbT5cIixcIkFycGl0IFNvbGFua2kgPHNvbGFua2lhcnBpdDE5OTdAZ21haWwuY29tPlwiLFwiWXVraSBJdG8gPHl1a2lAZ25uay5uZXQ+XCIsXCJBcnR1ciBaYXlhdHMgPHphZzJhcnRAZ21haWwuY29tPlwiXSxcImZ1bmRpbmdcIjp7XCJ0eXBlXCI6XCJvcGVuY29sbGVjdGl2ZVwiLFwidXJsXCI6XCJodHRwczovL29wZW5jb2xsZWN0aXZlLmNvbS9wZWVyXCJ9LFwiY29sbGVjdGl2ZVwiOntcInR5cGVcIjpcIm9wZW5jb2xsZWN0aXZlXCIsXCJ1cmxcIjpcImh0dHBzOi8vb3BlbmNvbGxlY3RpdmUuY29tL3BlZXJcIn0sXCJmaWxlc1wiOltcImRpc3QvKlwiXSxcInNpZGVFZmZlY3RzXCI6W1wibGliL2dsb2JhbC50c1wiLFwibGliL3N1cHBvcnRzLnRzXCJdLFwibWFpblwiOlwiZGlzdC9idW5kbGVyLmNqc1wiLFwibW9kdWxlXCI6XCJkaXN0L2J1bmRsZXIubWpzXCIsXCJicm93c2VyLW1pbmlmaWVkXCI6XCJkaXN0L3BlZXJqcy5taW4uanNcIixcImJyb3dzZXItdW5taW5pZmllZFwiOlwiZGlzdC9wZWVyanMuanNcIixcImJyb3dzZXItbWluaWZpZWQtbXNncGFja1wiOlwiZGlzdC9zZXJpYWxpemVyLm1zZ3BhY2subWpzXCIsXCJ0eXBlc1wiOlwiZGlzdC90eXBlcy5kLnRzXCIsXCJlbmdpbmVzXCI6e1wibm9kZVwiOlwiPj0gMTRcIn0sXCJ0YXJnZXRzXCI6e1widHlwZXNcIjp7XCJzb3VyY2VcIjpcImxpYi9leHBvcnRzLnRzXCJ9LFwibWFpblwiOntcInNvdXJjZVwiOlwibGliL2V4cG9ydHMudHNcIixcInNvdXJjZU1hcFwiOntcImlubGluZVNvdXJjZXNcIjp0cnVlfX0sXCJtb2R1bGVcIjp7XCJzb3VyY2VcIjpcImxpYi9leHBvcnRzLnRzXCIsXCJpbmNsdWRlTm9kZU1vZHVsZXNcIjpbXCJldmVudGVtaXR0ZXIzXCJdLFwic291cmNlTWFwXCI6e1wiaW5saW5lU291cmNlc1wiOnRydWV9fSxcImJyb3dzZXItbWluaWZpZWRcIjp7XCJjb250ZXh0XCI6XCJicm93c2VyXCIsXCJvdXRwdXRGb3JtYXRcIjpcImdsb2JhbFwiLFwib3B0aW1pemVcIjp0cnVlLFwiZW5naW5lc1wiOntcImJyb3dzZXJzXCI6XCJjaHJvbWUgPj0gODMsIGVkZ2UgPj0gODMsIGZpcmVmb3ggPj0gODAsIHNhZmFyaSA+PSAxNVwifSxcInNvdXJjZVwiOlwibGliL2dsb2JhbC50c1wifSxcImJyb3dzZXItdW5taW5pZmllZFwiOntcImNvbnRleHRcIjpcImJyb3dzZXJcIixcIm91dHB1dEZvcm1hdFwiOlwiZ2xvYmFsXCIsXCJvcHRpbWl6ZVwiOmZhbHNlLFwiZW5naW5lc1wiOntcImJyb3dzZXJzXCI6XCJjaHJvbWUgPj0gODMsIGVkZ2UgPj0gODMsIGZpcmVmb3ggPj0gODAsIHNhZmFyaSA+PSAxNVwifSxcInNvdXJjZVwiOlwibGliL2dsb2JhbC50c1wifSxcImJyb3dzZXItbWluaWZpZWQtbXNncGFja1wiOntcImNvbnRleHRcIjpcImJyb3dzZXJcIixcIm91dHB1dEZvcm1hdFwiOlwiZXNtb2R1bGVcIixcImlzTGlicmFyeVwiOnRydWUsXCJvcHRpbWl6ZVwiOnRydWUsXCJlbmdpbmVzXCI6e1wiYnJvd3NlcnNcIjpcImNocm9tZSA+PSA4MywgZWRnZSA+PSA4MywgZmlyZWZveCA+PSAxMDIsIHNhZmFyaSA+PSAxNVwifSxcInNvdXJjZVwiOlwibGliL2RhdGFjb25uZWN0aW9uL1N0cmVhbUNvbm5lY3Rpb24vTXNnUGFjay50c1wifX0sXCJzY3JpcHRzXCI6e1wiY29udHJpYnV0b3JzXCI6XCJnaXQtYXV0aG9ycy1jbGkgLS1wcmludD1mYWxzZSAmJiBwcmV0dGllciAtLXdyaXRlIHBhY2thZ2UuanNvbiAmJiBnaXQgYWRkIHBhY2thZ2UuanNvbiBwYWNrYWdlLWxvY2suanNvbiAmJiBnaXQgY29tbWl0IC1tIFxcXFxcImNob3JlKGNvbnRyaWJ1dG9ycyk6IHVwZGF0ZSBhbmQgc29ydCBjb250cmlidXRvcnMgbGlzdFxcXFxcIlwiLFwiY2hlY2tcIjpcInRzYyAtLW5vRW1pdCAmJiB0c2MgLXAgZTJlL3RzY29uZmlnLmpzb24gLS1ub0VtaXRcIixcIndhdGNoXCI6XCJwYXJjZWwgd2F0Y2hcIixcImJ1aWxkXCI6XCJybSAtcmYgZGlzdCAmJiBwYXJjZWwgYnVpbGRcIixcInByZXB1Ymxpc2hPbmx5XCI6XCJucG0gcnVuIGJ1aWxkXCIsXCJ0ZXN0XCI6XCJqZXN0XCIsXCJ0ZXN0OndhdGNoXCI6XCJqZXN0IC0td2F0Y2hcIixcImNvdmVyYWdlXCI6XCJqZXN0IC0tY292ZXJhZ2UgLS1jb2xsZWN0Q292ZXJhZ2VGcm9tPVxcXFxcIi4vbGliLyoqXFxcXFwiXCIsXCJmb3JtYXRcIjpcInByZXR0aWVyIC0td3JpdGUgLlwiLFwiZm9ybWF0OmNoZWNrXCI6XCJwcmV0dGllciAtLWNoZWNrIC5cIixcInNlbWFudGljLXJlbGVhc2VcIjpcInNlbWFudGljLXJlbGVhc2VcIixcImUyZVwiOlwid2RpbyBydW4gZTJlL3dkaW8ubG9jYWwuY29uZi50c1wiLFwiZTJlOmJzdGFja1wiOlwid2RpbyBydW4gZTJlL3dkaW8uYnN0YWNrLmNvbmYudHNcIn0sXCJkZXZEZXBlbmRlbmNpZXNcIjp7XCJAcGFyY2VsL2NvbmZpZy1kZWZhdWx0XCI6XCJeMi45LjNcIixcIkBwYXJjZWwvcGFja2FnZXItdHNcIjpcIl4yLjkuM1wiLFwiQHBhcmNlbC90cmFuc2Zvcm1lci10eXBlc2NyaXB0LXRzY1wiOlwiXjIuOS4zXCIsXCJAcGFyY2VsL3RyYW5zZm9ybWVyLXR5cGVzY3JpcHQtdHlwZXNcIjpcIl4yLjkuM1wiLFwiQHNlbWFudGljLXJlbGVhc2UvY2hhbmdlbG9nXCI6XCJeNi4wLjFcIixcIkBzZW1hbnRpYy1yZWxlYXNlL2dpdFwiOlwiXjEwLjAuMVwiLFwiQHN3Yy9jb3JlXCI6XCJeMS4zLjI3XCIsXCJAc3djL2plc3RcIjpcIl4wLjIuMjRcIixcIkB0eXBlcy9qYXNtaW5lXCI6XCJeNC4zLjRcIixcIkB3ZGlvL2Jyb3dzZXJzdGFjay1zZXJ2aWNlXCI6XCJeOC4xMS4yXCIsXCJAd2Rpby9jbGlcIjpcIl44LjExLjJcIixcIkB3ZGlvL2dsb2JhbHNcIjpcIl44LjExLjJcIixcIkB3ZGlvL2phc21pbmUtZnJhbWV3b3JrXCI6XCJeOC4xMS4yXCIsXCJAd2Rpby9sb2NhbC1ydW5uZXJcIjpcIl44LjExLjJcIixcIkB3ZGlvL3NwZWMtcmVwb3J0ZXJcIjpcIl44LjExLjJcIixcIkB3ZGlvL3R5cGVzXCI6XCJeOC4xMC40XCIsXCJodHRwLXNlcnZlclwiOlwiXjE0LjEuMVwiLFwiamVzdFwiOlwiXjI5LjMuMVwiLFwiamVzdC1lbnZpcm9ubWVudC1qc2RvbVwiOlwiXjI5LjMuMVwiLFwibW9jay1zb2NrZXRcIjpcIl45LjAuMFwiLFwicGFyY2VsXCI6XCJeMi45LjNcIixcInByZXR0aWVyXCI6XCJeMy4wLjBcIixcInNlbWFudGljLXJlbGVhc2VcIjpcIl4yMS4wLjBcIixcInRzLW5vZGVcIjpcIl4xMC45LjFcIixcInR5cGVzY3JpcHRcIjpcIl41LjAuMFwiLFwid2Rpby1nZWNrb2RyaXZlci1zZXJ2aWNlXCI6XCJeNS4wLjFcIn0sXCJkZXBlbmRlbmNpZXNcIjp7XCJAbXNncGFjay9tc2dwYWNrXCI6XCJeMi44LjBcIixcImV2ZW50ZW1pdHRlcjNcIjpcIl40LjAuN1wiLFwicGVlcmpzLWpzLWJpbmFyeXBhY2tcIjpcIl4yLjEuMFwiLFwid2VicnRjLWFkYXB0ZXJcIjpcIl45LjAuMFwifSxcImFsaWFzXCI6e1wicHJvY2Vzc1wiOmZhbHNlLFwiYnVmZmVyXCI6ZmFsc2V9fScpO1xuXG5cbmNsYXNzICQ4ZjViZmE2MDgzNmQyNjFkJGV4cG9ydCQ0Nzk4OTE3ZGJmMTQ5Yjc5IGV4dGVuZHMgKDAsICRjNGRjZmQxZDFlYTg2NjQ3JGV4cG9ydHMuRXZlbnRFbWl0dGVyKSB7XG4gICAgY29uc3RydWN0b3Ioc2VjdXJlLCBob3N0LCBwb3J0LCBwYXRoLCBrZXksIHBpbmdJbnRlcnZhbCA9IDUwMDApe1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnBpbmdJbnRlcnZhbCA9IHBpbmdJbnRlcnZhbDtcbiAgICAgICAgdGhpcy5fZGlzY29ubmVjdGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fbWVzc2FnZXNRdWV1ZSA9IFtdO1xuICAgICAgICBjb25zdCB3c1Byb3RvY29sID0gc2VjdXJlID8gXCJ3c3M6Ly9cIiA6IFwid3M6Ly9cIjtcbiAgICAgICAgdGhpcy5fYmFzZVVybCA9IHdzUHJvdG9jb2wgKyBob3N0ICsgXCI6XCIgKyBwb3J0ICsgcGF0aCArIFwicGVlcmpzP2tleT1cIiArIGtleTtcbiAgICB9XG4gICAgc3RhcnQoaWQsIHRva2VuKSB7XG4gICAgICAgIHRoaXMuX2lkID0gaWQ7XG4gICAgICAgIGNvbnN0IHdzVXJsID0gYCR7dGhpcy5fYmFzZVVybH0maWQ9JHtpZH0mdG9rZW49JHt0b2tlbn1gO1xuICAgICAgICBpZiAoISF0aGlzLl9zb2NrZXQgfHwgIXRoaXMuX2Rpc2Nvbm5lY3RlZCkgcmV0dXJuO1xuICAgICAgICB0aGlzLl9zb2NrZXQgPSBuZXcgV2ViU29ja2V0KHdzVXJsICsgXCImdmVyc2lvbj1cIiArICgwLCAkZjVmODgxZWM0NTc1ZjFmYyRleHBvcnRzLnZlcnNpb24pKTtcbiAgICAgICAgdGhpcy5fZGlzY29ubmVjdGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3NvY2tldC5vbm1lc3NhZ2UgPSAoZXZlbnQpPT57XG4gICAgICAgICAgICBsZXQgZGF0YTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoZXZlbnQuZGF0YSk7XG4gICAgICAgICAgICAgICAgKDAsICQyNTc5NDdlOTI5MjYyNzdhJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkpLmxvZyhcIlNlcnZlciBtZXNzYWdlIHJlY2VpdmVkOlwiLCBkYXRhKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAoMCwgJDI1Nzk0N2U5MjkyNjI3N2EkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOSkubG9nKFwiSW52YWxpZCBzZXJ2ZXIgbWVzc2FnZVwiLCBldmVudC5kYXRhKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVtaXQoKDAsICQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydCQzYjVjNGE0YjYzNTRmMDIzKS5NZXNzYWdlLCBkYXRhKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fc29ja2V0Lm9uY2xvc2UgPSAoZXZlbnQpPT57XG4gICAgICAgICAgICBpZiAodGhpcy5fZGlzY29ubmVjdGVkKSByZXR1cm47XG4gICAgICAgICAgICAoMCwgJDI1Nzk0N2U5MjkyNjI3N2EkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOSkubG9nKFwiU29ja2V0IGNsb3NlZC5cIiwgZXZlbnQpO1xuICAgICAgICAgICAgdGhpcy5fY2xlYW51cCgpO1xuICAgICAgICAgICAgdGhpcy5fZGlzY29ubmVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgoMCwgJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JDNiNWM0YTRiNjM1NGYwMjMpLkRpc2Nvbm5lY3RlZCk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIFRha2UgY2FyZSBvZiB0aGUgcXVldWUgb2YgY29ubmVjdGlvbnMgaWYgbmVjZXNzYXJ5IGFuZCBtYWtlIHN1cmUgUGVlciBrbm93c1xuICAgICAgICAvLyBzb2NrZXQgaXMgb3Blbi5cbiAgICAgICAgdGhpcy5fc29ja2V0Lm9ub3BlbiA9ICgpPT57XG4gICAgICAgICAgICBpZiAodGhpcy5fZGlzY29ubmVjdGVkKSByZXR1cm47XG4gICAgICAgICAgICB0aGlzLl9zZW5kUXVldWVkTWVzc2FnZXMoKTtcbiAgICAgICAgICAgICgwLCAkMjU3OTQ3ZTkyOTI2Mjc3YSRleHBvcnQkMmUyYmNkODczOWFlMDM5KS5sb2coXCJTb2NrZXQgb3BlblwiKTtcbiAgICAgICAgICAgIHRoaXMuX3NjaGVkdWxlSGVhcnRiZWF0KCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIF9zY2hlZHVsZUhlYXJ0YmVhdCgpIHtcbiAgICAgICAgdGhpcy5fd3NQaW5nVGltZXIgPSBzZXRUaW1lb3V0KCgpPT57XG4gICAgICAgICAgICB0aGlzLl9zZW5kSGVhcnRiZWF0KCk7XG4gICAgICAgIH0sIHRoaXMucGluZ0ludGVydmFsKTtcbiAgICB9XG4gICAgX3NlbmRIZWFydGJlYXQoKSB7XG4gICAgICAgIGlmICghdGhpcy5fd3NPcGVuKCkpIHtcbiAgICAgICAgICAgICgwLCAkMjU3OTQ3ZTkyOTI2Mjc3YSRleHBvcnQkMmUyYmNkODczOWFlMDM5KS5sb2coYENhbm5vdCBzZW5kIGhlYXJ0YmVhdCwgYmVjYXVzZSBzb2NrZXQgY2xvc2VkYCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIHR5cGU6ICgwLCAkNzg0NTVlMjJkZWE5NmI4YyRleHBvcnQkYWRiNGExNzU0ZGE2ZjEwZCkuSGVhcnRiZWF0XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9zb2NrZXQuc2VuZChtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5fc2NoZWR1bGVIZWFydGJlYXQoKTtcbiAgICB9XG4gICAgLyoqIElzIHRoZSB3ZWJzb2NrZXQgY3VycmVudGx5IG9wZW4/ICovIF93c09wZW4oKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX3NvY2tldCAmJiB0aGlzLl9zb2NrZXQucmVhZHlTdGF0ZSA9PT0gMTtcbiAgICB9XG4gICAgLyoqIFNlbmQgcXVldWVkIG1lc3NhZ2VzLiAqLyBfc2VuZFF1ZXVlZE1lc3NhZ2VzKCkge1xuICAgICAgICAvL0NyZWF0ZSBjb3B5IG9mIHF1ZXVlIGFuZCBjbGVhciBpdCxcbiAgICAgICAgLy9iZWNhdXNlIHNlbmQgbWV0aG9kIHB1c2ggdGhlIG1lc3NhZ2UgYmFjayB0byBxdWV1ZSBpZiBzbXRoIHdpbGwgZ28gd3JvbmdcbiAgICAgICAgY29uc3QgY29waWVkUXVldWUgPSBbXG4gICAgICAgICAgICAuLi50aGlzLl9tZXNzYWdlc1F1ZXVlXG4gICAgICAgIF07XG4gICAgICAgIHRoaXMuX21lc3NhZ2VzUXVldWUgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBtZXNzYWdlIG9mIGNvcGllZFF1ZXVlKXRoaXMuc2VuZChtZXNzYWdlKTtcbiAgICB9XG4gICAgLyoqIEV4cG9zZWQgc2VuZCBmb3IgREMgJiBQZWVyLiAqLyBzZW5kKGRhdGEpIHtcbiAgICAgICAgaWYgKHRoaXMuX2Rpc2Nvbm5lY3RlZCkgcmV0dXJuO1xuICAgICAgICAvLyBJZiB3ZSBkaWRuJ3QgZ2V0IGFuIElEIHlldCwgd2UgY2FuJ3QgeWV0IHNlbmQgYW55dGhpbmcgc28gd2Ugc2hvdWxkIHF1ZXVlXG4gICAgICAgIC8vIHVwIHRoZXNlIG1lc3NhZ2VzLlxuICAgICAgICBpZiAoIXRoaXMuX2lkKSB7XG4gICAgICAgICAgICB0aGlzLl9tZXNzYWdlc1F1ZXVlLnB1c2goZGF0YSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkYXRhLnR5cGUpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgoMCwgJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JDNiNWM0YTRiNjM1NGYwMjMpLkVycm9yLCBcIkludmFsaWQgbWVzc2FnZVwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX3dzT3BlbigpKSByZXR1cm47XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBKU09OLnN0cmluZ2lmeShkYXRhKTtcbiAgICAgICAgdGhpcy5fc29ja2V0LnNlbmQobWVzc2FnZSk7XG4gICAgfVxuICAgIGNsb3NlKCkge1xuICAgICAgICBpZiAodGhpcy5fZGlzY29ubmVjdGVkKSByZXR1cm47XG4gICAgICAgIHRoaXMuX2NsZWFudXAoKTtcbiAgICAgICAgdGhpcy5fZGlzY29ubmVjdGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgX2NsZWFudXAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9zb2NrZXQpIHtcbiAgICAgICAgICAgIHRoaXMuX3NvY2tldC5vbm9wZW4gPSB0aGlzLl9zb2NrZXQub25tZXNzYWdlID0gdGhpcy5fc29ja2V0Lm9uY2xvc2UgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fc29ja2V0LmNsb3NlKCk7XG4gICAgICAgICAgICB0aGlzLl9zb2NrZXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3dzUGluZ1RpbWVyKTtcbiAgICB9XG59XG5cblxuXG5cblxuXG5jbGFzcyAkYjgyZmI4ZmMwNTE0YmZjMSRleHBvcnQkODllNmJiNWFkNjRiZjRhIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25uZWN0aW9uKXtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uID0gY29ubmVjdGlvbjtcbiAgICB9XG4gICAgLyoqIFJldHVybnMgYSBQZWVyQ29ubmVjdGlvbiBvYmplY3Qgc2V0IHVwIGNvcnJlY3RseSAoZm9yIGRhdGEsIG1lZGlhKS4gKi8gc3RhcnRDb25uZWN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcGVlckNvbm5lY3Rpb24gPSB0aGlzLl9zdGFydFBlZXJDb25uZWN0aW9uKCk7XG4gICAgICAgIC8vIFNldCB0aGUgY29ubmVjdGlvbidzIFBDLlxuICAgICAgICB0aGlzLmNvbm5lY3Rpb24ucGVlckNvbm5lY3Rpb24gPSBwZWVyQ29ubmVjdGlvbjtcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGlvbi50eXBlID09PSAoMCwgJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JDMxNTdkNTdiNDEzNWUzYmMpLk1lZGlhICYmIG9wdGlvbnMuX3N0cmVhbSkgdGhpcy5fYWRkVHJhY2tzVG9Db25uZWN0aW9uKG9wdGlvbnMuX3N0cmVhbSwgcGVlckNvbm5lY3Rpb24pO1xuICAgICAgICAvLyBXaGF0IGRvIHdlIG5lZWQgdG8gZG8gbm93P1xuICAgICAgICBpZiAob3B0aW9ucy5vcmlnaW5hdG9yKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhQ29ubmVjdGlvbiA9IHRoaXMuY29ubmVjdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgICAgICAgICAgICBvcmRlcmVkOiAhIW9wdGlvbnMucmVsaWFibGVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBkYXRhQ2hhbm5lbCA9IHBlZXJDb25uZWN0aW9uLmNyZWF0ZURhdGFDaGFubmVsKGRhdGFDb25uZWN0aW9uLmxhYmVsLCBjb25maWcpO1xuICAgICAgICAgICAgZGF0YUNvbm5lY3Rpb24uX2luaXRpYWxpemVEYXRhQ2hhbm5lbChkYXRhQ2hhbm5lbCk7XG4gICAgICAgICAgICB0aGlzLl9tYWtlT2ZmZXIoKTtcbiAgICAgICAgfSBlbHNlIHRoaXMuaGFuZGxlU0RQKFwiT0ZGRVJcIiwgb3B0aW9ucy5zZHApO1xuICAgIH1cbiAgICAvKiogU3RhcnQgYSBQQy4gKi8gX3N0YXJ0UGVlckNvbm5lY3Rpb24oKSB7XG4gICAgICAgICgwLCAkMjU3OTQ3ZTkyOTI2Mjc3YSRleHBvcnQkMmUyYmNkODczOWFlMDM5KS5sb2coXCJDcmVhdGluZyBSVENQZWVyQ29ubmVjdGlvbi5cIik7XG4gICAgICAgIGNvbnN0IHBlZXJDb25uZWN0aW9uID0gbmV3IFJUQ1BlZXJDb25uZWN0aW9uKHRoaXMuY29ubmVjdGlvbi5wcm92aWRlci5vcHRpb25zLmNvbmZpZyk7XG4gICAgICAgIHRoaXMuX3NldHVwTGlzdGVuZXJzKHBlZXJDb25uZWN0aW9uKTtcbiAgICAgICAgcmV0dXJuIHBlZXJDb25uZWN0aW9uO1xuICAgIH1cbiAgICAvKiogU2V0IHVwIHZhcmlvdXMgV2ViUlRDIGxpc3RlbmVycy4gKi8gX3NldHVwTGlzdGVuZXJzKHBlZXJDb25uZWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IHBlZXJJZCA9IHRoaXMuY29ubmVjdGlvbi5wZWVyO1xuICAgICAgICBjb25zdCBjb25uZWN0aW9uSWQgPSB0aGlzLmNvbm5lY3Rpb24uY29ubmVjdGlvbklkO1xuICAgICAgICBjb25zdCBjb25uZWN0aW9uVHlwZSA9IHRoaXMuY29ubmVjdGlvbi50eXBlO1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IHRoaXMuY29ubmVjdGlvbi5wcm92aWRlcjtcbiAgICAgICAgLy8gSUNFIENBTkRJREFURVMuXG4gICAgICAgICgwLCAkMjU3OTQ3ZTkyOTI2Mjc3YSRleHBvcnQkMmUyYmNkODczOWFlMDM5KS5sb2coXCJMaXN0ZW5pbmcgZm9yIElDRSBjYW5kaWRhdGVzLlwiKTtcbiAgICAgICAgcGVlckNvbm5lY3Rpb24ub25pY2VjYW5kaWRhdGUgPSAoZXZ0KT0+e1xuICAgICAgICAgICAgaWYgKCFldnQuY2FuZGlkYXRlIHx8ICFldnQuY2FuZGlkYXRlLmNhbmRpZGF0ZSkgcmV0dXJuO1xuICAgICAgICAgICAgKDAsICQyNTc5NDdlOTI5MjYyNzdhJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkpLmxvZyhgUmVjZWl2ZWQgSUNFIGNhbmRpZGF0ZXMgZm9yICR7cGVlcklkfTpgLCBldnQuY2FuZGlkYXRlKTtcbiAgICAgICAgICAgIHByb3ZpZGVyLnNvY2tldC5zZW5kKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAoMCwgJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JGFkYjRhMTc1NGRhNmYxMGQpLkNhbmRpZGF0ZSxcbiAgICAgICAgICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgICAgICAgICAgIGNhbmRpZGF0ZTogZXZ0LmNhbmRpZGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogY29ubmVjdGlvblR5cGUsXG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25JZDogY29ubmVjdGlvbklkXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBkc3Q6IHBlZXJJZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHBlZXJDb25uZWN0aW9uLm9uaWNlY29ubmVjdGlvbnN0YXRlY2hhbmdlID0gKCk9PntcbiAgICAgICAgICAgIHN3aXRjaChwZWVyQ29ubmVjdGlvbi5pY2VDb25uZWN0aW9uU3RhdGUpe1xuICAgICAgICAgICAgICAgIGNhc2UgXCJmYWlsZWRcIjpcbiAgICAgICAgICAgICAgICAgICAgKDAsICQyNTc5NDdlOTI5MjYyNzdhJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkpLmxvZyhcImljZUNvbm5lY3Rpb25TdGF0ZSBpcyBmYWlsZWQsIGNsb3NpbmcgY29ubmVjdGlvbnMgdG8gXCIgKyBwZWVySWQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb24uZW1pdEVycm9yKCgwLCAkNzg0NTVlMjJkZWE5NmI4YyRleHBvcnQkNzk3NDkzNTY4NjE0OTY4NikuTmVnb3RpYXRpb25GYWlsZWQsIFwiTmVnb3RpYXRpb24gb2YgY29ubmVjdGlvbiB0byBcIiArIHBlZXJJZCArIFwiIGZhaWxlZC5cIik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbi5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiY2xvc2VkXCI6XG4gICAgICAgICAgICAgICAgICAgICgwLCAkMjU3OTQ3ZTkyOTI2Mjc3YSRleHBvcnQkMmUyYmNkODczOWFlMDM5KS5sb2coXCJpY2VDb25uZWN0aW9uU3RhdGUgaXMgY2xvc2VkLCBjbG9zaW5nIGNvbm5lY3Rpb25zIHRvIFwiICsgcGVlcklkKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uLmVtaXRFcnJvcigoMCwgJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JDc5NzQ5MzU2ODYxNDk2ODYpLkNvbm5lY3Rpb25DbG9zZWQsIFwiQ29ubmVjdGlvbiB0byBcIiArIHBlZXJJZCArIFwiIGNsb3NlZC5cIik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbi5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiZGlzY29ubmVjdGVkXCI6XG4gICAgICAgICAgICAgICAgICAgICgwLCAkMjU3OTQ3ZTkyOTI2Mjc3YSRleHBvcnQkMmUyYmNkODczOWFlMDM5KS5sb2coXCJpY2VDb25uZWN0aW9uU3RhdGUgY2hhbmdlZCB0byBkaXNjb25uZWN0ZWQgb24gdGhlIGNvbm5lY3Rpb24gd2l0aCBcIiArIHBlZXJJZCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJjb21wbGV0ZWRcIjpcbiAgICAgICAgICAgICAgICAgICAgcGVlckNvbm5lY3Rpb24ub25pY2VjYW5kaWRhdGUgPSAoKT0+e307XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uLmVtaXQoXCJpY2VTdGF0ZUNoYW5nZWRcIiwgcGVlckNvbm5lY3Rpb24uaWNlQ29ubmVjdGlvblN0YXRlKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gREFUQUNPTk5FQ1RJT04uXG4gICAgICAgICgwLCAkMjU3OTQ3ZTkyOTI2Mjc3YSRleHBvcnQkMmUyYmNkODczOWFlMDM5KS5sb2coXCJMaXN0ZW5pbmcgZm9yIGRhdGEgY2hhbm5lbFwiKTtcbiAgICAgICAgLy8gRmlyZWQgYmV0d2VlbiBvZmZlciBhbmQgYW5zd2VyLCBzbyBvcHRpb25zIHNob3VsZCBhbHJlYWR5IGJlIHNhdmVkXG4gICAgICAgIC8vIGluIHRoZSBvcHRpb25zIGhhc2guXG4gICAgICAgIHBlZXJDb25uZWN0aW9uLm9uZGF0YWNoYW5uZWwgPSAoZXZ0KT0+e1xuICAgICAgICAgICAgKDAsICQyNTc5NDdlOTI5MjYyNzdhJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkpLmxvZyhcIlJlY2VpdmVkIGRhdGEgY2hhbm5lbFwiKTtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFDaGFubmVsID0gZXZ0LmNoYW5uZWw7XG4gICAgICAgICAgICBjb25zdCBjb25uZWN0aW9uID0gcHJvdmlkZXIuZ2V0Q29ubmVjdGlvbihwZWVySWQsIGNvbm5lY3Rpb25JZCk7XG4gICAgICAgICAgICBjb25uZWN0aW9uLl9pbml0aWFsaXplRGF0YUNoYW5uZWwoZGF0YUNoYW5uZWwpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBNRURJQUNPTk5FQ1RJT04uXG4gICAgICAgICgwLCAkMjU3OTQ3ZTkyOTI2Mjc3YSRleHBvcnQkMmUyYmNkODczOWFlMDM5KS5sb2coXCJMaXN0ZW5pbmcgZm9yIHJlbW90ZSBzdHJlYW1cIik7XG4gICAgICAgIHBlZXJDb25uZWN0aW9uLm9udHJhY2sgPSAoZXZ0KT0+e1xuICAgICAgICAgICAgKDAsICQyNTc5NDdlOTI5MjYyNzdhJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkpLmxvZyhcIlJlY2VpdmVkIHJlbW90ZSBzdHJlYW1cIik7XG4gICAgICAgICAgICBjb25zdCBzdHJlYW0gPSBldnQuc3RyZWFtc1swXTtcbiAgICAgICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSBwcm92aWRlci5nZXRDb25uZWN0aW9uKHBlZXJJZCwgY29ubmVjdGlvbklkKTtcbiAgICAgICAgICAgIGlmIChjb25uZWN0aW9uLnR5cGUgPT09ICgwLCAkNzg0NTVlMjJkZWE5NmI4YyRleHBvcnQkMzE1N2Q1N2I0MTM1ZTNiYykuTWVkaWEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtZWRpYUNvbm5lY3Rpb24gPSBjb25uZWN0aW9uO1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkZFN0cmVhbVRvTWVkaWFDb25uZWN0aW9uKHN0cmVhbSwgbWVkaWFDb25uZWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgY2xlYW51cCgpIHtcbiAgICAgICAgKDAsICQyNTc5NDdlOTI5MjYyNzdhJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkpLmxvZyhcIkNsZWFuaW5nIHVwIFBlZXJDb25uZWN0aW9uIHRvIFwiICsgdGhpcy5jb25uZWN0aW9uLnBlZXIpO1xuICAgICAgICBjb25zdCBwZWVyQ29ubmVjdGlvbiA9IHRoaXMuY29ubmVjdGlvbi5wZWVyQ29ubmVjdGlvbjtcbiAgICAgICAgaWYgKCFwZWVyQ29ubmVjdGlvbikgcmV0dXJuO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb24ucGVlckNvbm5lY3Rpb24gPSBudWxsO1xuICAgICAgICAvL3Vuc3Vic2NyaWJlIGZyb20gYWxsIFBlZXJDb25uZWN0aW9uJ3MgZXZlbnRzXG4gICAgICAgIHBlZXJDb25uZWN0aW9uLm9uaWNlY2FuZGlkYXRlID0gcGVlckNvbm5lY3Rpb24ub25pY2Vjb25uZWN0aW9uc3RhdGVjaGFuZ2UgPSBwZWVyQ29ubmVjdGlvbi5vbmRhdGFjaGFubmVsID0gcGVlckNvbm5lY3Rpb24ub250cmFjayA9ICgpPT57fTtcbiAgICAgICAgY29uc3QgcGVlckNvbm5lY3Rpb25Ob3RDbG9zZWQgPSBwZWVyQ29ubmVjdGlvbi5zaWduYWxpbmdTdGF0ZSAhPT0gXCJjbG9zZWRcIjtcbiAgICAgICAgbGV0IGRhdGFDaGFubmVsTm90Q2xvc2VkID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGRhdGFDaGFubmVsID0gdGhpcy5jb25uZWN0aW9uLmRhdGFDaGFubmVsO1xuICAgICAgICBpZiAoZGF0YUNoYW5uZWwpIGRhdGFDaGFubmVsTm90Q2xvc2VkID0gISFkYXRhQ2hhbm5lbC5yZWFkeVN0YXRlICYmIGRhdGFDaGFubmVsLnJlYWR5U3RhdGUgIT09IFwiY2xvc2VkXCI7XG4gICAgICAgIGlmIChwZWVyQ29ubmVjdGlvbk5vdENsb3NlZCB8fCBkYXRhQ2hhbm5lbE5vdENsb3NlZCkgcGVlckNvbm5lY3Rpb24uY2xvc2UoKTtcbiAgICB9XG4gICAgYXN5bmMgX21ha2VPZmZlcigpIHtcbiAgICAgICAgY29uc3QgcGVlckNvbm5lY3Rpb24gPSB0aGlzLmNvbm5lY3Rpb24ucGVlckNvbm5lY3Rpb247XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gdGhpcy5jb25uZWN0aW9uLnByb3ZpZGVyO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qgb2ZmZXIgPSBhd2FpdCBwZWVyQ29ubmVjdGlvbi5jcmVhdGVPZmZlcih0aGlzLmNvbm5lY3Rpb24ub3B0aW9ucy5jb25zdHJhaW50cyk7XG4gICAgICAgICAgICAoMCwgJDI1Nzk0N2U5MjkyNjI3N2EkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOSkubG9nKFwiQ3JlYXRlZCBvZmZlci5cIik7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25uZWN0aW9uLm9wdGlvbnMuc2RwVHJhbnNmb3JtICYmIHR5cGVvZiB0aGlzLmNvbm5lY3Rpb24ub3B0aW9ucy5zZHBUcmFuc2Zvcm0gPT09IFwiZnVuY3Rpb25cIikgb2ZmZXIuc2RwID0gdGhpcy5jb25uZWN0aW9uLm9wdGlvbnMuc2RwVHJhbnNmb3JtKG9mZmVyLnNkcCkgfHwgb2ZmZXIuc2RwO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhd2FpdCBwZWVyQ29ubmVjdGlvbi5zZXRMb2NhbERlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgICAgICAgICAoMCwgJDI1Nzk0N2U5MjkyNjI3N2EkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOSkubG9nKFwiU2V0IGxvY2FsRGVzY3JpcHRpb246XCIsIG9mZmVyLCBgZm9yOiR7dGhpcy5jb25uZWN0aW9uLnBlZXJ9YCk7XG4gICAgICAgICAgICAgICAgbGV0IHBheWxvYWQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHNkcDogb2ZmZXIsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IHRoaXMuY29ubmVjdGlvbi50eXBlLFxuICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uSWQ6IHRoaXMuY29ubmVjdGlvbi5jb25uZWN0aW9uSWQsXG4gICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhOiB0aGlzLmNvbm5lY3Rpb24ubWV0YWRhdGFcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbm5lY3Rpb24udHlwZSA9PT0gKDAsICQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydCQzMTU3ZDU3YjQxMzVlM2JjKS5EYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFDb25uZWN0aW9uID0gdGhpcy5jb25uZWN0aW9uO1xuICAgICAgICAgICAgICAgICAgICBwYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4ucGF5bG9hZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBkYXRhQ29ubmVjdGlvbi5sYWJlbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbGlhYmxlOiBkYXRhQ29ubmVjdGlvbi5yZWxpYWJsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmlhbGl6YXRpb246IGRhdGFDb25uZWN0aW9uLnNlcmlhbGl6YXRpb25cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJvdmlkZXIuc29ja2V0LnNlbmQoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAoMCwgJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JGFkYjRhMTc1NGRhNmYxMGQpLk9mZmVyLFxuICAgICAgICAgICAgICAgICAgICBwYXlsb2FkOiBwYXlsb2FkLFxuICAgICAgICAgICAgICAgICAgICBkc3Q6IHRoaXMuY29ubmVjdGlvbi5wZWVyXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBpbnZlc3RpZ2F0ZSB3aHkgX21ha2VPZmZlciBpcyBiZWluZyBjYWxsZWQgZnJvbSB0aGUgYW5zd2VyXG4gICAgICAgICAgICAgICAgaWYgKGVyciAhPSBcIk9wZXJhdGlvbkVycm9yOiBGYWlsZWQgdG8gc2V0IGxvY2FsIG9mZmVyIHNkcDogQ2FsbGVkIGluIHdyb25nIHN0YXRlOiBrSGF2ZVJlbW90ZU9mZmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXIuZW1pdEVycm9yKCgwLCAkNzg0NTVlMjJkZWE5NmI4YyRleHBvcnQkOTU0N2FhYTJlMzkwMzBmZikuV2ViUlRDLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICAoMCwgJDI1Nzk0N2U5MjkyNjI3N2EkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOSkubG9nKFwiRmFpbGVkIHRvIHNldExvY2FsRGVzY3JpcHRpb24sIFwiLCBlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyXzEpIHtcbiAgICAgICAgICAgIHByb3ZpZGVyLmVtaXRFcnJvcigoMCwgJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JDk1NDdhYWEyZTM5MDMwZmYpLldlYlJUQywgZXJyXzEpO1xuICAgICAgICAgICAgKDAsICQyNTc5NDdlOTI5MjYyNzdhJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkpLmxvZyhcIkZhaWxlZCB0byBjcmVhdGVPZmZlciwgXCIsIGVycl8xKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBfbWFrZUFuc3dlcigpIHtcbiAgICAgICAgY29uc3QgcGVlckNvbm5lY3Rpb24gPSB0aGlzLmNvbm5lY3Rpb24ucGVlckNvbm5lY3Rpb247XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gdGhpcy5jb25uZWN0aW9uLnByb3ZpZGVyO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgYW5zd2VyID0gYXdhaXQgcGVlckNvbm5lY3Rpb24uY3JlYXRlQW5zd2VyKCk7XG4gICAgICAgICAgICAoMCwgJDI1Nzk0N2U5MjkyNjI3N2EkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOSkubG9nKFwiQ3JlYXRlZCBhbnN3ZXIuXCIpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29ubmVjdGlvbi5vcHRpb25zLnNkcFRyYW5zZm9ybSAmJiB0eXBlb2YgdGhpcy5jb25uZWN0aW9uLm9wdGlvbnMuc2RwVHJhbnNmb3JtID09PSBcImZ1bmN0aW9uXCIpIGFuc3dlci5zZHAgPSB0aGlzLmNvbm5lY3Rpb24ub3B0aW9ucy5zZHBUcmFuc2Zvcm0oYW5zd2VyLnNkcCkgfHwgYW5zd2VyLnNkcDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgcGVlckNvbm5lY3Rpb24uc2V0TG9jYWxEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICAgICAgICAgICgwLCAkMjU3OTQ3ZTkyOTI2Mjc3YSRleHBvcnQkMmUyYmNkODczOWFlMDM5KS5sb2coYFNldCBsb2NhbERlc2NyaXB0aW9uOmAsIGFuc3dlciwgYGZvcjoke3RoaXMuY29ubmVjdGlvbi5wZWVyfWApO1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyLnNvY2tldC5zZW5kKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogKDAsICQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydCRhZGI0YTE3NTRkYTZmMTBkKS5BbnN3ZXIsXG4gICAgICAgICAgICAgICAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNkcDogYW5zd2VyLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogdGhpcy5jb25uZWN0aW9uLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uSWQ6IHRoaXMuY29ubmVjdGlvbi5jb25uZWN0aW9uSWRcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZHN0OiB0aGlzLmNvbm5lY3Rpb24ucGVlclxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcHJvdmlkZXIuZW1pdEVycm9yKCgwLCAkNzg0NTVlMjJkZWE5NmI4YyRleHBvcnQkOTU0N2FhYTJlMzkwMzBmZikuV2ViUlRDLCBlcnIpO1xuICAgICAgICAgICAgICAgICgwLCAkMjU3OTQ3ZTkyOTI2Mjc3YSRleHBvcnQkMmUyYmNkODczOWFlMDM5KS5sb2coXCJGYWlsZWQgdG8gc2V0TG9jYWxEZXNjcmlwdGlvbiwgXCIsIGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycl8xKSB7XG4gICAgICAgICAgICBwcm92aWRlci5lbWl0RXJyb3IoKDAsICQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydCQ5NTQ3YWFhMmUzOTAzMGZmKS5XZWJSVEMsIGVycl8xKTtcbiAgICAgICAgICAgICgwLCAkMjU3OTQ3ZTkyOTI2Mjc3YSRleHBvcnQkMmUyYmNkODczOWFlMDM5KS5sb2coXCJGYWlsZWQgdG8gY3JlYXRlIGFuc3dlciwgXCIsIGVycl8xKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogSGFuZGxlIGFuIFNEUC4gKi8gYXN5bmMgaGFuZGxlU0RQKHR5cGUsIHNkcCkge1xuICAgICAgICBzZHAgPSBuZXcgUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKHNkcCk7XG4gICAgICAgIGNvbnN0IHBlZXJDb25uZWN0aW9uID0gdGhpcy5jb25uZWN0aW9uLnBlZXJDb25uZWN0aW9uO1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IHRoaXMuY29ubmVjdGlvbi5wcm92aWRlcjtcbiAgICAgICAgKDAsICQyNTc5NDdlOTI5MjYyNzdhJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkpLmxvZyhcIlNldHRpbmcgcmVtb3RlIGRlc2NyaXB0aW9uXCIsIHNkcCk7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgcGVlckNvbm5lY3Rpb24uc2V0UmVtb3RlRGVzY3JpcHRpb24oc2RwKTtcbiAgICAgICAgICAgICgwLCAkMjU3OTQ3ZTkyOTI2Mjc3YSRleHBvcnQkMmUyYmNkODczOWFlMDM5KS5sb2coYFNldCByZW1vdGVEZXNjcmlwdGlvbjoke3R5cGV9IGZvcjoke3RoaXMuY29ubmVjdGlvbi5wZWVyfWApO1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwiT0ZGRVJcIikgYXdhaXQgc2VsZi5fbWFrZUFuc3dlcigpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHByb3ZpZGVyLmVtaXRFcnJvcigoMCwgJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JDk1NDdhYWEyZTM5MDMwZmYpLldlYlJUQywgZXJyKTtcbiAgICAgICAgICAgICgwLCAkMjU3OTQ3ZTkyOTI2Mjc3YSRleHBvcnQkMmUyYmNkODczOWFlMDM5KS5sb2coXCJGYWlsZWQgdG8gc2V0UmVtb3RlRGVzY3JpcHRpb24sIFwiLCBlcnIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBIYW5kbGUgYSBjYW5kaWRhdGUuICovIGFzeW5jIGhhbmRsZUNhbmRpZGF0ZShpY2UpIHtcbiAgICAgICAgKDAsICQyNTc5NDdlOTI5MjYyNzdhJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkpLmxvZyhgaGFuZGxlQ2FuZGlkYXRlOmAsIGljZSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmNvbm5lY3Rpb24ucGVlckNvbm5lY3Rpb24uYWRkSWNlQ2FuZGlkYXRlKGljZSk7XG4gICAgICAgICAgICAoMCwgJDI1Nzk0N2U5MjkyNjI3N2EkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOSkubG9nKGBBZGRlZCBJQ0UgY2FuZGlkYXRlIGZvcjoke3RoaXMuY29ubmVjdGlvbi5wZWVyfWApO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbi5wcm92aWRlci5lbWl0RXJyb3IoKDAsICQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydCQ5NTQ3YWFhMmUzOTAzMGZmKS5XZWJSVEMsIGVycik7XG4gICAgICAgICAgICAoMCwgJDI1Nzk0N2U5MjkyNjI3N2EkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOSkubG9nKFwiRmFpbGVkIHRvIGhhbmRsZUNhbmRpZGF0ZSwgXCIsIGVycik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2FkZFRyYWNrc1RvQ29ubmVjdGlvbihzdHJlYW0sIHBlZXJDb25uZWN0aW9uKSB7XG4gICAgICAgICgwLCAkMjU3OTQ3ZTkyOTI2Mjc3YSRleHBvcnQkMmUyYmNkODczOWFlMDM5KS5sb2coYGFkZCB0cmFja3MgZnJvbSBzdHJlYW0gJHtzdHJlYW0uaWR9IHRvIHBlZXIgY29ubmVjdGlvbmApO1xuICAgICAgICBpZiAoIXBlZXJDb25uZWN0aW9uLmFkZFRyYWNrKSByZXR1cm4gKDAsICQyNTc5NDdlOTI5MjYyNzdhJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkpLmVycm9yKGBZb3VyIGJyb3dzZXIgZG9lcyd0IHN1cHBvcnQgUlRDUGVlckNvbm5lY3Rpb24jYWRkVHJhY2suIElnbm9yZWQuYCk7XG4gICAgICAgIHN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKCh0cmFjayk9PntcbiAgICAgICAgICAgIHBlZXJDb25uZWN0aW9uLmFkZFRyYWNrKHRyYWNrLCBzdHJlYW0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2FkZFN0cmVhbVRvTWVkaWFDb25uZWN0aW9uKHN0cmVhbSwgbWVkaWFDb25uZWN0aW9uKSB7XG4gICAgICAgICgwLCAkMjU3OTQ3ZTkyOTI2Mjc3YSRleHBvcnQkMmUyYmNkODczOWFlMDM5KS5sb2coYGFkZCBzdHJlYW0gJHtzdHJlYW0uaWR9IHRvIG1lZGlhIGNvbm5lY3Rpb24gJHttZWRpYUNvbm5lY3Rpb24uY29ubmVjdGlvbklkfWApO1xuICAgICAgICBtZWRpYUNvbm5lY3Rpb24uYWRkU3RyZWFtKHN0cmVhbSk7XG4gICAgfVxufVxuXG5cblxuXG5cbmNsYXNzICQyMzc3OWQxODgxMTU3YTE4JGV4cG9ydCQ2YTY3OGU1ODljOGE0NTQyIGV4dGVuZHMgKDAsICRjNGRjZmQxZDFlYTg2NjQ3JGV4cG9ydHMuRXZlbnRFbWl0dGVyKSB7XG4gICAgLyoqXG5cdCAqIEVtaXRzIGEgdHlwZWQgZXJyb3IgbWVzc2FnZS5cblx0ICpcblx0ICogQGludGVybmFsXG5cdCAqLyBlbWl0RXJyb3IodHlwZSwgZXJyKSB7XG4gICAgICAgICgwLCAkMjU3OTQ3ZTkyOTI2Mjc3YSRleHBvcnQkMmUyYmNkODczOWFlMDM5KS5lcnJvcihcIkVycm9yOlwiLCBlcnIpO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHRoaXMuZW1pdChcImVycm9yXCIsIG5ldyAkMjM3NzlkMTg4MTE1N2ExOCRleHBvcnQkOTg4NzE4ODJmNDkyZGU4MihgJHt0eXBlfWAsIGVycikpO1xuICAgIH1cbn1cbmNsYXNzICQyMzc3OWQxODgxMTU3YTE4JGV4cG9ydCQ5ODg3MTg4MmY0OTJkZTgyIGV4dGVuZHMgRXJyb3Ige1xuICAgIC8qKlxuXHQgKiBAaW50ZXJuYWxcblx0ICovIGNvbnN0cnVjdG9yKHR5cGUsIGVycil7XG4gICAgICAgIGlmICh0eXBlb2YgZXJyID09PSBcInN0cmluZ1wiKSBzdXBlcihlcnIpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN1cGVyKCk7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIGVycik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB9XG59XG5cblxuY2xhc3MgJDUwNDUxOTJmYzZkMzg3YmEkZXhwb3J0JDIzYTJhNjgyODNjMjRkODAgZXh0ZW5kcyAoMCwgJDIzNzc5ZDE4ODExNTdhMTgkZXhwb3J0JDZhNjc4ZTU4OWM4YTQ1NDIpIHtcbiAgICAvKipcblx0ICogV2hldGhlciB0aGUgbWVkaWEgY29ubmVjdGlvbiBpcyBhY3RpdmUgKGUuZy4geW91ciBjYWxsIGhhcyBiZWVuIGFuc3dlcmVkKS5cblx0ICogWW91IGNhbiBjaGVjayB0aGlzIGlmIHlvdSB3YW50IHRvIHNldCBhIG1heGltdW0gd2FpdCB0aW1lIGZvciBhIG9uZS1zaWRlZCBjYWxsLlxuXHQgKi8gZ2V0IG9wZW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vcGVuO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcigvKipcblx0XHQgKiBUaGUgSUQgb2YgdGhlIHBlZXIgb24gdGhlIG90aGVyIGVuZCBvZiB0aGlzIGNvbm5lY3Rpb24uXG5cdFx0ICovIHBlZXIsIHByb3ZpZGVyLCBvcHRpb25zKXtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5wZWVyID0gcGVlcjtcbiAgICAgICAgdGhpcy5wcm92aWRlciA9IHByb3ZpZGVyO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLl9vcGVuID0gZmFsc2U7XG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBvcHRpb25zLm1ldGFkYXRhO1xuICAgIH1cbn1cblxuXG5jbGFzcyAkNWMxZDA4YzdjNTdkYTlhMyRleHBvcnQkNGE4NGU5NWEyMzI0YWMyOSBleHRlbmRzICgwLCAkNTA0NTE5MmZjNmQzODdiYSRleHBvcnQkMjNhMmE2ODI4M2MyNGQ4MCkge1xuICAgIHN0YXRpYyAjXyA9IHRoaXMuSURfUFJFRklYID0gXCJtY19cIjtcbiAgICAvKipcblx0ICogRm9yIG1lZGlhIGNvbm5lY3Rpb25zLCB0aGlzIGlzIGFsd2F5cyAnbWVkaWEnLlxuXHQgKi8gZ2V0IHR5cGUoKSB7XG4gICAgICAgIHJldHVybiAoMCwgJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JDMxNTdkNTdiNDEzNWUzYmMpLk1lZGlhO1xuICAgIH1cbiAgICBnZXQgbG9jYWxTdHJlYW0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2NhbFN0cmVhbTtcbiAgICB9XG4gICAgZ2V0IHJlbW90ZVN0cmVhbSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlbW90ZVN0cmVhbTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IocGVlcklkLCBwcm92aWRlciwgb3B0aW9ucyl7XG4gICAgICAgIHN1cGVyKHBlZXJJZCwgcHJvdmlkZXIsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9sb2NhbFN0cmVhbSA9IHRoaXMub3B0aW9ucy5fc3RyZWFtO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb25JZCA9IHRoaXMub3B0aW9ucy5jb25uZWN0aW9uSWQgfHwgJDVjMWQwOGM3YzU3ZGE5YTMkZXhwb3J0JDRhODRlOTVhMjMyNGFjMjkuSURfUFJFRklYICsgKDAsICQ0ZjQxMzQxNTZjNDQ2MzkyJGV4cG9ydCQ3ZGViYjUwZWYxMWQ1ZTBiKS5yYW5kb21Ub2tlbigpO1xuICAgICAgICB0aGlzLl9uZWdvdGlhdG9yID0gbmV3ICgwLCAkYjgyZmI4ZmMwNTE0YmZjMSRleHBvcnQkODllNmJiNWFkNjRiZjRhKSh0aGlzKTtcbiAgICAgICAgaWYgKHRoaXMuX2xvY2FsU3RyZWFtKSB0aGlzLl9uZWdvdGlhdG9yLnN0YXJ0Q29ubmVjdGlvbih7XG4gICAgICAgICAgICBfc3RyZWFtOiB0aGlzLl9sb2NhbFN0cmVhbSxcbiAgICAgICAgICAgIG9yaWdpbmF0b3I6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKiBDYWxsZWQgYnkgdGhlIE5lZ290aWF0b3Igd2hlbiB0aGUgRGF0YUNoYW5uZWwgaXMgcmVhZHkuICovIF9pbml0aWFsaXplRGF0YUNoYW5uZWwoZGMpIHtcbiAgICAgICAgdGhpcy5kYXRhQ2hhbm5lbCA9IGRjO1xuICAgICAgICB0aGlzLmRhdGFDaGFubmVsLm9ub3BlbiA9ICgpPT57XG4gICAgICAgICAgICAoMCwgJDI1Nzk0N2U5MjkyNjI3N2EkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOSkubG9nKGBEQyMke3RoaXMuY29ubmVjdGlvbklkfSBkYyBjb25uZWN0aW9uIHN1Y2Nlc3NgKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcIndpbGxDbG9zZU9uUmVtb3RlXCIpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmRhdGFDaGFubmVsLm9uY2xvc2UgPSAoKT0+e1xuICAgICAgICAgICAgKDAsICQyNTc5NDdlOTI5MjYyNzdhJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkpLmxvZyhgREMjJHt0aGlzLmNvbm5lY3Rpb25JZH0gZGMgY2xvc2VkIGZvcjpgLCB0aGlzLnBlZXIpO1xuICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBhZGRTdHJlYW0ocmVtb3RlU3RyZWFtKSB7XG4gICAgICAgICgwLCAkMjU3OTQ3ZTkyOTI2Mjc3YSRleHBvcnQkMmUyYmNkODczOWFlMDM5KS5sb2coXCJSZWNlaXZpbmcgc3RyZWFtXCIsIHJlbW90ZVN0cmVhbSk7XG4gICAgICAgIHRoaXMuX3JlbW90ZVN0cmVhbSA9IHJlbW90ZVN0cmVhbTtcbiAgICAgICAgc3VwZXIuZW1pdChcInN0cmVhbVwiLCByZW1vdGVTdHJlYW0pOyAvLyBTaG91bGQgd2UgY2FsbCB0aGlzIGBvcGVuYD9cbiAgICB9XG4gICAgLyoqXG5cdCAqIEBpbnRlcm5hbFxuXHQgKi8gaGFuZGxlTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSBtZXNzYWdlLnR5cGU7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSBtZXNzYWdlLnBheWxvYWQ7XG4gICAgICAgIHN3aXRjaChtZXNzYWdlLnR5cGUpe1xuICAgICAgICAgICAgY2FzZSAoMCwgJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JGFkYjRhMTc1NGRhNmYxMGQpLkFuc3dlcjpcbiAgICAgICAgICAgICAgICAvLyBGb3J3YXJkIHRvIG5lZ290aWF0b3JcbiAgICAgICAgICAgICAgICB0aGlzLl9uZWdvdGlhdG9yLmhhbmRsZVNEUCh0eXBlLCBwYXlsb2FkLnNkcCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fb3BlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICgwLCAkNzg0NTVlMjJkZWE5NmI4YyRleHBvcnQkYWRiNGExNzU0ZGE2ZjEwZCkuQ2FuZGlkYXRlOlxuICAgICAgICAgICAgICAgIHRoaXMuX25lZ290aWF0b3IuaGFuZGxlQ2FuZGlkYXRlKHBheWxvYWQuY2FuZGlkYXRlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgKDAsICQyNTc5NDdlOTI5MjYyNzdhJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkpLndhcm4oYFVucmVjb2duaXplZCBtZXNzYWdlIHR5cGU6JHt0eXBlfSBmcm9tIHBlZXI6JHt0aGlzLnBlZXJ9YCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogV2hlbiByZWNlaXZpbmcgYSB7QGFwaWxpbmsgUGVlckV2ZW50cyB8IGBjYWxsYH0gZXZlbnQgb24gYSBwZWVyLCB5b3UgY2FuIGNhbGxcbiAgICAgKiBgYW5zd2VyYCBvbiB0aGUgbWVkaWEgY29ubmVjdGlvbiBwcm92aWRlZCBieSB0aGUgY2FsbGJhY2sgdG8gYWNjZXB0IHRoZSBjYWxsXG4gICAgICogYW5kIG9wdGlvbmFsbHkgc2VuZCB5b3VyIG93biBtZWRpYSBzdHJlYW0uXG5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdHJlYW0gQSBXZWJSVEMgbWVkaWEgc3RyZWFtLlxuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICogQHJldHVybnNcbiAgICAgKi8gYW5zd2VyKHN0cmVhbSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGlmICh0aGlzLl9sb2NhbFN0cmVhbSkge1xuICAgICAgICAgICAgKDAsICQyNTc5NDdlOTI5MjYyNzdhJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkpLndhcm4oXCJMb2NhbCBzdHJlYW0gYWxyZWFkeSBleGlzdHMgb24gdGhpcyBNZWRpYUNvbm5lY3Rpb24uIEFyZSB5b3UgYW5zd2VyaW5nIGEgY2FsbCB0d2ljZT9cIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbG9jYWxTdHJlYW0gPSBzdHJlYW07XG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuc2RwVHJhbnNmb3JtKSB0aGlzLm9wdGlvbnMuc2RwVHJhbnNmb3JtID0gb3B0aW9ucy5zZHBUcmFuc2Zvcm07XG4gICAgICAgIHRoaXMuX25lZ290aWF0b3Iuc3RhcnRDb25uZWN0aW9uKHtcbiAgICAgICAgICAgIC4uLnRoaXMub3B0aW9ucy5fcGF5bG9hZCxcbiAgICAgICAgICAgIF9zdHJlYW06IHN0cmVhbVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gUmV0cmlldmUgbG9zdCBtZXNzYWdlcyBzdG9yZWQgYmVjYXVzZSBQZWVyQ29ubmVjdGlvbiBub3Qgc2V0IHVwLlxuICAgICAgICBjb25zdCBtZXNzYWdlcyA9IHRoaXMucHJvdmlkZXIuX2dldE1lc3NhZ2VzKHRoaXMuY29ubmVjdGlvbklkKTtcbiAgICAgICAgZm9yIChjb25zdCBtZXNzYWdlIG9mIG1lc3NhZ2VzKXRoaXMuaGFuZGxlTWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5fb3BlbiA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuXHQgKiBFeHBvc2VkIGZ1bmN0aW9uYWxpdHkgZm9yIHVzZXJzLlxuXHQgKi8gLyoqXG5cdCAqIENsb3NlcyB0aGUgbWVkaWEgY29ubmVjdGlvbi5cblx0ICovIGNsb3NlKCkge1xuICAgICAgICBpZiAodGhpcy5fbmVnb3RpYXRvcikge1xuICAgICAgICAgICAgdGhpcy5fbmVnb3RpYXRvci5jbGVhbnVwKCk7XG4gICAgICAgICAgICB0aGlzLl9uZWdvdGlhdG9yID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sb2NhbFN0cmVhbSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3JlbW90ZVN0cmVhbSA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLnByb3ZpZGVyKSB7XG4gICAgICAgICAgICB0aGlzLnByb3ZpZGVyLl9yZW1vdmVDb25uZWN0aW9uKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5wcm92aWRlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMuX3N0cmVhbSkgdGhpcy5vcHRpb25zLl9zdHJlYW0gPSBudWxsO1xuICAgICAgICBpZiAoIXRoaXMub3BlbikgcmV0dXJuO1xuICAgICAgICB0aGlzLl9vcGVuID0gZmFsc2U7XG4gICAgICAgIHN1cGVyLmVtaXQoXCJjbG9zZVwiKTtcbiAgICB9XG59XG5cblxuXG5cblxuXG5jbGFzcyAkYWJmMjY2NjQxOTI3Y2Q4OSRleHBvcnQkMmM0ZTgyNWRjOTEyMGY4NyB7XG4gICAgY29uc3RydWN0b3IoX29wdGlvbnMpe1xuICAgICAgICB0aGlzLl9vcHRpb25zID0gX29wdGlvbnM7XG4gICAgfVxuICAgIF9idWlsZFJlcXVlc3QobWV0aG9kKSB7XG4gICAgICAgIGNvbnN0IHByb3RvY29sID0gdGhpcy5fb3B0aW9ucy5zZWN1cmUgPyBcImh0dHBzXCIgOiBcImh0dHBcIjtcbiAgICAgICAgY29uc3QgeyBob3N0OiBob3N0LCBwb3J0OiBwb3J0LCBwYXRoOiBwYXRoLCBrZXk6IGtleSB9ID0gdGhpcy5fb3B0aW9ucztcbiAgICAgICAgY29uc3QgdXJsID0gbmV3IFVSTChgJHtwcm90b2NvbH06Ly8ke2hvc3R9OiR7cG9ydH0ke3BhdGh9JHtrZXl9LyR7bWV0aG9kfWApO1xuICAgICAgICAvLyBUT0RPOiBXaHkgdGltZXN0YW1wLCB3aHkgcmFuZG9tP1xuICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldChcInRzXCIsIGAke0RhdGUubm93KCl9JHtNYXRoLnJhbmRvbSgpfWApO1xuICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldChcInZlcnNpb25cIiwgKDAsICRmNWY4ODFlYzQ1NzVmMWZjJGV4cG9ydHMudmVyc2lvbikpO1xuICAgICAgICByZXR1cm4gZmV0Y2godXJsLmhyZWYsIHtcbiAgICAgICAgICAgIHJlZmVycmVyUG9saWN5OiB0aGlzLl9vcHRpb25zLnJlZmVycmVyUG9saWN5XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKiogR2V0IGEgdW5pcXVlIElEIGZyb20gdGhlIHNlcnZlciB2aWEgWEhSIGFuZCBpbml0aWFsaXplIHdpdGggaXQuICovIGFzeW5jIHJldHJpZXZlSWQoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX2J1aWxkUmVxdWVzdChcImlkXCIpO1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyAhPT0gMjAwKSB0aHJvdyBuZXcgRXJyb3IoYEVycm9yLiBTdGF0dXM6JHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgKDAsICQyNTc5NDdlOTI5MjYyNzdhJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkpLmVycm9yKFwiRXJyb3IgcmV0cmlldmluZyBJRFwiLCBlcnJvcik7XG4gICAgICAgICAgICBsZXQgcGF0aEVycm9yID0gXCJcIjtcbiAgICAgICAgICAgIGlmICh0aGlzLl9vcHRpb25zLnBhdGggPT09IFwiL1wiICYmIHRoaXMuX29wdGlvbnMuaG9zdCAhPT0gKDAsICQ0ZjQxMzQxNTZjNDQ2MzkyJGV4cG9ydCQ3ZGViYjUwZWYxMWQ1ZTBiKS5DTE9VRF9IT1NUKSBwYXRoRXJyb3IgPSBcIiBJZiB5b3UgcGFzc2VkIGluIGEgYHBhdGhgIHRvIHlvdXIgc2VsZi1ob3N0ZWQgUGVlclNlcnZlciwgeW91J2xsIGFsc28gbmVlZCB0byBwYXNzIGluIHRoYXQgc2FtZSBwYXRoIHdoZW4gY3JlYXRpbmcgYSBuZXcgUGVlci5cIjtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBnZXQgYW4gSUQgZnJvbSB0aGUgc2VydmVyLlwiICsgcGF0aEVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogQGRlcHJlY2F0ZWQgKi8gYXN5bmMgbGlzdEFsbFBlZXJzKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9idWlsZFJlcXVlc3QoXCJwZWVyc1wiKTtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwMSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaGVscGZ1bEVycm9yID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMuaG9zdCA9PT0gKDAsICQ0ZjQxMzQxNTZjNDQ2MzkyJGV4cG9ydCQ3ZGViYjUwZWYxMWQ1ZTBiKS5DTE9VRF9IT1NUKSBoZWxwZnVsRXJyb3IgPSBcIkl0IGxvb2tzIGxpa2UgeW91J3JlIHVzaW5nIHRoZSBjbG91ZCBzZXJ2ZXIuIFlvdSBjYW4gZW1haWwgdGVhbUBwZWVyanMuY29tIHRvIGVuYWJsZSBwZWVyIGxpc3RpbmcgZm9yIHlvdXIgQVBJIGtleS5cIjtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBoZWxwZnVsRXJyb3IgPSBcIllvdSBuZWVkIHRvIGVuYWJsZSBgYWxsb3dfZGlzY292ZXJ5YCBvbiB5b3VyIHNlbGYtaG9zdGVkIFBlZXJTZXJ2ZXIgdG8gdXNlIHRoaXMgZmVhdHVyZS5cIjtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSXQgZG9lc24ndCBsb29rIGxpa2UgeW91IGhhdmUgcGVybWlzc2lvbiB0byBsaXN0IHBlZXJzIElEcy4gXCIgKyBoZWxwZnVsRXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yLiBTdGF0dXM6JHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgKDAsICQyNTc5NDdlOTI5MjYyNzdhJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkpLmVycm9yKFwiRXJyb3IgcmV0cmlldmluZyBsaXN0IHBlZXJzXCIsIGVycm9yKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBnZXQgbGlzdCBwZWVycyBmcm9tIHRoZSBzZXJ2ZXIuXCIgKyBlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG59XG5cblxuXG5cblxuXG5cblxuXG5cbmNsYXNzICQ2MzY2YzRjYTE2MWJjMjk3JGV4cG9ydCRkMzY1ZjdhZDlkN2RmOWM5IGV4dGVuZHMgKDAsICQ1MDQ1MTkyZmM2ZDM4N2JhJGV4cG9ydCQyM2EyYTY4MjgzYzI0ZDgwKSB7XG4gICAgc3RhdGljICNfID0gdGhpcy5JRF9QUkVGSVggPSBcImRjX1wiO1xuICAgIHN0YXRpYyAjXzIgPSB0aGlzLk1BWF9CVUZGRVJFRF9BTU9VTlQgPSA4Mzg4NjA4O1xuICAgIGdldCB0eXBlKCkge1xuICAgICAgICByZXR1cm4gKDAsICQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydCQzMTU3ZDU3YjQxMzVlM2JjKS5EYXRhO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihwZWVySWQsIHByb3ZpZGVyLCBvcHRpb25zKXtcbiAgICAgICAgc3VwZXIocGVlcklkLCBwcm92aWRlciwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbklkID0gdGhpcy5vcHRpb25zLmNvbm5lY3Rpb25JZCB8fCAkNjM2NmM0Y2ExNjFiYzI5NyRleHBvcnQkZDM2NWY3YWQ5ZDdkZjljOS5JRF9QUkVGSVggKyAoMCwgJDBlNWZkMTU4NTc4NGMyNTIkZXhwb3J0JDRlNjFmNjcyOTM2YmVjNzcpKCk7XG4gICAgICAgIHRoaXMubGFiZWwgPSB0aGlzLm9wdGlvbnMubGFiZWwgfHwgdGhpcy5jb25uZWN0aW9uSWQ7XG4gICAgICAgIHRoaXMucmVsaWFibGUgPSAhIXRoaXMub3B0aW9ucy5yZWxpYWJsZTtcbiAgICAgICAgdGhpcy5fbmVnb3RpYXRvciA9IG5ldyAoMCwgJGI4MmZiOGZjMDUxNGJmYzEkZXhwb3J0JDg5ZTZiYjVhZDY0YmY0YSkodGhpcyk7XG4gICAgICAgIHRoaXMuX25lZ290aWF0b3Iuc3RhcnRDb25uZWN0aW9uKHRoaXMub3B0aW9ucy5fcGF5bG9hZCB8fCB7XG4gICAgICAgICAgICBvcmlnaW5hdG9yOiB0cnVlLFxuICAgICAgICAgICAgcmVsaWFibGU6IHRoaXMucmVsaWFibGVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKiBDYWxsZWQgYnkgdGhlIE5lZ290aWF0b3Igd2hlbiB0aGUgRGF0YUNoYW5uZWwgaXMgcmVhZHkuICovIF9pbml0aWFsaXplRGF0YUNoYW5uZWwoZGMpIHtcbiAgICAgICAgdGhpcy5kYXRhQ2hhbm5lbCA9IGRjO1xuICAgICAgICB0aGlzLmRhdGFDaGFubmVsLm9ub3BlbiA9ICgpPT57XG4gICAgICAgICAgICAoMCwgJDI1Nzk0N2U5MjkyNjI3N2EkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOSkubG9nKGBEQyMke3RoaXMuY29ubmVjdGlvbklkfSBkYyBjb25uZWN0aW9uIHN1Y2Nlc3NgKTtcbiAgICAgICAgICAgIHRoaXMuX29wZW4gPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwib3BlblwiKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kYXRhQ2hhbm5lbC5vbm1lc3NhZ2UgPSAoZSk9PntcbiAgICAgICAgICAgICgwLCAkMjU3OTQ3ZTkyOTI2Mjc3YSRleHBvcnQkMmUyYmNkODczOWFlMDM5KS5sb2coYERDIyR7dGhpcy5jb25uZWN0aW9uSWR9IGRjIG9ubWVzc2FnZTpgLCBlLmRhdGEpO1xuICAgICAgICAvLyB0aGlzLl9oYW5kbGVEYXRhTWVzc2FnZShlKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kYXRhQ2hhbm5lbC5vbmNsb3NlID0gKCk9PntcbiAgICAgICAgICAgICgwLCAkMjU3OTQ3ZTkyOTI2Mjc3YSRleHBvcnQkMmUyYmNkODczOWFlMDM5KS5sb2coYERDIyR7dGhpcy5jb25uZWN0aW9uSWR9IGRjIGNsb3NlZCBmb3I6YCwgdGhpcy5wZWVyKTtcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG5cdCAqIEV4cG9zZWQgZnVuY3Rpb25hbGl0eSBmb3IgdXNlcnMuXG5cdCAqLyAvKiogQWxsb3dzIHVzZXIgdG8gY2xvc2UgY29ubmVjdGlvbi4gKi8gY2xvc2Uob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucz8uZmx1c2gpIHtcbiAgICAgICAgICAgIHRoaXMuc2VuZCh7XG4gICAgICAgICAgICAgICAgX19wZWVyRGF0YToge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImNsb3NlXCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fbmVnb3RpYXRvcikge1xuICAgICAgICAgICAgdGhpcy5fbmVnb3RpYXRvci5jbGVhbnVwKCk7XG4gICAgICAgICAgICB0aGlzLl9uZWdvdGlhdG9yID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wcm92aWRlcikge1xuICAgICAgICAgICAgdGhpcy5wcm92aWRlci5fcmVtb3ZlQ29ubmVjdGlvbih0aGlzKTtcbiAgICAgICAgICAgIHRoaXMucHJvdmlkZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRhdGFDaGFubmVsKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGFDaGFubmVsLm9ub3BlbiA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmRhdGFDaGFubmVsLm9ubWVzc2FnZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmRhdGFDaGFubmVsLm9uY2xvc2UgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5kYXRhQ2hhbm5lbCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLm9wZW4pIHJldHVybjtcbiAgICAgICAgdGhpcy5fb3BlbiA9IGZhbHNlO1xuICAgICAgICBzdXBlci5lbWl0KFwiY2xvc2VcIik7XG4gICAgfVxuICAgIC8qKiBBbGxvd3MgdXNlciB0byBzZW5kIGRhdGEuICovIHNlbmQoZGF0YSwgY2h1bmtlZCA9IGZhbHNlKSB7XG4gICAgICAgIGlmICghdGhpcy5vcGVuKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXRFcnJvcigoMCwgJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JDQ5YWU4MDBjMTE0ZGY0MWQpLk5vdE9wZW5ZZXQsIFwiQ29ubmVjdGlvbiBpcyBub3Qgb3Blbi4gWW91IHNob3VsZCBsaXN0ZW4gZm9yIHRoZSBgb3BlbmAgZXZlbnQgYmVmb3JlIHNlbmRpbmcgbWVzc2FnZXMuXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9zZW5kKGRhdGEsIGNodW5rZWQpO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IG1lc3NhZ2UucGF5bG9hZDtcbiAgICAgICAgc3dpdGNoKG1lc3NhZ2UudHlwZSl7XG4gICAgICAgICAgICBjYXNlICgwLCAkNzg0NTVlMjJkZWE5NmI4YyRleHBvcnQkYWRiNGExNzU0ZGE2ZjEwZCkuQW5zd2VyOlxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX25lZ290aWF0b3IuaGFuZGxlU0RQKG1lc3NhZ2UudHlwZSwgcGF5bG9hZC5zZHApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAoMCwgJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JGFkYjRhMTc1NGRhNmYxMGQpLkNhbmRpZGF0ZTpcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9uZWdvdGlhdG9yLmhhbmRsZUNhbmRpZGF0ZShwYXlsb2FkLmNhbmRpZGF0ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICgwLCAkMjU3OTQ3ZTkyOTI2Mjc3YSRleHBvcnQkMmUyYmNkODczOWFlMDM5KS53YXJuKFwiVW5yZWNvZ25pemVkIG1lc3NhZ2UgdHlwZTpcIiwgbWVzc2FnZS50eXBlLCBcImZyb20gcGVlcjpcIiwgdGhpcy5wZWVyKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbn1cblxuXG5jbGFzcyAkYTIyOWJlZGJjYWE2Y2EyMyRleHBvcnQkZmY3YzlkNGMxMWQ5NGU4YiBleHRlbmRzICgwLCAkNjM2NmM0Y2ExNjFiYzI5NyRleHBvcnQkZDM2NWY3YWQ5ZDdkZjljOSkge1xuICAgIGdldCBidWZmZXJTaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYnVmZmVyU2l6ZTtcbiAgICB9XG4gICAgX2luaXRpYWxpemVEYXRhQ2hhbm5lbChkYykge1xuICAgICAgICBzdXBlci5faW5pdGlhbGl6ZURhdGFDaGFubmVsKGRjKTtcbiAgICAgICAgdGhpcy5kYXRhQ2hhbm5lbC5iaW5hcnlUeXBlID0gXCJhcnJheWJ1ZmZlclwiO1xuICAgICAgICB0aGlzLmRhdGFDaGFubmVsLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIChlKT0+dGhpcy5faGFuZGxlRGF0YU1lc3NhZ2UoZSkpO1xuICAgIH1cbiAgICBfYnVmZmVyZWRTZW5kKG1zZykge1xuICAgICAgICBpZiAodGhpcy5fYnVmZmVyaW5nIHx8ICF0aGlzLl90cnlTZW5kKG1zZykpIHtcbiAgICAgICAgICAgIHRoaXMuX2J1ZmZlci5wdXNoKG1zZyk7XG4gICAgICAgICAgICB0aGlzLl9idWZmZXJTaXplID0gdGhpcy5fYnVmZmVyLmxlbmd0aDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBSZXR1cm5zIHRydWUgaWYgdGhlIHNlbmQgc3VjY2VlZHMuXG4gICAgX3RyeVNlbmQobXNnKSB7XG4gICAgICAgIGlmICghdGhpcy5vcGVuKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLmRhdGFDaGFubmVsLmJ1ZmZlcmVkQW1vdW50ID4gKDAsICQ2MzY2YzRjYTE2MWJjMjk3JGV4cG9ydCRkMzY1ZjdhZDlkN2RmOWM5KS5NQVhfQlVGRkVSRURfQU1PVU5UKSB7XG4gICAgICAgICAgICB0aGlzLl9idWZmZXJpbmcgPSB0cnVlO1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKT0+e1xuICAgICAgICAgICAgICAgIHRoaXMuX2J1ZmZlcmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RyeUJ1ZmZlcigpO1xuICAgICAgICAgICAgfSwgNTApO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmRhdGFDaGFubmVsLnNlbmQobXNnKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgKDAsICQyNTc5NDdlOTI5MjYyNzdhJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkpLmVycm9yKGBEQyM6JHt0aGlzLmNvbm5lY3Rpb25JZH0gRXJyb3Igd2hlbiBzZW5kaW5nOmAsIGUpO1xuICAgICAgICAgICAgdGhpcy5fYnVmZmVyaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gVHJ5IHRvIHNlbmQgdGhlIGZpcnN0IG1lc3NhZ2UgaW4gdGhlIGJ1ZmZlci5cbiAgICBfdHJ5QnVmZmVyKCkge1xuICAgICAgICBpZiAoIXRoaXMub3BlbikgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy5fYnVmZmVyLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgICAgICBjb25zdCBtc2cgPSB0aGlzLl9idWZmZXJbMF07XG4gICAgICAgIGlmICh0aGlzLl90cnlTZW5kKG1zZykpIHtcbiAgICAgICAgICAgIHRoaXMuX2J1ZmZlci5zaGlmdCgpO1xuICAgICAgICAgICAgdGhpcy5fYnVmZmVyU2l6ZSA9IHRoaXMuX2J1ZmZlci5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLl90cnlCdWZmZXIoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjbG9zZShvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zPy5mbHVzaCkge1xuICAgICAgICAgICAgdGhpcy5zZW5kKHtcbiAgICAgICAgICAgICAgICBfX3BlZXJEYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiY2xvc2VcIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2J1ZmZlciA9IFtdO1xuICAgICAgICB0aGlzLl9idWZmZXJTaXplID0gMDtcbiAgICAgICAgc3VwZXIuY2xvc2UoKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoLi4uYXJncyl7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgICAgICB0aGlzLl9idWZmZXIgPSBbXTtcbiAgICAgICAgdGhpcy5fYnVmZmVyU2l6ZSA9IDA7XG4gICAgICAgIHRoaXMuX2J1ZmZlcmluZyA9IGZhbHNlO1xuICAgIH1cbn1cblxuXG5cblxuY2xhc3MgJDlmY2ZkZGIzYWUxNDhmODgkZXhwb3J0JGYwYTVhNjRkNWJiMzcxMDggZXh0ZW5kcyAoMCwgJGEyMjliZWRiY2FhNmNhMjMkZXhwb3J0JGZmN2M5ZDRjMTFkOTRlOGIpIHtcbiAgICBjbG9zZShvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyLmNsb3NlKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9jaHVua2VkRGF0YSA9IHt9O1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihwZWVySWQsIHByb3ZpZGVyLCBvcHRpb25zKXtcbiAgICAgICAgc3VwZXIocGVlcklkLCBwcm92aWRlciwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuY2h1bmtlciA9IG5ldyAoMCwgJGZjYmNjNzUzOGE2Nzc2ZDUkZXhwb3J0JGYxYzVmNGM5Y2I5NTM5MGIpKCk7XG4gICAgICAgIHRoaXMuc2VyaWFsaXphdGlvbiA9ICgwLCAkNzg0NTVlMjJkZWE5NmI4YyRleHBvcnQkODlmNTA3Y2Y5ODZhOTQ3KS5CaW5hcnk7XG4gICAgICAgIHRoaXMuX2NodW5rZWREYXRhID0ge307XG4gICAgfVxuICAgIC8vIEhhbmRsZXMgYSBEYXRhQ2hhbm5lbCBtZXNzYWdlLlxuICAgIF9oYW5kbGVEYXRhTWVzc2FnZSh7IGRhdGE6IGRhdGEgfSkge1xuICAgICAgICBjb25zdCBkZXNlcmlhbGl6ZWREYXRhID0gKDAsICRnQ2NiWSR1bnBhY2spKGRhdGEpO1xuICAgICAgICAvLyBQZWVySlMgc3BlY2lmaWMgbWVzc2FnZVxuICAgICAgICBjb25zdCBwZWVyRGF0YSA9IGRlc2VyaWFsaXplZERhdGFbXCJfX3BlZXJEYXRhXCJdO1xuICAgICAgICBpZiAocGVlckRhdGEpIHtcbiAgICAgICAgICAgIGlmIChwZWVyRGF0YS50eXBlID09PSBcImNsb3NlXCIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2h1bmtlZCBkYXRhIC0tIHBpZWNlIHRoaW5ncyBiYWNrIHRvZ2V0aGVyLlxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgdGhpcy5faGFuZGxlQ2h1bmsoZGVzZXJpYWxpemVkRGF0YSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0KFwiZGF0YVwiLCBkZXNlcmlhbGl6ZWREYXRhKTtcbiAgICB9XG4gICAgX2hhbmRsZUNodW5rKGRhdGEpIHtcbiAgICAgICAgY29uc3QgaWQgPSBkYXRhLl9fcGVlckRhdGE7XG4gICAgICAgIGNvbnN0IGNodW5rSW5mbyA9IHRoaXMuX2NodW5rZWREYXRhW2lkXSB8fCB7XG4gICAgICAgICAgICBkYXRhOiBbXSxcbiAgICAgICAgICAgIGNvdW50OiAwLFxuICAgICAgICAgICAgdG90YWw6IGRhdGEudG90YWxcbiAgICAgICAgfTtcbiAgICAgICAgY2h1bmtJbmZvLmRhdGFbZGF0YS5uXSA9IG5ldyBVaW50OEFycmF5KGRhdGEuZGF0YSk7XG4gICAgICAgIGNodW5rSW5mby5jb3VudCsrO1xuICAgICAgICB0aGlzLl9jaHVua2VkRGF0YVtpZF0gPSBjaHVua0luZm87XG4gICAgICAgIGlmIChjaHVua0luZm8udG90YWwgPT09IGNodW5rSW5mby5jb3VudCkge1xuICAgICAgICAgICAgLy8gQ2xlYW4gdXAgYmVmb3JlIG1ha2luZyB0aGUgcmVjdXJzaXZlIGNhbGwgdG8gYF9oYW5kbGVEYXRhTWVzc2FnZWAuXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fY2h1bmtlZERhdGFbaWRdO1xuICAgICAgICAgICAgLy8gV2UndmUgcmVjZWl2ZWQgYWxsIHRoZSBjaHVua3MtLXRpbWUgdG8gY29uc3RydWN0IHRoZSBjb21wbGV0ZSBkYXRhLlxuICAgICAgICAgICAgLy8gY29uc3QgZGF0YSA9IG5ldyBCbG9iKGNodW5rSW5mby5kYXRhKTtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSAoMCwgJGZjYmNjNzUzOGE2Nzc2ZDUkZXhwb3J0JDUyYzg5ZWJjZGM0ZjUzZjIpKGNodW5rSW5mby5kYXRhKTtcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZURhdGFNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICBkYXRhOiBkYXRhXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfc2VuZChkYXRhLCBjaHVua2VkKSB7XG4gICAgICAgIGNvbnN0IGJsb2IgPSAoMCwgJGdDY2JZJHBhY2spKGRhdGEpO1xuICAgICAgICBpZiAoYmxvYiBpbnN0YW5jZW9mIFByb21pc2UpIHJldHVybiB0aGlzLl9zZW5kX2Jsb2IoYmxvYik7XG4gICAgICAgIGlmICghY2h1bmtlZCAmJiBibG9iLmJ5dGVMZW5ndGggPiB0aGlzLmNodW5rZXIuY2h1bmtlZE1UVSkge1xuICAgICAgICAgICAgdGhpcy5fc2VuZENodW5rcyhibG9iKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9idWZmZXJlZFNlbmQoYmxvYik7XG4gICAgfVxuICAgIGFzeW5jIF9zZW5kX2Jsb2IoYmxvYlByb21pc2UpIHtcbiAgICAgICAgY29uc3QgYmxvYiA9IGF3YWl0IGJsb2JQcm9taXNlO1xuICAgICAgICBpZiAoYmxvYi5ieXRlTGVuZ3RoID4gdGhpcy5jaHVua2VyLmNodW5rZWRNVFUpIHtcbiAgICAgICAgICAgIHRoaXMuX3NlbmRDaHVua3MoYmxvYik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYnVmZmVyZWRTZW5kKGJsb2IpO1xuICAgIH1cbiAgICBfc2VuZENodW5rcyhibG9iKSB7XG4gICAgICAgIGNvbnN0IGJsb2JzID0gdGhpcy5jaHVua2VyLmNodW5rKGJsb2IpO1xuICAgICAgICAoMCwgJDI1Nzk0N2U5MjkyNjI3N2EkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOSkubG9nKGBEQyMke3RoaXMuY29ubmVjdGlvbklkfSBUcnkgdG8gc2VuZCAke2Jsb2JzLmxlbmd0aH0gY2h1bmtzLi4uYCk7XG4gICAgICAgIGZvciAoY29uc3QgYmxvYiBvZiBibG9icyl0aGlzLnNlbmQoYmxvYiwgdHJ1ZSk7XG4gICAgfVxufVxuXG5cblxuXG5jbGFzcyAkYmJhZWUzZjE1ZjcxNDY2MyRleHBvcnQkNmY4OGZlNDdkMzJjOWM5NCBleHRlbmRzICgwLCAkYTIyOWJlZGJjYWE2Y2EyMyRleHBvcnQkZmY3YzlkNGMxMWQ5NGU4Yikge1xuICAgIF9oYW5kbGVEYXRhTWVzc2FnZSh7IGRhdGE6IGRhdGEgfSkge1xuICAgICAgICBzdXBlci5lbWl0KFwiZGF0YVwiLCBkYXRhKTtcbiAgICB9XG4gICAgX3NlbmQoZGF0YSwgX2NodW5rZWQpIHtcbiAgICAgICAgdGhpcy5fYnVmZmVyZWRTZW5kKGRhdGEpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKXtcbiAgICAgICAgc3VwZXIoLi4uYXJncyk7XG4gICAgICAgIHRoaXMuc2VyaWFsaXphdGlvbiA9ICgwLCAkNzg0NTVlMjJkZWE5NmI4YyRleHBvcnQkODlmNTA3Y2Y5ODZhOTQ3KS5Ob25lO1xuICAgIH1cbn1cblxuXG5cblxuXG5jbGFzcyAkODE3ZjkzMWUzZjkwOTZjZiRleHBvcnQkNDg4ODBhYzYzNWY0NzE4NiBleHRlbmRzICgwLCAkYTIyOWJlZGJjYWE2Y2EyMyRleHBvcnQkZmY3YzlkNGMxMWQ5NGU4Yikge1xuICAgIC8vIEhhbmRsZXMgYSBEYXRhQ2hhbm5lbCBtZXNzYWdlLlxuICAgIF9oYW5kbGVEYXRhTWVzc2FnZSh7IGRhdGE6IGRhdGEgfSkge1xuICAgICAgICBjb25zdCBkZXNlcmlhbGl6ZWREYXRhID0gdGhpcy5wYXJzZSh0aGlzLmRlY29kZXIuZGVjb2RlKGRhdGEpKTtcbiAgICAgICAgLy8gUGVlckpTIHNwZWNpZmljIG1lc3NhZ2VcbiAgICAgICAgY29uc3QgcGVlckRhdGEgPSBkZXNlcmlhbGl6ZWREYXRhW1wiX19wZWVyRGF0YVwiXTtcbiAgICAgICAgaWYgKHBlZXJEYXRhICYmIHBlZXJEYXRhLnR5cGUgPT09IFwiY2xvc2VcIikge1xuICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdChcImRhdGFcIiwgZGVzZXJpYWxpemVkRGF0YSk7XG4gICAgfVxuICAgIF9zZW5kKGRhdGEsIF9jaHVua2VkKSB7XG4gICAgICAgIGNvbnN0IGVuY29kZWREYXRhID0gdGhpcy5lbmNvZGVyLmVuY29kZSh0aGlzLnN0cmluZ2lmeShkYXRhKSk7XG4gICAgICAgIGlmIChlbmNvZGVkRGF0YS5ieXRlTGVuZ3RoID49ICgwLCAkNGY0MTM0MTU2YzQ0NjM5MiRleHBvcnQkN2RlYmI1MGVmMTFkNWUwYikuY2h1bmtlZE1UVSkge1xuICAgICAgICAgICAgdGhpcy5lbWl0RXJyb3IoKDAsICQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydCQ0OWFlODAwYzExNGRmNDFkKS5NZXNzYWdlVG9CaWcsIFwiTWVzc2FnZSB0b28gYmlnIGZvciBKU09OIGNoYW5uZWxcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYnVmZmVyZWRTZW5kKGVuY29kZWREYXRhKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoLi4uYXJncyl7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgICAgICB0aGlzLnNlcmlhbGl6YXRpb24gPSAoMCwgJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JDg5ZjUwN2NmOTg2YTk0NykuSlNPTjtcbiAgICAgICAgdGhpcy5lbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgICAgIHRoaXMuZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuICAgICAgICB0aGlzLnN0cmluZ2lmeSA9IEpTT04uc3RyaW5naWZ5O1xuICAgICAgICB0aGlzLnBhcnNlID0gSlNPTi5wYXJzZTtcbiAgICB9XG59XG5cblxuXG5jbGFzcyAkNDE2MjYwYmNlMzM3ZGY5MCR2YXIkUGVlck9wdGlvbnMge1xufVxuY2xhc3MgJDQxNjI2MGJjZTMzN2RmOTAkZXhwb3J0JGVjZDFmYzEzNmM0MjI0NDggZXh0ZW5kcyAoMCwgJDIzNzc5ZDE4ODExNTdhMTgkZXhwb3J0JDZhNjc4ZTU4OWM4YTQ1NDIpIHtcbiAgICBzdGF0aWMgI18gPSB0aGlzLkRFRkFVTFRfS0VZID0gXCJwZWVyanNcIjtcbiAgICAvKipcblx0ICogVGhlIGJyb2tlcmluZyBJRCBvZiB0aGlzIHBlZXJcblx0ICpcblx0ICogSWYgbm8gSUQgd2FzIHNwZWNpZmllZCBpbiB7QGFwaWxpbmsgUGVlciB8IHRoZSBjb25zdHJ1Y3Rvcn0sXG5cdCAqIHRoaXMgd2lsbCBiZSBgdW5kZWZpbmVkYCB1bnRpbCB0aGUge0BhcGlsaW5rIFBlZXJFdmVudHMgfCBgb3BlbmB9IGV2ZW50IGlzIGVtaXR0ZWQuXG5cdCAqLyBnZXQgaWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pZDtcbiAgICB9XG4gICAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vcHRpb25zO1xuICAgIH1cbiAgICBnZXQgb3BlbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29wZW47XG4gICAgfVxuICAgIC8qKlxuXHQgKiBAaW50ZXJuYWxcblx0ICovIGdldCBzb2NrZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zb2NrZXQ7XG4gICAgfVxuICAgIC8qKlxuXHQgKiBBIGhhc2ggb2YgYWxsIGNvbm5lY3Rpb25zIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHBlZXIsIGtleWVkIGJ5IHRoZSByZW1vdGUgcGVlcidzIElELlxuXHQgKiBAZGVwcmVjYXRlZFxuXHQgKiBSZXR1cm4gdHlwZSB3aWxsIGNoYW5nZSBmcm9tIE9iamVjdCB0byBNYXA8c3RyaW5nLFtdPlxuXHQgKi8gZ2V0IGNvbm5lY3Rpb25zKCkge1xuICAgICAgICBjb25zdCBwbGFpbkNvbm5lY3Rpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgZm9yIChjb25zdCBbaywgdl0gb2YgdGhpcy5fY29ubmVjdGlvbnMpcGxhaW5Db25uZWN0aW9uc1trXSA9IHY7XG4gICAgICAgIHJldHVybiBwbGFpbkNvbm5lY3Rpb25zO1xuICAgIH1cbiAgICAvKipcblx0ICogdHJ1ZSBpZiB0aGlzIHBlZXIgYW5kIGFsbCBvZiBpdHMgY29ubmVjdGlvbnMgY2FuIG5vIGxvbmdlciBiZSB1c2VkLlxuXHQgKi8gZ2V0IGRlc3Ryb3llZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Rlc3Ryb3llZDtcbiAgICB9XG4gICAgLyoqXG5cdCAqIGZhbHNlIGlmIHRoZXJlIGlzIGFuIGFjdGl2ZSBjb25uZWN0aW9uIHRvIHRoZSBQZWVyU2VydmVyLlxuXHQgKi8gZ2V0IGRpc2Nvbm5lY3RlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc2Nvbm5lY3RlZDtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoaWQsIG9wdGlvbnMpe1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl9zZXJpYWxpemVycyA9IHtcbiAgICAgICAgICAgIHJhdzogKDAsICRiYmFlZTNmMTVmNzE0NjYzJGV4cG9ydCQ2Zjg4ZmU0N2QzMmM5Yzk0KSxcbiAgICAgICAgICAgIGpzb246ICgwLCAkODE3ZjkzMWUzZjkwOTZjZiRleHBvcnQkNDg4ODBhYzYzNWY0NzE4NiksXG4gICAgICAgICAgICBiaW5hcnk6ICgwLCAkOWZjZmRkYjNhZTE0OGY4OCRleHBvcnQkZjBhNWE2NGQ1YmIzNzEwOCksXG4gICAgICAgICAgICBcImJpbmFyeS11dGY4XCI6ICgwLCAkOWZjZmRkYjNhZTE0OGY4OCRleHBvcnQkZjBhNWE2NGQ1YmIzNzEwOCksXG4gICAgICAgICAgICBkZWZhdWx0OiAoMCwgJDlmY2ZkZGIzYWUxNDhmODgkZXhwb3J0JGYwYTVhNjRkNWJiMzcxMDgpXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2lkID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbGFzdFNlcnZlcklkID0gbnVsbDtcbiAgICAgICAgLy8gU3RhdGVzLlxuICAgICAgICB0aGlzLl9kZXN0cm95ZWQgPSBmYWxzZSAvLyBDb25uZWN0aW9ucyBoYXZlIGJlZW4ga2lsbGVkXG4gICAgICAgIDtcbiAgICAgICAgdGhpcy5fZGlzY29ubmVjdGVkID0gZmFsc2UgLy8gQ29ubmVjdGlvbiB0byBQZWVyU2VydmVyIGtpbGxlZCBidXQgUDJQIGNvbm5lY3Rpb25zIHN0aWxsIGFjdGl2ZVxuICAgICAgICA7XG4gICAgICAgIHRoaXMuX29wZW4gPSBmYWxzZSAvLyBTb2NrZXRzIGFuZCBzdWNoIGFyZSBub3QgeWV0IG9wZW4uXG4gICAgICAgIDtcbiAgICAgICAgdGhpcy5fY29ubmVjdGlvbnMgPSBuZXcgTWFwKCkgLy8gQWxsIGNvbm5lY3Rpb25zIGZvciB0aGlzIHBlZXIuXG4gICAgICAgIDtcbiAgICAgICAgdGhpcy5fbG9zdE1lc3NhZ2VzID0gbmV3IE1hcCgpIC8vIHNyYyA9PiBbbGlzdCBvZiBtZXNzYWdlc11cbiAgICAgICAgO1xuICAgICAgICBsZXQgdXNlcklkO1xuICAgICAgICAvLyBEZWFsIHdpdGggb3ZlcmxvYWRpbmdcbiAgICAgICAgaWYgKGlkICYmIGlkLmNvbnN0cnVjdG9yID09IE9iamVjdCkgb3B0aW9ucyA9IGlkO1xuICAgICAgICBlbHNlIGlmIChpZCkgdXNlcklkID0gaWQudG9TdHJpbmcoKTtcbiAgICAgICAgLy8gQ29uZmlndXJpemUgb3B0aW9uc1xuICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgICAgZGVidWc6IDAsXG4gICAgICAgICAgICBob3N0OiAoMCwgJDRmNDEzNDE1NmM0NDYzOTIkZXhwb3J0JDdkZWJiNTBlZjExZDVlMGIpLkNMT1VEX0hPU1QsXG4gICAgICAgICAgICBwb3J0OiAoMCwgJDRmNDEzNDE1NmM0NDYzOTIkZXhwb3J0JDdkZWJiNTBlZjExZDVlMGIpLkNMT1VEX1BPUlQsXG4gICAgICAgICAgICBwYXRoOiBcIi9cIixcbiAgICAgICAgICAgIGtleTogJDQxNjI2MGJjZTMzN2RmOTAkZXhwb3J0JGVjZDFmYzEzNmM0MjI0NDguREVGQVVMVF9LRVksXG4gICAgICAgICAgICB0b2tlbjogKDAsICQ0ZjQxMzQxNTZjNDQ2MzkyJGV4cG9ydCQ3ZGViYjUwZWYxMWQ1ZTBiKS5yYW5kb21Ub2tlbigpLFxuICAgICAgICAgICAgY29uZmlnOiAoMCwgJDRmNDEzNDE1NmM0NDYzOTIkZXhwb3J0JDdkZWJiNTBlZjExZDVlMGIpLmRlZmF1bHRDb25maWcsXG4gICAgICAgICAgICByZWZlcnJlclBvbGljeTogXCJzdHJpY3Qtb3JpZ2luLXdoZW4tY3Jvc3Mtb3JpZ2luXCIsXG4gICAgICAgICAgICBzZXJpYWxpemVyczoge30sXG4gICAgICAgICAgICAuLi5vcHRpb25zXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLl9zZXJpYWxpemVycyA9IHtcbiAgICAgICAgICAgIC4uLnRoaXMuX3NlcmlhbGl6ZXJzLFxuICAgICAgICAgICAgLi4udGhpcy5vcHRpb25zLnNlcmlhbGl6ZXJzXG4gICAgICAgIH07XG4gICAgICAgIC8vIERldGVjdCByZWxhdGl2ZSBVUkwgaG9zdC5cbiAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMuaG9zdCA9PT0gXCIvXCIpIHRoaXMuX29wdGlvbnMuaG9zdCA9IHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZTtcbiAgICAgICAgLy8gU2V0IHBhdGggY29ycmVjdGx5LlxuICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy5wYXRoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy5wYXRoWzBdICE9PSBcIi9cIikgdGhpcy5fb3B0aW9ucy5wYXRoID0gXCIvXCIgKyB0aGlzLl9vcHRpb25zLnBhdGg7XG4gICAgICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy5wYXRoW3RoaXMuX29wdGlvbnMucGF0aC5sZW5ndGggLSAxXSAhPT0gXCIvXCIpIHRoaXMuX29wdGlvbnMucGF0aCArPSBcIi9cIjtcbiAgICAgICAgfVxuICAgICAgICAvLyBTZXQgd2hldGhlciB3ZSB1c2UgU1NMIHRvIHNhbWUgYXMgY3VycmVudCBob3N0XG4gICAgICAgIGlmICh0aGlzLl9vcHRpb25zLnNlY3VyZSA9PT0gdW5kZWZpbmVkICYmIHRoaXMuX29wdGlvbnMuaG9zdCAhPT0gKDAsICQ0ZjQxMzQxNTZjNDQ2MzkyJGV4cG9ydCQ3ZGViYjUwZWYxMWQ1ZTBiKS5DTE9VRF9IT1NUKSB0aGlzLl9vcHRpb25zLnNlY3VyZSA9ICgwLCAkNGY0MTM0MTU2YzQ0NjM5MiRleHBvcnQkN2RlYmI1MGVmMTFkNWUwYikuaXNTZWN1cmUoKTtcbiAgICAgICAgZWxzZSBpZiAodGhpcy5fb3B0aW9ucy5ob3N0ID09ICgwLCAkNGY0MTM0MTU2YzQ0NjM5MiRleHBvcnQkN2RlYmI1MGVmMTFkNWUwYikuQ0xPVURfSE9TVCkgdGhpcy5fb3B0aW9ucy5zZWN1cmUgPSB0cnVlO1xuICAgICAgICAvLyBTZXQgYSBjdXN0b20gbG9nIGZ1bmN0aW9uIGlmIHByZXNlbnRcbiAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMubG9nRnVuY3Rpb24pICgwLCAkMjU3OTQ3ZTkyOTI2Mjc3YSRleHBvcnQkMmUyYmNkODczOWFlMDM5KS5zZXRMb2dGdW5jdGlvbih0aGlzLl9vcHRpb25zLmxvZ0Z1bmN0aW9uKTtcbiAgICAgICAgKDAsICQyNTc5NDdlOTI5MjYyNzdhJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkpLmxvZ0xldmVsID0gdGhpcy5fb3B0aW9ucy5kZWJ1ZyB8fCAwO1xuICAgICAgICB0aGlzLl9hcGkgPSBuZXcgKDAsICRhYmYyNjY2NDE5MjdjZDg5JGV4cG9ydCQyYzRlODI1ZGM5MTIwZjg3KShvcHRpb25zKTtcbiAgICAgICAgdGhpcy5fc29ja2V0ID0gdGhpcy5fY3JlYXRlU2VydmVyQ29ubmVjdGlvbigpO1xuICAgICAgICAvLyBTYW5pdHkgY2hlY2tzXG4gICAgICAgIC8vIEVuc3VyZSBXZWJSVEMgc3VwcG9ydGVkXG4gICAgICAgIGlmICghKDAsICQ0ZjQxMzQxNTZjNDQ2MzkyJGV4cG9ydCQ3ZGViYjUwZWYxMWQ1ZTBiKS5zdXBwb3J0cy5hdWRpb1ZpZGVvICYmICEoMCwgJDRmNDEzNDE1NmM0NDYzOTIkZXhwb3J0JDdkZWJiNTBlZjExZDVlMGIpLnN1cHBvcnRzLmRhdGEpIHtcbiAgICAgICAgICAgIHRoaXMuX2RlbGF5ZWRBYm9ydCgoMCwgJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JDk1NDdhYWEyZTM5MDMwZmYpLkJyb3dzZXJJbmNvbXBhdGlibGUsIFwiVGhlIGN1cnJlbnQgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IFdlYlJUQ1wiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBFbnN1cmUgYWxwaGFudW1lcmljIGlkXG4gICAgICAgIGlmICghIXVzZXJJZCAmJiAhKDAsICQ0ZjQxMzQxNTZjNDQ2MzkyJGV4cG9ydCQ3ZGViYjUwZWYxMWQ1ZTBiKS52YWxpZGF0ZUlkKHVzZXJJZCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2RlbGF5ZWRBYm9ydCgoMCwgJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JDk1NDdhYWEyZTM5MDMwZmYpLkludmFsaWRJRCwgYElEIFwiJHt1c2VySWR9XCIgaXMgaW52YWxpZGApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1c2VySWQpIHRoaXMuX2luaXRpYWxpemUodXNlcklkKTtcbiAgICAgICAgZWxzZSB0aGlzLl9hcGkucmV0cmlldmVJZCgpLnRoZW4oKGlkKT0+dGhpcy5faW5pdGlhbGl6ZShpZCkpLmNhdGNoKChlcnJvcik9PnRoaXMuX2Fib3J0KCgwLCAkNzg0NTVlMjJkZWE5NmI4YyRleHBvcnQkOTU0N2FhYTJlMzkwMzBmZikuU2VydmVyRXJyb3IsIGVycm9yKSk7XG4gICAgfVxuICAgIF9jcmVhdGVTZXJ2ZXJDb25uZWN0aW9uKCkge1xuICAgICAgICBjb25zdCBzb2NrZXQgPSBuZXcgKDAsICQ4ZjViZmE2MDgzNmQyNjFkJGV4cG9ydCQ0Nzk4OTE3ZGJmMTQ5Yjc5KSh0aGlzLl9vcHRpb25zLnNlY3VyZSwgdGhpcy5fb3B0aW9ucy5ob3N0LCB0aGlzLl9vcHRpb25zLnBvcnQsIHRoaXMuX29wdGlvbnMucGF0aCwgdGhpcy5fb3B0aW9ucy5rZXksIHRoaXMuX29wdGlvbnMucGluZ0ludGVydmFsKTtcbiAgICAgICAgc29ja2V0Lm9uKCgwLCAkNzg0NTVlMjJkZWE5NmI4YyRleHBvcnQkM2I1YzRhNGI2MzU0ZjAyMykuTWVzc2FnZSwgKGRhdGEpPT57XG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVNZXNzYWdlKGRhdGEpO1xuICAgICAgICB9KTtcbiAgICAgICAgc29ja2V0Lm9uKCgwLCAkNzg0NTVlMjJkZWE5NmI4YyRleHBvcnQkM2I1YzRhNGI2MzU0ZjAyMykuRXJyb3IsIChlcnJvcik9PntcbiAgICAgICAgICAgIHRoaXMuX2Fib3J0KCgwLCAkNzg0NTVlMjJkZWE5NmI4YyRleHBvcnQkOTU0N2FhYTJlMzkwMzBmZikuU29ja2V0RXJyb3IsIGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHNvY2tldC5vbigoMCwgJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JDNiNWM0YTRiNjM1NGYwMjMpLkRpc2Nvbm5lY3RlZCwgKCk9PntcbiAgICAgICAgICAgIGlmICh0aGlzLmRpc2Nvbm5lY3RlZCkgcmV0dXJuO1xuICAgICAgICAgICAgdGhpcy5lbWl0RXJyb3IoKDAsICQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydCQ5NTQ3YWFhMmUzOTAzMGZmKS5OZXR3b3JrLCBcIkxvc3QgY29ubmVjdGlvbiB0byBzZXJ2ZXIuXCIpO1xuICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgICAgIH0pO1xuICAgICAgICBzb2NrZXQub24oKDAsICQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydCQzYjVjNGE0YjYzNTRmMDIzKS5DbG9zZSwgKCk9PntcbiAgICAgICAgICAgIGlmICh0aGlzLmRpc2Nvbm5lY3RlZCkgcmV0dXJuO1xuICAgICAgICAgICAgdGhpcy5fYWJvcnQoKDAsICQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydCQ5NTQ3YWFhMmUzOTAzMGZmKS5Tb2NrZXRDbG9zZWQsIFwiVW5kZXJseWluZyBzb2NrZXQgaXMgYWxyZWFkeSBjbG9zZWQuXCIpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHNvY2tldDtcbiAgICB9XG4gICAgLyoqIEluaXRpYWxpemUgYSBjb25uZWN0aW9uIHdpdGggdGhlIHNlcnZlci4gKi8gX2luaXRpYWxpemUoaWQpIHtcbiAgICAgICAgdGhpcy5faWQgPSBpZDtcbiAgICAgICAgdGhpcy5zb2NrZXQuc3RhcnQoaWQsIHRoaXMuX29wdGlvbnMudG9rZW4pO1xuICAgIH1cbiAgICAvKiogSGFuZGxlcyBtZXNzYWdlcyBmcm9tIHRoZSBzZXJ2ZXIuICovIF9oYW5kbGVNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IG1lc3NhZ2UudHlwZTtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IG1lc3NhZ2UucGF5bG9hZDtcbiAgICAgICAgY29uc3QgcGVlcklkID0gbWVzc2FnZS5zcmM7XG4gICAgICAgIHN3aXRjaCh0eXBlKXtcbiAgICAgICAgICAgIGNhc2UgKDAsICQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydCRhZGI0YTE3NTRkYTZmMTBkKS5PcGVuOlxuICAgICAgICAgICAgICAgIHRoaXMuX2xhc3RTZXJ2ZXJJZCA9IHRoaXMuaWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5fb3BlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwib3BlblwiLCB0aGlzLmlkKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgKDAsICQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydCRhZGI0YTE3NTRkYTZmMTBkKS5FcnJvcjpcbiAgICAgICAgICAgICAgICB0aGlzLl9hYm9ydCgoMCwgJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JDk1NDdhYWEyZTM5MDMwZmYpLlNlcnZlckVycm9yLCBwYXlsb2FkLm1zZyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICgwLCAkNzg0NTVlMjJkZWE5NmI4YyRleHBvcnQkYWRiNGExNzU0ZGE2ZjEwZCkuSWRUYWtlbjpcbiAgICAgICAgICAgICAgICB0aGlzLl9hYm9ydCgoMCwgJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JDk1NDdhYWEyZTM5MDMwZmYpLlVuYXZhaWxhYmxlSUQsIGBJRCBcIiR7dGhpcy5pZH1cIiBpcyB0YWtlbmApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAoMCwgJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JGFkYjRhMTc1NGRhNmYxMGQpLkludmFsaWRLZXk6XG4gICAgICAgICAgICAgICAgdGhpcy5fYWJvcnQoKDAsICQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydCQ5NTQ3YWFhMmUzOTAzMGZmKS5JbnZhbGlkS2V5LCBgQVBJIEtFWSBcIiR7dGhpcy5fb3B0aW9ucy5rZXl9XCIgaXMgaW52YWxpZGApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAoMCwgJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JGFkYjRhMTc1NGRhNmYxMGQpLkxlYXZlOlxuICAgICAgICAgICAgICAgICgwLCAkMjU3OTQ3ZTkyOTI2Mjc3YSRleHBvcnQkMmUyYmNkODczOWFlMDM5KS5sb2coYFJlY2VpdmVkIGxlYXZlIG1lc3NhZ2UgZnJvbSAke3BlZXJJZH1gKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jbGVhbnVwUGVlcihwZWVySWQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2Nvbm5lY3Rpb25zLmRlbGV0ZShwZWVySWQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAoMCwgJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JGFkYjRhMTc1NGRhNmYxMGQpLkV4cGlyZTpcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXRFcnJvcigoMCwgJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JDk1NDdhYWEyZTM5MDMwZmYpLlBlZXJVbmF2YWlsYWJsZSwgYENvdWxkIG5vdCBjb25uZWN0IHRvIHBlZXIgJHtwZWVySWR9YCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICgwLCAkNzg0NTVlMjJkZWE5NmI4YyRleHBvcnQkYWRiNGExNzU0ZGE2ZjEwZCkuT2ZmZXI6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBzaG91bGQgY29uc2lkZXIgc3dpdGNoaW5nIHRoaXMgdG8gQ0FMTC9DT05ORUNULCBidXQgdGhpcyBpcyB0aGUgbGVhc3QgYnJlYWtpbmcgb3B0aW9uLlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb25uZWN0aW9uSWQgPSBwYXlsb2FkLmNvbm5lY3Rpb25JZDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvbm5lY3Rpb24gPSB0aGlzLmdldENvbm5lY3Rpb24ocGVlcklkLCBjb25uZWN0aW9uSWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29ubmVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbi5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgKDAsICQyNTc5NDdlOTI5MjYyNzdhJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkpLndhcm4oYE9mZmVyIHJlY2VpdmVkIGZvciBleGlzdGluZyBDb25uZWN0aW9uIElEOiR7Y29ubmVjdGlvbklkfWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhIG5ldyBjb25uZWN0aW9uLlxuICAgICAgICAgICAgICAgICAgICBpZiAocGF5bG9hZC50eXBlID09PSAoMCwgJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JDMxNTdkNTdiNDEzNWUzYmMpLk1lZGlhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtZWRpYUNvbm5lY3Rpb24gPSBuZXcgKDAsICQ1YzFkMDhjN2M1N2RhOWEzJGV4cG9ydCQ0YTg0ZTk1YTIzMjRhYzI5KShwZWVySWQsIHRoaXMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uSWQ6IGNvbm5lY3Rpb25JZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcGF5bG9hZDogcGF5bG9hZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YTogcGF5bG9hZC5tZXRhZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uID0gbWVkaWFDb25uZWN0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkQ29ubmVjdGlvbihwZWVySWQsIGNvbm5lY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiY2FsbFwiLCBtZWRpYUNvbm5lY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBheWxvYWQudHlwZSA9PT0gKDAsICQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydCQzMTU3ZDU3YjQxMzVlM2JjKS5EYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhQ29ubmVjdGlvbiA9IG5ldyB0aGlzLl9zZXJpYWxpemVyc1twYXlsb2FkLnNlcmlhbGl6YXRpb25dKHBlZXJJZCwgdGhpcywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25JZDogY29ubmVjdGlvbklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9wYXlsb2FkOiBwYXlsb2FkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBwYXlsb2FkLm1ldGFkYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBwYXlsb2FkLmxhYmVsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcmlhbGl6YXRpb246IHBheWxvYWQuc2VyaWFsaXphdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWxpYWJsZTogcGF5bG9hZC5yZWxpYWJsZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uID0gZGF0YUNvbm5lY3Rpb247XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRDb25uZWN0aW9uKHBlZXJJZCwgY29ubmVjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJjb25uZWN0aW9uXCIsIGRhdGFDb25uZWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICgwLCAkMjU3OTQ3ZTkyOTI2Mjc3YSRleHBvcnQkMmUyYmNkODczOWFlMDM5KS53YXJuKGBSZWNlaXZlZCBtYWxmb3JtZWQgY29ubmVjdGlvbiB0eXBlOiR7cGF5bG9hZC50eXBlfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEZpbmQgbWVzc2FnZXMuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2VzID0gdGhpcy5fZ2V0TWVzc2FnZXMoY29ubmVjdGlvbklkKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBtZXNzYWdlIG9mIG1lc3NhZ2VzKWNvbm5lY3Rpb24uaGFuZGxlTWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcGF5bG9hZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgKDAsICQyNTc5NDdlOTI5MjYyNzdhJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkpLndhcm4oYFlvdSByZWNlaXZlZCBhIG1hbGZvcm1lZCBtZXNzYWdlIGZyb20gJHtwZWVySWR9IG9mIHR5cGUgJHt0eXBlfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbm5lY3Rpb25JZCA9IHBheWxvYWQuY29ubmVjdGlvbklkO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb25uZWN0aW9uID0gdGhpcy5nZXRDb25uZWN0aW9uKHBlZXJJZCwgY29ubmVjdGlvbklkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbm5lY3Rpb24gJiYgY29ubmVjdGlvbi5wZWVyQ29ubmVjdGlvbikgLy8gUGFzcyBpdCBvbi5cbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbi5oYW5kbGVNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjb25uZWN0aW9uSWQpIC8vIFN0b3JlIGZvciBwb3NzaWJsZSBsYXRlciB1c2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RvcmVNZXNzYWdlKGNvbm5lY3Rpb25JZCwgbWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgKDAsICQyNTc5NDdlOTI5MjYyNzdhJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkpLndhcm4oXCJZb3UgcmVjZWl2ZWQgYW4gdW5yZWNvZ25pemVkIG1lc3NhZ2U6XCIsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIFN0b3JlcyBtZXNzYWdlcyB3aXRob3V0IGEgc2V0IHVwIGNvbm5lY3Rpb24sIHRvIGJlIGNsYWltZWQgbGF0ZXIuICovIF9zdG9yZU1lc3NhZ2UoY29ubmVjdGlvbklkLCBtZXNzYWdlKSB7XG4gICAgICAgIGlmICghdGhpcy5fbG9zdE1lc3NhZ2VzLmhhcyhjb25uZWN0aW9uSWQpKSB0aGlzLl9sb3N0TWVzc2FnZXMuc2V0KGNvbm5lY3Rpb25JZCwgW10pO1xuICAgICAgICB0aGlzLl9sb3N0TWVzc2FnZXMuZ2V0KGNvbm5lY3Rpb25JZCkucHVzaChtZXNzYWdlKTtcbiAgICB9XG4gICAgLyoqXG5cdCAqIFJldHJpZXZlIG1lc3NhZ2VzIGZyb20gbG9zdCBtZXNzYWdlIHN0b3JlXG5cdCAqIEBpbnRlcm5hbFxuXHQgKi8gLy9UT0RPIENoYW5nZSBpdCB0byBwcml2YXRlXG4gICAgX2dldE1lc3NhZ2VzKGNvbm5lY3Rpb25JZCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlcyA9IHRoaXMuX2xvc3RNZXNzYWdlcy5nZXQoY29ubmVjdGlvbklkKTtcbiAgICAgICAgaWYgKG1lc3NhZ2VzKSB7XG4gICAgICAgICAgICB0aGlzLl9sb3N0TWVzc2FnZXMuZGVsZXRlKGNvbm5lY3Rpb25JZCk7XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICAvKipcblx0ICogQ29ubmVjdHMgdG8gdGhlIHJlbW90ZSBwZWVyIHNwZWNpZmllZCBieSBpZCBhbmQgcmV0dXJucyBhIGRhdGEgY29ubmVjdGlvbi5cblx0ICogQHBhcmFtIHBlZXIgVGhlIGJyb2tlcmluZyBJRCBvZiB0aGUgcmVtb3RlIHBlZXIgKHRoZWlyIHtAYXBpbGluayBQZWVyLmlkfSkuXG5cdCAqIEBwYXJhbSBvcHRpb25zIGZvciBzcGVjaWZ5aW5nIGRldGFpbHMgYWJvdXQgUGVlciBDb25uZWN0aW9uXG5cdCAqLyBjb25uZWN0KHBlZXIsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgICAgc2VyaWFsaXphdGlvbjogXCJkZWZhdWx0XCIsXG4gICAgICAgICAgICAuLi5vcHRpb25zXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLmRpc2Nvbm5lY3RlZCkge1xuICAgICAgICAgICAgKDAsICQyNTc5NDdlOTI5MjYyNzdhJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkpLndhcm4oXCJZb3UgY2Fubm90IGNvbm5lY3QgdG8gYSBuZXcgUGVlciBiZWNhdXNlIHlvdSBjYWxsZWQgLmRpc2Nvbm5lY3QoKSBvbiB0aGlzIFBlZXIgYW5kIGVuZGVkIHlvdXIgY29ubmVjdGlvbiB3aXRoIHRoZSBzZXJ2ZXIuIFlvdSBjYW4gY3JlYXRlIGEgbmV3IFBlZXIgdG8gcmVjb25uZWN0LCBvciBjYWxsIHJlY29ubmVjdCBvbiB0aGlzIHBlZXIgaWYgeW91IGJlbGlldmUgaXRzIElEIHRvIHN0aWxsIGJlIGF2YWlsYWJsZS5cIik7XG4gICAgICAgICAgICB0aGlzLmVtaXRFcnJvcigoMCwgJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JDk1NDdhYWEyZTM5MDMwZmYpLkRpc2Nvbm5lY3RlZCwgXCJDYW5ub3QgY29ubmVjdCB0byBuZXcgUGVlciBhZnRlciBkaXNjb25uZWN0aW5nIGZyb20gc2VydmVyLlwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRhQ29ubmVjdGlvbiA9IG5ldyB0aGlzLl9zZXJpYWxpemVyc1tvcHRpb25zLnNlcmlhbGl6YXRpb25dKHBlZXIsIHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9hZGRDb25uZWN0aW9uKHBlZXIsIGRhdGFDb25uZWN0aW9uKTtcbiAgICAgICAgcmV0dXJuIGRhdGFDb25uZWN0aW9uO1xuICAgIH1cbiAgICAvKipcblx0ICogQ2FsbHMgdGhlIHJlbW90ZSBwZWVyIHNwZWNpZmllZCBieSBpZCBhbmQgcmV0dXJucyBhIG1lZGlhIGNvbm5lY3Rpb24uXG5cdCAqIEBwYXJhbSBwZWVyIFRoZSBicm9rZXJpbmcgSUQgb2YgdGhlIHJlbW90ZSBwZWVyICh0aGVpciBwZWVyLmlkKS5cblx0ICogQHBhcmFtIHN0cmVhbSBUaGUgY2FsbGVyJ3MgbWVkaWEgc3RyZWFtXG5cdCAqIEBwYXJhbSBvcHRpb25zIE1ldGFkYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGUgY29ubmVjdGlvbiwgcGFzc2VkIGluIGJ5IHdob2V2ZXIgaW5pdGlhdGVkIHRoZSBjb25uZWN0aW9uLlxuXHQgKi8gY2FsbChwZWVyLCBzdHJlYW0sIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBpZiAodGhpcy5kaXNjb25uZWN0ZWQpIHtcbiAgICAgICAgICAgICgwLCAkMjU3OTQ3ZTkyOTI2Mjc3YSRleHBvcnQkMmUyYmNkODczOWFlMDM5KS53YXJuKFwiWW91IGNhbm5vdCBjb25uZWN0IHRvIGEgbmV3IFBlZXIgYmVjYXVzZSB5b3UgY2FsbGVkIC5kaXNjb25uZWN0KCkgb24gdGhpcyBQZWVyIGFuZCBlbmRlZCB5b3VyIGNvbm5lY3Rpb24gd2l0aCB0aGUgc2VydmVyLiBZb3UgY2FuIGNyZWF0ZSBhIG5ldyBQZWVyIHRvIHJlY29ubmVjdC5cIik7XG4gICAgICAgICAgICB0aGlzLmVtaXRFcnJvcigoMCwgJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JDk1NDdhYWEyZTM5MDMwZmYpLkRpc2Nvbm5lY3RlZCwgXCJDYW5ub3QgY29ubmVjdCB0byBuZXcgUGVlciBhZnRlciBkaXNjb25uZWN0aW5nIGZyb20gc2VydmVyLlwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXN0cmVhbSkge1xuICAgICAgICAgICAgKDAsICQyNTc5NDdlOTI5MjYyNzdhJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkpLmVycm9yKFwiVG8gY2FsbCBhIHBlZXIsIHlvdSBtdXN0IHByb3ZpZGUgYSBzdHJlYW0gZnJvbSB5b3VyIGJyb3dzZXIncyBgZ2V0VXNlck1lZGlhYC5cIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWVkaWFDb25uZWN0aW9uID0gbmV3ICgwLCAkNWMxZDA4YzdjNTdkYTlhMyRleHBvcnQkNGE4NGU5NWEyMzI0YWMyOSkocGVlciwgdGhpcywge1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIF9zdHJlYW06IHN0cmVhbVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fYWRkQ29ubmVjdGlvbihwZWVyLCBtZWRpYUNvbm5lY3Rpb24pO1xuICAgICAgICByZXR1cm4gbWVkaWFDb25uZWN0aW9uO1xuICAgIH1cbiAgICAvKiogQWRkIGEgZGF0YS9tZWRpYSBjb25uZWN0aW9uIHRvIHRoaXMgcGVlci4gKi8gX2FkZENvbm5lY3Rpb24ocGVlcklkLCBjb25uZWN0aW9uKSB7XG4gICAgICAgICgwLCAkMjU3OTQ3ZTkyOTI2Mjc3YSRleHBvcnQkMmUyYmNkODczOWFlMDM5KS5sb2coYGFkZCBjb25uZWN0aW9uICR7Y29ubmVjdGlvbi50eXBlfToke2Nvbm5lY3Rpb24uY29ubmVjdGlvbklkfSB0byBwZWVySWQ6JHtwZWVySWR9YCk7XG4gICAgICAgIGlmICghdGhpcy5fY29ubmVjdGlvbnMuaGFzKHBlZXJJZCkpIHRoaXMuX2Nvbm5lY3Rpb25zLnNldChwZWVySWQsIFtdKTtcbiAgICAgICAgdGhpcy5fY29ubmVjdGlvbnMuZ2V0KHBlZXJJZCkucHVzaChjb25uZWN0aW9uKTtcbiAgICB9XG4gICAgLy9UT0RPIHNob3VsZCBiZSBwcml2YXRlXG4gICAgX3JlbW92ZUNvbm5lY3Rpb24oY29ubmVjdGlvbikge1xuICAgICAgICBjb25zdCBjb25uZWN0aW9ucyA9IHRoaXMuX2Nvbm5lY3Rpb25zLmdldChjb25uZWN0aW9uLnBlZXIpO1xuICAgICAgICBpZiAoY29ubmVjdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gY29ubmVjdGlvbnMuaW5kZXhPZihjb25uZWN0aW9uKTtcbiAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIGNvbm5lY3Rpb25zLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgLy9yZW1vdmUgZnJvbSBsb3N0IG1lc3NhZ2VzXG4gICAgICAgIHRoaXMuX2xvc3RNZXNzYWdlcy5kZWxldGUoY29ubmVjdGlvbi5jb25uZWN0aW9uSWQpO1xuICAgIH1cbiAgICAvKiogUmV0cmlldmUgYSBkYXRhL21lZGlhIGNvbm5lY3Rpb24gZm9yIHRoaXMgcGVlci4gKi8gZ2V0Q29ubmVjdGlvbihwZWVySWQsIGNvbm5lY3Rpb25JZCkge1xuICAgICAgICBjb25zdCBjb25uZWN0aW9ucyA9IHRoaXMuX2Nvbm5lY3Rpb25zLmdldChwZWVySWQpO1xuICAgICAgICBpZiAoIWNvbm5lY3Rpb25zKSByZXR1cm4gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBjb25uZWN0aW9uIG9mIGNvbm5lY3Rpb25zKXtcbiAgICAgICAgICAgIGlmIChjb25uZWN0aW9uLmNvbm5lY3Rpb25JZCA9PT0gY29ubmVjdGlvbklkKSByZXR1cm4gY29ubmVjdGlvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgX2RlbGF5ZWRBYm9ydCh0eXBlLCBtZXNzYWdlKSB7XG4gICAgICAgIHNldFRpbWVvdXQoKCk9PntcbiAgICAgICAgICAgIHRoaXMuX2Fib3J0KHR5cGUsIG1lc3NhZ2UpO1xuICAgICAgICB9LCAwKTtcbiAgICB9XG4gICAgLyoqXG5cdCAqIEVtaXRzIGFuIGVycm9yIG1lc3NhZ2UgYW5kIGRlc3Ryb3lzIHRoZSBQZWVyLlxuXHQgKiBUaGUgUGVlciBpcyBub3QgZGVzdHJveWVkIGlmIGl0J3MgaW4gYSBkaXNjb25uZWN0ZWQgc3RhdGUsIGluIHdoaWNoIGNhc2Vcblx0ICogaXQgcmV0YWlucyBpdHMgZGlzY29ubmVjdGVkIHN0YXRlIGFuZCBpdHMgZXhpc3RpbmcgY29ubmVjdGlvbnMuXG5cdCAqLyBfYWJvcnQodHlwZSwgbWVzc2FnZSkge1xuICAgICAgICAoMCwgJDI1Nzk0N2U5MjkyNjI3N2EkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOSkuZXJyb3IoXCJBYm9ydGluZyFcIik7XG4gICAgICAgIHRoaXMuZW1pdEVycm9yKHR5cGUsIG1lc3NhZ2UpO1xuICAgICAgICBpZiAoIXRoaXMuX2xhc3RTZXJ2ZXJJZCkgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgIGVsc2UgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgfVxuICAgIC8qKlxuXHQgKiBEZXN0cm95cyB0aGUgUGVlcjogY2xvc2VzIGFsbCBhY3RpdmUgY29ubmVjdGlvbnMgYXMgd2VsbCBhcyB0aGUgY29ubmVjdGlvblxuXHQgKiB0byB0aGUgc2VydmVyLlxuXHQgKlxuXHQgKiA6OjpjYXV0aW9uXG5cdCAqIFRoaXMgY2Fubm90IGJlIHVuZG9uZTsgdGhlIHJlc3BlY3RpdmUgcGVlciBvYmplY3Qgd2lsbCBubyBsb25nZXIgYmUgYWJsZVxuXHQgKiB0byBjcmVhdGUgb3IgcmVjZWl2ZSBhbnkgY29ubmVjdGlvbnMsIGl0cyBJRCB3aWxsIGJlIGZvcmZlaXRlZCBvbiB0aGUgc2VydmVyLFxuXHQgKiBhbmQgYWxsIG9mIGl0cyBkYXRhIGFuZCBtZWRpYSBjb25uZWN0aW9ucyB3aWxsIGJlIGNsb3NlZC5cblx0ICogOjo6XG5cdCAqLyBkZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHJldHVybjtcbiAgICAgICAgKDAsICQyNTc5NDdlOTI5MjYyNzdhJGV4cG9ydCQyZTJiY2Q4NzM5YWUwMzkpLmxvZyhgRGVzdHJveSBwZWVyIHdpdGggSUQ6JHt0aGlzLmlkfWApO1xuICAgICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgdGhpcy5fY2xlYW51cCgpO1xuICAgICAgICB0aGlzLl9kZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmVtaXQoXCJjbG9zZVwiKTtcbiAgICB9XG4gICAgLyoqIERpc2Nvbm5lY3RzIGV2ZXJ5IGNvbm5lY3Rpb24gb24gdGhpcyBwZWVyLiAqLyBfY2xlYW51cCgpIHtcbiAgICAgICAgZm9yIChjb25zdCBwZWVySWQgb2YgdGhpcy5fY29ubmVjdGlvbnMua2V5cygpKXtcbiAgICAgICAgICAgIHRoaXMuX2NsZWFudXBQZWVyKHBlZXJJZCk7XG4gICAgICAgICAgICB0aGlzLl9jb25uZWN0aW9ucy5kZWxldGUocGVlcklkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNvY2tldC5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICB9XG4gICAgLyoqIENsb3NlcyBhbGwgY29ubmVjdGlvbnMgdG8gdGhpcyBwZWVyLiAqLyBfY2xlYW51cFBlZXIocGVlcklkKSB7XG4gICAgICAgIGNvbnN0IGNvbm5lY3Rpb25zID0gdGhpcy5fY29ubmVjdGlvbnMuZ2V0KHBlZXJJZCk7XG4gICAgICAgIGlmICghY29ubmVjdGlvbnMpIHJldHVybjtcbiAgICAgICAgZm9yIChjb25zdCBjb25uZWN0aW9uIG9mIGNvbm5lY3Rpb25zKWNvbm5lY3Rpb24uY2xvc2UoKTtcbiAgICB9XG4gICAgLyoqXG5cdCAqIERpc2Nvbm5lY3RzIHRoZSBQZWVyJ3MgY29ubmVjdGlvbiB0byB0aGUgUGVlclNlcnZlci4gRG9lcyBub3QgY2xvc2UgYW55XG5cdCAqICBhY3RpdmUgY29ubmVjdGlvbnMuXG5cdCAqIFdhcm5pbmc6IFRoZSBwZWVyIGNhbiBubyBsb25nZXIgY3JlYXRlIG9yIGFjY2VwdCBjb25uZWN0aW9ucyBhZnRlciBiZWluZ1xuXHQgKiAgZGlzY29ubmVjdGVkLiBJdCBhbHNvIGNhbm5vdCByZWNvbm5lY3QgdG8gdGhlIHNlcnZlci5cblx0ICovIGRpc2Nvbm5lY3QoKSB7XG4gICAgICAgIGlmICh0aGlzLmRpc2Nvbm5lY3RlZCkgcmV0dXJuO1xuICAgICAgICBjb25zdCBjdXJyZW50SWQgPSB0aGlzLmlkO1xuICAgICAgICAoMCwgJDI1Nzk0N2U5MjkyNjI3N2EkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOSkubG9nKGBEaXNjb25uZWN0IHBlZXIgd2l0aCBJRDoke2N1cnJlbnRJZH1gKTtcbiAgICAgICAgdGhpcy5fZGlzY29ubmVjdGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fb3BlbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNvY2tldC5jbG9zZSgpO1xuICAgICAgICB0aGlzLl9sYXN0U2VydmVySWQgPSBjdXJyZW50SWQ7XG4gICAgICAgIHRoaXMuX2lkID0gbnVsbDtcbiAgICAgICAgdGhpcy5lbWl0KFwiZGlzY29ubmVjdGVkXCIsIGN1cnJlbnRJZCk7XG4gICAgfVxuICAgIC8qKiBBdHRlbXB0cyB0byByZWNvbm5lY3Qgd2l0aCB0aGUgc2FtZSBJRC5cblx0ICpcblx0ICogT25seSB7QGFwaWxpbmsgUGVlci5kaXNjb25uZWN0IHwgZGlzY29ubmVjdGVkIHBlZXJzfSBjYW4gYmUgcmVjb25uZWN0ZWQuXG5cdCAqIERlc3Ryb3llZCBwZWVycyBjYW5ub3QgYmUgcmVjb25uZWN0ZWQuXG5cdCAqIElmIHRoZSBjb25uZWN0aW9uIGZhaWxzIChhcyBhbiBleGFtcGxlLCBpZiB0aGUgcGVlcidzIG9sZCBJRCBpcyBub3cgdGFrZW4pLFxuXHQgKiB0aGUgcGVlcidzIGV4aXN0aW5nIGNvbm5lY3Rpb25zIHdpbGwgbm90IGNsb3NlLCBidXQgYW55IGFzc29jaWF0ZWQgZXJyb3JzIGV2ZW50cyB3aWxsIGZpcmUuXG5cdCAqLyByZWNvbm5lY3QoKSB7XG4gICAgICAgIGlmICh0aGlzLmRpc2Nvbm5lY3RlZCAmJiAhdGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgICgwLCAkMjU3OTQ3ZTkyOTI2Mjc3YSRleHBvcnQkMmUyYmNkODczOWFlMDM5KS5sb2coYEF0dGVtcHRpbmcgcmVjb25uZWN0aW9uIHRvIHNlcnZlciB3aXRoIElEICR7dGhpcy5fbGFzdFNlcnZlcklkfWApO1xuICAgICAgICAgICAgdGhpcy5fZGlzY29ubmVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9pbml0aWFsaXplKHRoaXMuX2xhc3RTZXJ2ZXJJZCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5kZXN0cm95ZWQpIHRocm93IG5ldyBFcnJvcihcIlRoaXMgcGVlciBjYW5ub3QgcmVjb25uZWN0IHRvIHRoZSBzZXJ2ZXIuIEl0IGhhcyBhbHJlYWR5IGJlZW4gZGVzdHJveWVkLlwiKTtcbiAgICAgICAgZWxzZSBpZiAoIXRoaXMuZGlzY29ubmVjdGVkICYmICF0aGlzLm9wZW4pIC8vIERvIG5vdGhpbmcuIFdlJ3JlIHN0aWxsIGNvbm5lY3RpbmcgdGhlIGZpcnN0IHRpbWUuXG4gICAgICAgICgwLCAkMjU3OTQ3ZTkyOTI2Mjc3YSRleHBvcnQkMmUyYmNkODczOWFlMDM5KS5lcnJvcihcIkluIGEgaHVycnk/IFdlJ3JlIHN0aWxsIHRyeWluZyB0byBtYWtlIHRoZSBpbml0aWFsIGNvbm5lY3Rpb24hXCIpO1xuICAgICAgICBlbHNlIHRocm93IG5ldyBFcnJvcihgUGVlciAke3RoaXMuaWR9IGNhbm5vdCByZWNvbm5lY3QgYmVjYXVzZSBpdCBpcyBub3QgZGlzY29ubmVjdGVkIGZyb20gdGhlIHNlcnZlciFgKTtcbiAgICB9XG4gICAgLyoqXG5cdCAqIEdldCBhIGxpc3Qgb2YgYXZhaWxhYmxlIHBlZXIgSURzLiBJZiB5b3UncmUgcnVubmluZyB5b3VyIG93biBzZXJ2ZXIsIHlvdSdsbFxuXHQgKiB3YW50IHRvIHNldCBhbGxvd19kaXNjb3Zlcnk6IHRydWUgaW4gdGhlIFBlZXJTZXJ2ZXIgb3B0aW9ucy4gSWYgeW91J3JlIHVzaW5nXG5cdCAqIHRoZSBjbG91ZCBzZXJ2ZXIsIGVtYWlsIHRlYW1AcGVlcmpzLmNvbSB0byBnZXQgdGhlIGZ1bmN0aW9uYWxpdHkgZW5hYmxlZCBmb3Jcblx0ICogeW91ciBrZXkuXG5cdCAqLyBsaXN0QWxsUGVlcnMoY2IgPSAoXyk9Pnt9KSB7XG4gICAgICAgIHRoaXMuX2FwaS5saXN0QWxsUGVlcnMoKS50aGVuKChwZWVycyk9PmNiKHBlZXJzKSkuY2F0Y2goKGVycm9yKT0+dGhpcy5fYWJvcnQoKDAsICQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydCQ5NTQ3YWFhMmUzOTAzMGZmKS5TZXJ2ZXJFcnJvciwgZXJyb3IpKTtcbiAgICB9XG59XG5cblxuXG5cblxuXG5jbGFzcyAkMjBkYmU2ODE0OWQ3YWFkOSRleHBvcnQkNzJhYTQ0NjEyZTIyMDBjZCBleHRlbmRzICgwLCAkNjM2NmM0Y2ExNjFiYzI5NyRleHBvcnQkZDM2NWY3YWQ5ZDdkZjljOSkge1xuICAgIGNvbnN0cnVjdG9yKHBlZXJJZCwgcHJvdmlkZXIsIG9wdGlvbnMpe1xuICAgICAgICBzdXBlcihwZWVySWQsIHByb3ZpZGVyLCB7XG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgcmVsaWFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX0NIVU5LX1NJWkUgPSAzMjc2ODtcbiAgICAgICAgdGhpcy5fc3BsaXRTdHJlYW0gPSBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogKGNodW5rLCBjb250cm9sbGVyKT0+e1xuICAgICAgICAgICAgICAgIGZvcihsZXQgc3BsaXQgPSAwOyBzcGxpdCA8IGNodW5rLmxlbmd0aDsgc3BsaXQgKz0gdGhpcy5fQ0hVTktfU0laRSljb250cm9sbGVyLmVucXVldWUoY2h1bmsuc3ViYXJyYXkoc3BsaXQsIHNwbGl0ICsgdGhpcy5fQ0hVTktfU0laRSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fcmF3U2VuZFN0cmVhbSA9IG5ldyBXcml0YWJsZVN0cmVhbSh7XG4gICAgICAgICAgICB3cml0ZTogYXN5bmMgKGNodW5rLCBjb250cm9sbGVyKT0+e1xuICAgICAgICAgICAgICAgIGNvbnN0IG9wZW5FdmVudCA9IG5ldyBQcm9taXNlKChyZXNvbHZlKT0+dGhpcy5kYXRhQ2hhbm5lbC5hZGRFdmVudExpc3RlbmVyKFwiYnVmZmVyZWRhbW91bnRsb3dcIiwgcmVzb2x2ZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25jZTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgLy8gaWYgd2UgY2FuIHNlbmQgdGhlIGNodW5rIG5vdywgc2VuZCBpdFxuICAgICAgICAgICAgICAgIC8vIGlmIG5vdCwgd2Ugd2FpdCB1bnRpbCBhdCBsZWFzdCBoYWxmIG9mIHRoZSBzZW5kaW5nIGJ1ZmZlciBpcyBmcmVlIGFnYWluXG4gICAgICAgICAgICAgICAgYXdhaXQgKHRoaXMuZGF0YUNoYW5uZWwuYnVmZmVyZWRBbW91bnQgPD0gKDAsICQ2MzY2YzRjYTE2MWJjMjk3JGV4cG9ydCRkMzY1ZjdhZDlkN2RmOWM5KS5NQVhfQlVGRkVSRURfQU1PVU5UIC0gY2h1bmsuYnl0ZUxlbmd0aCB8fCBvcGVuRXZlbnQpO1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IHdoYXQgY2FuIGdvIHdyb25nIGhlcmU/XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRhQ2hhbm5lbC5zZW5kKGNodW5rKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICgwLCAkMjU3OTQ3ZTkyOTI2Mjc3YSRleHBvcnQkMmUyYmNkODczOWFlMDM5KS5lcnJvcihgREMjOiR7dGhpcy5jb25uZWN0aW9uSWR9IEVycm9yIHdoZW4gc2VuZGluZzpgLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lcnJvcihlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMud3JpdGVyID0gdGhpcy5fc3BsaXRTdHJlYW0ud3JpdGFibGUuZ2V0V3JpdGVyKCk7XG4gICAgICAgIHRoaXMuX3Jhd1JlYWRTdHJlYW0gPSBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgICAgICAgc3RhcnQ6IChjb250cm9sbGVyKT0+e1xuICAgICAgICAgICAgICAgIHRoaXMub25jZShcIm9wZW5cIiwgKCk9PntcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRhQ2hhbm5lbC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCAoZSk9PntcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShlLmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3NwbGl0U3RyZWFtLnJlYWRhYmxlLnBpcGVUbyh0aGlzLl9yYXdTZW5kU3RyZWFtKTtcbiAgICB9XG4gICAgX2luaXRpYWxpemVEYXRhQ2hhbm5lbChkYykge1xuICAgICAgICBzdXBlci5faW5pdGlhbGl6ZURhdGFDaGFubmVsKGRjKTtcbiAgICAgICAgdGhpcy5kYXRhQ2hhbm5lbC5iaW5hcnlUeXBlID0gXCJhcnJheWJ1ZmZlclwiO1xuICAgICAgICB0aGlzLmRhdGFDaGFubmVsLmJ1ZmZlcmVkQW1vdW50TG93VGhyZXNob2xkID0gKDAsICQ2MzY2YzRjYTE2MWJjMjk3JGV4cG9ydCRkMzY1ZjdhZDlkN2RmOWM5KS5NQVhfQlVGRkVSRURfQU1PVU5UIC8gMjtcbiAgICB9XG59XG5cblxuY2xhc3MgJDZlMzkyMzBhYjM2Mzk2YWQkZXhwb3J0JDgwZjVkZTFhNjZjNGQ2MjQgZXh0ZW5kcyAoMCwgJDIwZGJlNjgxNDlkN2FhZDkkZXhwb3J0JDcyYWE0NDYxMmUyMjAwY2QpIHtcbiAgICBjb25zdHJ1Y3RvcihwZWVySWQsIHByb3ZpZGVyLCBvcHRpb25zKXtcbiAgICAgICAgc3VwZXIocGVlcklkLCBwcm92aWRlciwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuc2VyaWFsaXphdGlvbiA9IFwiTXNnUGFja1wiO1xuICAgICAgICB0aGlzLl9lbmNvZGVyID0gbmV3ICgwLCAkZ0NjYlkkRW5jb2RlcikoKTtcbiAgICAgICAgKGFzeW5jICgpPT57XG4gICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IG1zZyBvZiAoMCwgJGdDY2JZJGRlY29kZU11bHRpU3RyZWFtKSh0aGlzLl9yYXdSZWFkU3RyZWFtKSl7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIGlmIChtc2cuX19wZWVyRGF0YT8udHlwZSA9PT0gXCJjbG9zZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkYXRhXCIsIG1zZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKCk7XG4gICAgfVxuICAgIF9zZW5kKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud3JpdGVyLndyaXRlKHRoaXMuX2VuY29kZXIuZW5jb2RlKGRhdGEpKTtcbiAgICB9XG59XG5cblxuY2xhc3MgJDFlMGFmZjE2YmUyYzMyOGUkZXhwb3J0JGQ3MmM3YmY4ZWVmNTA4NTMgZXh0ZW5kcyAoMCwgJDQxNjI2MGJjZTMzN2RmOTAkZXhwb3J0JGVjZDFmYzEzNmM0MjI0NDgpIHtcbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKXtcbiAgICAgICAgc3VwZXIoLi4uYXJncyk7XG4gICAgICAgIHRoaXMuX3NlcmlhbGl6ZXJzID0ge1xuICAgICAgICAgICAgTXNnUGFjazogJDZlMzkyMzBhYjM2Mzk2YWQkZXhwb3J0JDgwZjVkZTFhNjZjNGQ2MjQsXG4gICAgICAgICAgICBkZWZhdWx0OiAoMCwgJDZlMzkyMzBhYjM2Mzk2YWQkZXhwb3J0JDgwZjVkZTFhNjZjNGQ2MjQpXG4gICAgICAgIH07XG4gICAgfVxufVxuXG5cblxuXG5cblxuXG52YXIgJGRkMDE4N2Q3ZjI4ZTM4NmYkZXhwb3J0JDJlMmJjZDg3MzlhZTAzOSA9ICgwLCAkNDE2MjYwYmNlMzM3ZGY5MCRleHBvcnQkZWNkMWZjMTM2YzQyMjQ0OCk7XG5cblxuZXhwb3J0IHskZGQwMTg3ZDdmMjhlMzg2ZiRleHBvcnQkMmUyYmNkODczOWFlMDM5IGFzIGRlZmF1bHQsICQ0ZjQxMzQxNTZjNDQ2MzkyJGV4cG9ydCQ3ZGViYjUwZWYxMWQ1ZTBiIGFzIHV0aWwsICRhMjI5YmVkYmNhYTZjYTIzJGV4cG9ydCRmZjdjOWQ0YzExZDk0ZThiIGFzIEJ1ZmZlcmVkQ29ubmVjdGlvbiwgJDIwZGJlNjgxNDlkN2FhZDkkZXhwb3J0JDcyYWE0NDYxMmUyMjAwY2QgYXMgU3RyZWFtQ29ubmVjdGlvbiwgJDZlMzkyMzBhYjM2Mzk2YWQkZXhwb3J0JDgwZjVkZTFhNjZjNGQ2MjQgYXMgTXNnUGFjaywgJDQxNjI2MGJjZTMzN2RmOTAkZXhwb3J0JGVjZDFmYzEzNmM0MjI0NDggYXMgUGVlciwgJDFlMGFmZjE2YmUyYzMyOGUkZXhwb3J0JGQ3MmM3YmY4ZWVmNTA4NTMgYXMgTXNnUGFja1BlZXIsICQyMzc3OWQxODgxMTU3YTE4JGV4cG9ydCQ5ODg3MTg4MmY0OTJkZTgyIGFzIFBlZXJFcnJvciwgJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JDMxNTdkNTdiNDEzNWUzYmMgYXMgQ29ubmVjdGlvblR5cGUsICQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydCQ5NTQ3YWFhMmUzOTAzMGZmIGFzIFBlZXJFcnJvclR5cGUsICQ3ODQ1NWUyMmRlYTk2YjhjJGV4cG9ydCQ3OTc0OTM1Njg2MTQ5Njg2IGFzIEJhc2VDb25uZWN0aW9uRXJyb3JUeXBlLCAkNzg0NTVlMjJkZWE5NmI4YyRleHBvcnQkNDlhZTgwMGMxMTRkZjQxZCBhcyBEYXRhQ29ubmVjdGlvbkVycm9yVHlwZSwgJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JDg5ZjUwN2NmOTg2YTk0NyBhcyBTZXJpYWxpemF0aW9uVHlwZSwgJDc4NDU1ZTIyZGVhOTZiOGMkZXhwb3J0JDNiNWM0YTRiNjM1NGYwMjMgYXMgU29ja2V0RXZlbnRUeXBlLCAkNzg0NTVlMjJkZWE5NmI4YyRleHBvcnQkYWRiNGExNzU0ZGE2ZjEwZCBhcyBTZXJ2ZXJNZXNzYWdlVHlwZX07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1idW5kbGVyLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/peerjs/dist/bundler.mjs\n");

/***/ })

};
;